Let's explore how events are used in these practical and complex scenarios, focusing on their benefits for decoupling and communication.

### 1\. In a real-time stock trading dashboard, how would you use events to notify UI of stock price changes?

In a real-time stock trading dashboard, events are the **ideal mechanism** for notifying the UI of stock price changes because they provide a highly efficient, loosely coupled, and responsive way for the data source to push updates to all interested UI components.

**Scenario:**
You have a backend service that receives real-time stock quotes (e.g., from a market data feed). The UI dashboard displays prices for multiple stocks, and these displays need to update instantly when a new quote arrives.

**Solution using Events (Publisher-Subscriber):**

1.  **Publisher (StockPriceFeed/MarketDataProvider):** This component is responsible for receiving the raw market data and transforming it into meaningful updates. It will raise events for each stock price change.

    ```csharp
    using System;
    using System.Collections.Generic;
    using System.Threading;
    using System.Threading.Tasks;

    // EventArgs to carry the stock price update data
    public class StockPriceUpdateEventArgs : EventArgs
    {
        public string Symbol { get; }
        public decimal Price { get; }
        public DateTime Timestamp { get; }

        public StockPriceUpdateEventArgs(string symbol, decimal price, DateTime timestamp)
        {
            Symbol = symbol;
            Price = price;
            Timestamp = timestamp;
        }
    }

    // Publisher: Simulates a real-time stock price feed
    public class StockPriceFeed
    {
        // Event to notify subscribers of price changes
        public event EventHandler<StockPriceUpdateEventArgs> PriceUpdated;

        private bool _isRunning = false;
        private CancellationTokenSource _cts;
        private Random _random = new Random();

        // Protected method to safely raise the event
        protected virtual void OnPriceUpdated(StockPriceUpdateEventArgs e)
        {
            PriceUpdated?.Invoke(this, e);
        }

        public async Task StartFeed(string[] symbols)
        {
            if (_isRunning) return;
            _isRunning = true;
            _cts = new CancellationTokenSource();
            Console.WriteLine("[Feed] Starting stock price feed...");

            // Simulate continuous price updates for each symbol
            foreach (var symbol in symbols)
            {
                // Each symbol gets its own task to simulate parallel updates
                _ = Task.Run(async () =>
                {
                    decimal currentPrice = _random.Next(50, 500); // Initial price
                    while (!_cts.Token.IsCancellationRequested)
                    {
                        // Simulate price fluctuation
                        currentPrice += (decimal)(_random.NextDouble() * 2 - 1); // -1 to +1 change
                        currentPrice = Math.Round(Math.Max(1m, currentPrice), 2); // Ensure positive, 2 decimal places

                        // Raise the event
                        OnPriceUpdated(new StockPriceUpdateEventArgs(symbol, currentPrice, DateTime.Now));
                        await Task.Delay(_random.Next(50, 500)); // Simulate variable update frequency
                    }
                }, _cts.Token);
            }
        }

        public void StopFeed()
        {
            if (_isRunning)
            {
                _cts?.Cancel();
                _isRunning = false;
                Console.WriteLine("[Feed] Stock price feed stopped.");
            }
        }
    }
    ```

2.  **Subscribers (UI Components):** These are the individual widgets or controls on the dashboard that display stock prices. They will subscribe to the `PriceUpdated` event.

    ```csharp
    using System.Windows.Forms; // Example for a WinForms UI context (concept applies to WPF/Blazor etc.)

    // Subscriber: A UI control that displays a single stock's price
    public class StockPriceDisplayControl : UserControl // Inherits from UserControl for WinForms
    {
        private string _symbol;
        private Label _symbolLabel;
        private Label _priceLabel;
        private Label _timestampLabel;

        public StockPriceDisplayControl(string symbol)
        {
            _symbol = symbol;
            InitializeComponent();
            this.BorderStyle = BorderStyle.FixedSingle;
            this.Size = new System.Drawing.Size(200, 70);
        }

        private void InitializeComponent()
        {
            _symbolLabel = new Label { Text = _symbol, Font = new System.Drawing.Font("Arial", 12, System.Drawing.FontStyle.Bold), Location = new System.Drawing.Point(5, 5) };
            _priceLabel = new Label { Text = "Loading...", Font = new System.Drawing.Font("Arial", 14, System.Drawing.FontStyle.Bold), Location = new System.Drawing.Point(5, 25) };
            _timestampLabel = new Label { Text = "", Font = new System.Drawing.Font("Arial", 8), Location = new System.Drawing.Point(5, 50) };

            this.Controls.Add(_symbolLabel);
            this.Controls.Add(_priceLabel);
            this.Controls.Add(_timestampLabel);
        }

        // Event handler method to update the UI
        public void UpdatePrice(object sender, StockPriceUpdateEventArgs e)
        {
            // IMPORTANT: UI updates must happen on the UI thread.
            // In WinForms/WPF, use Invoke/Dispatcher. In Blazor, StateHasChanged.
            if (this.InvokeRequired)
            {
                this.Invoke(new Action(() => UpdatePrice(sender, e)));
                return;
            }

            if (e.Symbol == _symbol) // Ensure this update is for our stock
            {
                _priceLabel.Text = e.Price.ToString("C2"); // Format as currency
                _timestampLabel.Text = e.Timestamp.ToString("HH:mm:ss.fff");
                // Optional: Change color for price up/down
            }
        }

        // Remember to unsubscribe when the control is no longer needed (e.g., on Dispose)
        protected override void Dispose(bool disposing)
        {
            if (disposing && MarketDashboardForm.GlobalPriceFeed != null) // Access global feed for unsubscribe
            {
                MarketDashboardForm.GlobalPriceFeed.PriceUpdated -= UpdatePrice;
            }
            base.Dispose(disposing);
        }
    }

    // Main Dashboard Form (Container)
    public class MarketDashboardForm : Form
    {
        public static StockPriceFeed GlobalPriceFeed = new StockPriceFeed(); // Singleton-like feed

        private Dictionary<string, StockPriceDisplayControl> _displayControls = new Dictionary<string, StockPriceDisplayControl>();

        public MarketDashboardForm()
        {
            this.Text = "Real-Time Stock Dashboard";
            this.Size = new System.Drawing.Size(600, 400);
            this.Load += MarketDashboardForm_Load;
            this.FormClosing += MarketDashboardForm_FormClosing;
        }

        private async void MarketDashboardForm_Load(object sender, EventArgs e)
        {
            string[] stocksToMonitor = { "AAPL", "GOOGL", "MSFT", "AMZN", "TSLA" };
            int x = 10, y = 10;
            int count = 0;

            foreach (string symbol in stocksToMonitor)
            {
                StockPriceDisplayControl control = new StockPriceDisplayControl(symbol);
                control.Location = new System.Drawing.Point(x, y);
                this.Controls.Add(control);
                _displayControls[symbol] = control;

                // Subscribe each control to the global price feed event
                GlobalPriceFeed.PriceUpdated += control.UpdatePrice;

                x += 210; // Move to next column
                count++;
                if (count % 2 == 0) // New row every 2 controls
                {
                    x = 10;
                    y += 80;
                }
            }

            // Start the feed
            await GlobalPriceFeed.StartFeed(stocksToMonitor);
        }

        private void MarketDashboardForm_FormClosing(object sender, FormClosingEventArgs e)
        {
            GlobalPriceFeed.StopFeed(); // Stop the feed when the form closes
        }

        public static void Main()
        {
            Application.Run(new MarketDashboardForm());
        }
    }
    ```

**How Events Achieve This:**

  * **Decoupling:** The `StockPriceFeed` has no knowledge of `StockPriceDisplayControl` or any other UI component. It just raises a generic `PriceUpdated` event. This means you could swap out your UI framework, add new display types (charts, tables), or even a logging service, without changing the `StockPriceFeed`.
  * **Real-time Push:** As soon as a new price is available, the `StockPriceFeed` pushes it out via the event. Subscribers react immediately without constant polling.
  * **Efficiency:** Only interested parties receive the updates. If a control is displaying "AAPL", it only reacts to "AAPL" updates, even if the event broadcasts "GOOGL" updates too.
  * **Scalability:** Adding new stock display controls or other subscribers (e.g., an alert system) simply means subscribing them to the existing event. The publisher doesn't need to be modified.
  * **Flexibility:** Different UI components can choose to react differently to the same event (e.g., one shows price, another shows volume, another sounds an alarm).
  * **Centralized Data Source:** The `StockPriceFeed` acts as a single, authoritative source of market data, and events ensure consistent updates across all consumers.

This event-driven architecture is fundamental for building responsive, scalable, and maintainable real-time dashboards.

### 2\. You’re designing a plugin architecture—how can events be used to trigger plugin actions at runtime?

Events are essential for enabling communication and triggering actions within a plugin architecture without the host application needing direct knowledge of specific plugin implementations.

**Scenario:**
You have a host application (e.g., a document editor) that allows users to install plugins. These plugins should react to specific actions within the host (e.g., document saved, text selected, new tab opened) or expose actions that the host can trigger.

**Solution using Events:**

1.  **Host Defines "Hooks" as Events:** The host application provides well-defined events that represent points where plugins can "hook in."
2.  **Plugins Register Event Handlers:** Plugins, upon loading, subscribe to these host-defined events with their own internal methods.
3.  **Host Publishes Events:** When a relevant action occurs in the host, it raises the corresponding event.
4.  **Host Exposes Action-Triggering Events (Less Common, but possible):** The host might also expose events that *it subscribes to*, and plugins can *raise* these events to request the host to perform an action (e.g., `Host.FileOpenRequested += plugin.RequestFileOpen;` or a more general `Host.ExecuteHostAction`). This is less common than the host triggering plugin actions. A more direct way is for plugins to register *delegates* with the host that the host can *invoke*, or for plugins to implement host-defined *interfaces*.

Let's focus on the host triggering plugin actions.

```csharp
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;

// --- Shared Interfaces/Delegates (Host and Plugins reference this assembly) ---

public interface IHostContext
{
    void Log(string message);
    // Potentially expose events for plugins to subscribe to
    event EventHandler<DocumentSavedEventArgs> DocumentSaved;
    event EventHandler<TextSelectedEventArgs> TextSelected;
}

public class DocumentSavedEventArgs : EventArgs
{
    public string FilePath { get; }
    public DocumentSavedEventArgs(string path) { FilePath = path; }
}

public class TextSelectedEventArgs : EventArgs
{
    public string SelectedText { get; }
    public TextSelectedEventArgs(string text) { SelectedText = text; }
}

public interface IPlugin
{
    string Name { get; }
    string Description { get; }
    // Plugins might get a reference to the host context to subscribe to its events
    void Initialize(IHostContext hostContext);
    void Shutdown();
}

// --- Host Application ---

public class DocumentEditorHost : IHostContext
{
    private List<IPlugin> _loadedPlugins = new List<IPlugin>();

    // Events that plugins can subscribe to
    public event EventHandler<DocumentSavedEventArgs> DocumentSaved;
    public event EventHandler<TextSelectedEventArgs> TextSelected;

    public void Log(string message) => Console.WriteLine($"[Host Log] {message}");

    protected virtual void OnDocumentSaved(DocumentSavedEventArgs e)
    {
        Log($"Document '{e.FilePath}' saved. Notifying plugins.");
        DocumentSaved?.Invoke(this, e);
    }

    protected virtual void OnTextSelected(TextSelectedEventArgs e)
    {
        Log($"Text selected: '{e.SelectedText}'. Notifying plugins.");
        TextSelected?.Invoke(this, e);
    }

    public void LoadPlugins(string pluginFolder)
    {
        Log($"Loading plugins from: {pluginFolder}");
        foreach (string dllFile in Directory.GetFiles(pluginFolder, "*.dll"))
        {
            try
            {
                Assembly assembly = Assembly.LoadFrom(dllFile);
                foreach (Type type in assembly.GetTypes())
                {
                    if (typeof(IPlugin).IsAssignableFrom(type) && !type.IsInterface && !type.IsAbstract)
                    {
                        IPlugin plugin = Activator.CreateInstance(type) as IPlugin;
                        if (plugin != null)
                        {
                            _loadedPlugins.Add(plugin);
                            plugin.Initialize(this); // Initialize plugin, allowing it to subscribe
                            Log($"Loaded plugin: {plugin.Name}");
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Log($"Error loading plugin from {dllFile}: {ex.Message}");
            }
        }
    }

    public void SimulateUserActions()
    {
        Console.WriteLine("\n--- Simulating User Actions ---");
        OnDocumentSaved(new DocumentSavedEventArgs("report.docx"));
        OnTextSelected(new TextSelectedEventArgs("important phrase"));
        OnDocumentSaved(new DocumentSavedEventArgs("presentation.pptx"));
        OnTextSelected(new TextSelectedEventArgs("another piece of text"));
    }

    public void ShutdownPlugins()
    {
        Console.WriteLine("\n--- Shutting Down Plugins ---");
        foreach (var plugin in _loadedPlugins)
        {
            plugin.Shutdown();
            Log($"Plugin {plugin.Name} shut down.");
        }
        _loadedPlugins.Clear();
    }
}

// --- Plugin Implementations (in separate DLLs) ---

// Plugin 1: Auto-Save Monitor
public class AutoSaveMonitorPlugin : IPlugin
{
    public string Name => "Auto-Save Monitor";
    public string Description => "Monitors document saves and logs them.";

    public void Initialize(IHostContext hostContext)
    {
        // Subscribe to the host's DocumentSaved event
        hostContext.DocumentSaved += Host_DocumentSaved;
        hostContext.Log($"[{Name}] Initialized and subscribed to DocumentSaved.");
    }

    private void Host_DocumentSaved(object sender, DocumentSavedEventArgs e)
    {
        Console.WriteLine($"  [{Name}] Document '{e.FilePath}' was saved. Recording for audit.");
    }

    public void Shutdown()
    {
        // Important: Unsubscribe if the host provides a way to get IHostContext back
        // Or if the host manages subscriptions via WeakEventManager.
        // For simplicity, this example assumes host life cycle ends soon after plugins.
        Console.WriteLine($"[{Name}] Shutting down.");
    }
}

// Plugin 2: Text Analyzer
public class TextAnalyzerPlugin : IPlugin
{
    public string Name => "Text Analyzer";
    public string Description => "Analyzes selected text for keywords.";

    public void Initialize(IHostContext hostContext)
    {
        // Subscribe to the host's TextSelected event
        hostContext.TextSelected += Host_TextSelected;
        hostContext.Log($"[{Name}] Initialized and subscribed to TextSelected.");
    }

    private void Host_TextSelected(object sender, TextSelectedEventArgs e)
    {
        Console.WriteLine($"  [{Name}] Analyzing selected text: '{e.SelectedText}'");
        if (e.SelectedText.Contains("important", StringComparison.OrdinalIgnoreCase))
        {
            Console.WriteLine($"    [{Name}] Keyword 'important' found!");
        }
    }

    public void Shutdown()
    {
        Console.WriteLine($"[{Name}] Shutting down.");
    }
}

public class PluginArchitectureExample
{
    public static async Task Main(string[] args)
    {
        string pluginFolder = "Plugins";
        if (!Directory.Exists(pluginFolder))
        {
            Directory.CreateDirectory(pluginFolder);
        }

        // Simulate building plugin DLLs (in a real scenario, this is done by a build system)
        // For demonstration, we just need the PluginAssembly.dll to exist.
        // Copy the compiled AutoSaveMonitorPlugin and TextAnalyzerPlugin to the "Plugins" folder.
        // (You'd typically compile these as separate class libraries)
        // To make this runnable, you would manually compile AutoSaveMonitorPlugin and TextAnalyzerPlugin
        // into DLLs in a "Plugins" subfolder.
        // Example for AutoSaveMonitorPlugin (assuming you put this in a separate .cs file in a library project):
        // public class AutoSaveMonitorPlugin : IPlugin { /* ... code ... */ }

        DocumentEditorHost host = new DocumentEditorHost();

        // Simulate plugin DLLs being present in the "Plugins" folder
        // For this console app, you'd compile the plugin code above into separate DLLs
        // and place them in a 'Plugins' directory relative to your executable.
        // For a quick test, you can just manually instantiate them:
        // host._loadedPlugins.Add(new AutoSaveMonitorPlugin());
        // host._loadedPlugins.Add(new TextAnalyzerPlugin());
        // (And then call plugin.Initialize(host) for each)

        // For actual runtime loading, you need the DLLs.
        // Compile the plugin code as separate class library projects and copy their DLLs
        // to a 'Plugins' folder relative to your main executable.
        // E.g., a project named 'MyPlugins.AutoSave' builds to MyPlugins.AutoSave.dll
        // and copy it to YourApp/bin/Debug/netX.Y/Plugins/MyPlugins.AutoSave.dll

        // Placeholder for demonstration without actual DLL compilation setup:
        // Manually create instances and initialize them, as if they were loaded.
        // In a real app, Assembly.LoadFrom would handle this.
        IPlugin autoSavePlugin = new AutoSaveMonitorPlugin();
        autoSavePlugin.Initialize(host);
        host._loadedPlugins.Add(autoSavePlugin);

        IPlugin textAnalyzerPlugin = new TextAnalyzerPlugin();
        textAnalyzerPlugin.Initialize(host);
        host._loadedPlugins.Add(textAnalyzerPlugin);


        host.SimulateUserActions();

        host.ShutdownPlugins();
    }
}
```

**How Events Trigger Plugin Actions:**

  * **Decoupling:** The `DocumentEditorHost` knows *that* it has a `DocumentSaved` event, but it doesn't know *which* plugins are subscribed or *what* they will do in response. This keeps the host's core logic clean and independent of specific plugin functionalities.
  * **Dynamic Behavior:** Plugins can be loaded at runtime, and as part of their `Initialize` method, they dynamically subscribe to the host's events. This allows new functionalities to be added without modifying the host's compile-time code.
  * **Extensibility:** New types of plugins can be created by simply implementing `IPlugin` and subscribing to the relevant host events. The host remains "closed for modification, open for extension."
  * **Centralized Notification:** The host provides a single, consistent way to notify about application-wide events. Any number of plugins can listen to the same event.
  * **Contextual Data:** The `EventArgs` classes (`DocumentSavedEventArgs`, `TextSelectedEventArgs`) ensure that relevant context (like `FilePath` or `SelectedText`) is passed to the plugins when an event is triggered.

### 3\. In a file upload system, how can you notify progress or completion to consumers using events?

Events are perfectly suited for progress notification and completion callbacks in long-running operations like file uploads. This allows a client (UI, another service) to receive granular updates without polling the upload component.

**Scenario:**
A component responsible for uploading a large file needs to provide feedback to the user interface (e.g., a progress bar) and notify other services upon completion (success/failure).

**Solution using Events:**

1.  **Publisher (FileUploadService):** This service performs the actual upload and raises events for progress and completion.

    ```csharp
    using System;
    using System.Threading.Tasks;
    using System.Threading; // For Task.Delay

    // EventArgs for upload progress
    public class UploadProgressEventArgs : EventArgs
    {
        public string FileName { get; }
        public long BytesTransferred { get; }
        public long TotalBytes { get; }
        public int Percentage { get; }

        public UploadProgressEventArgs(string fileName, long transferred, long total)
        {
            FileName = fileName;
            BytesTransferred = transferred;
            TotalBytes = total;
            Percentage = (int)((double)BytesTransferred / TotalBytes * 100);
        }
    }

    // EventArgs for upload completion
    public class UploadCompletedEventArgs : EventArgs
    {
        public string FileName { get; }
        public bool IsSuccess { get; }
        public string ErrorMessage { get; }

        public UploadCompletedEventArgs(string fileName, bool success, string errorMessage = null)
        {
            FileName = fileName;
            IsSuccess = success;
            ErrorMessage = errorMessage;
        }
    }

    // Publisher: File Upload Service
    public class FileUploadService
    {
        // Events for progress and completion
        public event EventHandler<UploadProgressEventArgs> UploadProgress;
        public event EventHandler<UploadCompletedEventArgs> UploadCompleted;

        protected virtual void OnUploadProgress(UploadProgressEventArgs e)
        {
            UploadProgress?.Invoke(this, e);
        }

        protected virtual void OnUploadCompleted(UploadCompletedEventArgs e)
        {
            UploadCompleted?.Invoke(this, e);
        }

        public async Task UploadFile(string filePath)
        {
            string fileName = Path.GetFileName(filePath);
            Console.WriteLine($"[Uploader] Starting upload for '{fileName}'...");

            long fileSize = new FileInfo(filePath).Length; // Simulate file size
            long chunkSize = fileSize / 10; // Simulate 10 chunks
            if (chunkSize == 0) chunkSize = 1; // At least one chunk for tiny files

            try
            {
                for (int i = 0; i <= 10; i++) // Simulate 0% to 100% in 10 steps
                {
                    long bytesTransferred = (long)(chunkSize * i);
                    if (bytesTransferred > fileSize) bytesTransferred = fileSize;

                    // Simulate network delay
                    await Task.Delay(200);

                    // Simulate failure for a specific file or condition
                    if (fileName.Contains("fail", StringComparison.OrdinalIgnoreCase) && i >= 5)
                    {
                        throw new InvalidOperationException("Simulated network error during transfer.");
                    }

                    // Raise progress event
                    OnUploadProgress(new UploadProgressEventArgs(fileName, bytesTransferred, fileSize));
                }
                // Raise completion event (success)
                OnUploadCompleted(new UploadCompletedEventArgs(fileName, true));
                Console.WriteLine($"[Uploader] Upload of '{fileName}' completed successfully.");
            }
            catch (Exception ex)
            {
                // Raise completion event (failure)
                OnUploadCompleted(new UploadCompletedEventArgs(fileName, false, ex.Message));
                Console.WriteLine($"[Uploader] Upload of '{fileName}' failed: {ex.Message}");
            }
        }
    }
    ```

2.  **Consumers (UI Progress Bar, Notification Service, Audit Log):** These components subscribe to the events to react to the upload's status.

    ```csharp
    // Consumer: UI component (e.g., a form)
    public class UploadDashboardForm : Form
    {
        private ProgressBar _progressBar;
        private Label _statusLabel;
        private FileUploadService _uploadService;

        public UploadDashboardForm()
        {
            this.Text = "File Upload Progress";
            this.Size = new System.Drawing.Size(400, 150);

            _progressBar = new ProgressBar { Location = new System.Drawing.Point(10, 20), Size = new System.Drawing.Size(360, 25) };
            _statusLabel = new Label { Text = "Ready to upload...", Location = new System.Drawing.Point(10, 60), AutoSize = true };
            Button uploadButton = new Button { Text = "Upload Test File", Location = new System.Drawing.Point(10, 90) };
            Button uploadFailButton = new Button { Text = "Upload Fail File", Location = new System.Drawing.Point(150, 90) };

            this.Controls.Add(_progressBar);
            this.Controls.Add(_statusLabel);
            this.Controls.Add(uploadButton);
            this.Controls.Add(uploadFailButton);

            _uploadService = new FileUploadService();

            // Subscribe to events
            _uploadService.UploadProgress += HandleUploadProgress;
            _uploadService.UploadCompleted += HandleUploadCompleted;

            uploadButton.Click += async (s, e) => await _uploadService.UploadFile("test_file.txt");
            uploadFailButton.Click += async (s, e) => await _uploadService.UploadFile("fail_file.txt");
        }

        // Event handler for progress updates
        private void HandleUploadProgress(object sender, UploadProgressEventArgs e)
        {
            // IMPORTANT: Marshal to UI thread if in a different thread context
            if (this.InvokeRequired)
            {
                this.Invoke(new Action(() => HandleUploadProgress(sender, e)));
                return;
            }
            _progressBar.Value = e.Percentage;
            _statusLabel.Text = $"Uploading {e.FileName}: {e.Percentage}% ({e.BytesTransferred}/{e.TotalBytes} bytes)";
        }

        // Event handler for completion updates
        private void HandleUploadCompleted(object sender, UploadCompletedEventArgs e)
        {
            if (this.InvokeRequired)
            {
                this.Invoke(new Action(() => HandleUploadCompleted(sender, e)));
                return;
            }
            if (e.IsSuccess)
            {
                _statusLabel.Text = $"Upload of {e.FileName} completed successfully!";
                _progressBar.Value = 100;
                Console.WriteLine($"[UI] Success notification for {e.FileName}.");
            }
            else
            {
                _statusLabel.Text = $"Upload of {e.FileName} failed: {e.ErrorMessage}";
                Console.WriteLine($"[UI] Failure notification for {e.FileName}: {e.ErrorMessage}");
            }
        }

        // Example: Another service listening for completion (e.g., for logging or further processing)
        public static void Main()
        {
            // Set up a global file upload service (or inject)
            FileUploadService globalUploader = new FileUploadService();

            // Subscribe an audit logger lambda to the completion event
            globalUploader.UploadCompleted += (sender, e) =>
            {
                Console.WriteLine($"[Audit Log] File: {e.FileName}, Status: {(e.IsSuccess ? "Success" : "Failed")}, Error: {e.ErrorMessage ?? "N/A"}");
            };

            // Use the service in a form for progress display
            Application.Run(new UploadDashboardForm());
        }
    }
    ```

**How Events Help Notify Progress/Completion:**

  * **Real-time Feedback:** Events allow the `FileUploadService` to push granular progress updates (`UploadProgressEventArgs`) as they happen, enabling a smooth UI experience with progress bars.
  * **Decoupling of Concerns:** The `FileUploadService` is solely responsible for the upload logic. It doesn't know about UI components, loggers, or notification services. It simply raises events. Consumers are responsible for how they react.
  * **Multiple Consumers:** Any number of consumers can subscribe to the `UploadProgress` and `UploadCompleted` events. A UI can show a progress bar, a logger can record transfer details, and a notification service can send an email upon completion, all reacting to the same events.
  * **Clear State Transitions:** The `UploadCompleted` event provides a clear signal about the final state of the upload (success or failure), including any error messages.
  * **Non-Blocking:** The `FileUploadService` raises events asynchronously (in this example, within an `async Task` method), ensuring the UI thread remains responsive and the application doesn't freeze during the upload.

### 4\. How would you build a loosely coupled logging mechanism using events across layers?

Events are an excellent choice for a loosely coupled logging mechanism. They allow different parts of an application (various layers like UI, business logic, data access) to emit log messages without knowing how or where those messages are actually processed (e.g., written to console, file, database, cloud service).

**Scenario:**
You need a logging framework where different modules or layers of your application can log messages, but the actual logging destination (sink) should be configurable and easily swappable without affecting the code that emits the logs.

**Solution using Events (and Strategy Pattern):**

1.  **Centralized Logger (Publisher):** A core `Logger` class acts as the central hub for emitting log messages. It defines an event that log consumers will subscribe to.

    ```csharp
    using System;
    using System.Collections.Generic;

    public enum LogLevel
    {
        Debug,
        Info,
        Warning,
        Error,
        Critical
    }

    // EventArgs to carry log message data
    public class LogMessageEventArgs : EventArgs
    {
        public LogLevel Level { get; }
        public string Message { get; }
        public DateTime Timestamp { get; }
        public string CallerMemberName { get; } // For context

        public LogMessageEventArgs(LogLevel level, string message,
                                   [System.Runtime.CompilerServices.CallerMemberName] string callerMember = "")
        {
            Level = level;
            Message = message;
            Timestamp = DateTime.Now;
            CallerMemberName = callerMember;
        }
    }

    // Publisher: Central Logging Hub
    public class ApplicationLogger
    {
        // Singleton pattern (optional, but common for loggers)
        private static ApplicationLogger _instance;
        public static ApplicationLogger Instance => _instance ?? (_instance = new ApplicationLogger());

        // Event for log messages
        public event EventHandler<LogMessageEventArgs> LogMessageReceived;

        private ApplicationLogger() { } // Private constructor for singleton

        // Public methods for emitting log messages
        public void Log(LogLevel level, string message,
                        [System.Runtime.CompilerServices.CallerMemberName] string callerMember = "")
        {
            OnLogMessageReceived(new LogMessageEventArgs(level, message, callerMember));
        }

        public void Debug(string message, [System.Runtime.CompilerServices.CallerMemberName] string callerMember = "") =>
            Log(LogLevel.Debug, message, callerMember);
        public void Info(string message, [System.Runtime.CompilerServices.CallerMemberName] string callerMember = "") =>
            Log(LogLevel.Info, message, callerMember);
        public void Warning(string message, [System.Runtime.CompilerServices.CallerMemberName] string callerMember = "") =>
            Log(LogLevel.Warning, message, callerMember);
        public void Error(string message, [System.Runtime.CompilerServices.CallerMemberName] string callerMember = "") =>
            Log(LogLevel.Error, message, callerMember);
        public void Critical(string message, [System.Runtime.CompilerServices.CallerMemberName] string callerMember = "") =>
            Log(LogLevel.Critical, message, callerMember);

        protected virtual void OnLogMessageReceived(LogMessageEventArgs e)
        {
            LogMessageReceived?.Invoke(this, e);
        }
    }
    ```

2.  **Log Sinks (Subscribers):** These classes or methods subscribe to the `LogMessageReceived` event and implement the actual logic for writing logs to different destinations.

    ```csharp
    using System.IO;

    // Subscriber: Console Log Sink
    public class ConsoleLogSink
    {
        public void HandleLogMessage(object sender, LogMessageEventArgs e)
        {
            string log = $"{e.Timestamp:HH:mm:ss} [{e.Level.ToString().ToUpper()}] ({e.CallerMemberName}) - {e.Message}";
            switch (e.Level)
            {
                case LogLevel.Error:
                case LogLevel.Critical:
                    Console.ForegroundColor = ConsoleColor.Red;
                    break;
                case LogLevel.Warning:
                    Console.ForegroundColor = ConsoleColor.Yellow;
                    break;
                case LogLevel.Info:
                    Console.ForegroundColor = ConsoleColor.Green;
                    break;
                default:
                    Console.ResetColor();
                    break;
            }
            Console.WriteLine(log);
            Console.ResetColor();
        }
    }

    // Subscriber: File Log Sink
    public class FileLogSink
    {
        private readonly string _logFilePath;
        public FileLogSink(string filePath)
        {
            _logFilePath = filePath;
            File.AppendAllText(_logFilePath, $"--- Log Session Started: {DateTime.Now} ---\n");
        }

        public void HandleLogMessage(object sender, LogMessageEventArgs e)
        {
            string log = $"{e.Timestamp:yyyy-MM-dd HH:mm:ss} [{e.Level.ToString().ToUpper()}] ({e.CallerMemberName}) - {e.Message}";
            File.AppendAllText(_logFilePath, log + Environment.NewLine);
        }
    }

    // Subscriber: Database Log Sink (simplified)
    public class DatabaseLogSink
    {
        public void HandleLogMessage(object sender, LogMessageEventArgs e)
        {
            // In a real app, this would insert into a DB table
            Console.WriteLine($"[DB Log] Storing {e.Level} message from {e.CallerMemberName}: {e.Message}");
        }
    }

    public class LooselyCoupledLoggingExample
    {
        public static void Main(string[] args)
        {
            Console.WriteLine("--- Loosely Coupled Logging Example ---");

            // Instantiate log sinks
            ConsoleLogSink consoleSink = new ConsoleLogSink();
            FileLogSink fileSink = new FileLogSink("app.log");
            DatabaseLogSink dbSink = new DatabaseLogSink();

            // Subscribe sinks to the central logger's event
            ApplicationLogger.Instance.LogMessageReceived += consoleSink.HandleLogMessage;
            ApplicationLogger.Instance.LogMessageReceived += fileSink.HandleLogMessage;
            ApplicationLogger.Instance.LogMessageReceived += dbSink.HandleLogMessage;

            // Log messages from different "layers" or parts of the application
            SimulateApplicationActivity();

            // Dynamically change logging (e.g., remove console for production)
            ApplicationLogger.Instance.LogMessageReceived -= consoleSink.HandleLogMessage;
            Console.WriteLine("\nConsole logging disabled.");
            ApplicationLogger.Instance.Info("Console logging has been unsubscribed.");
            ApplicationLogger.Instance.Error("This error will only go to file and DB now.");

            // Clear the log file after demo (optional)
            // File.Delete("app.log");
        }

        public static void SimulateApplicationActivity()
        {
            ApplicationLogger.Instance.Debug("Starting application initialization."); // CallerMemberName will be SimulateApplicationActivity
            ApplicationLogger.Instance.Info("User 'JohnDoe' logged in.");
            PerformBusinessLogic();
            ApplicationLogger.Instance.Warning("Low disk space detected on C: drive.");
            AccessDatabase();
            ApplicationLogger.Instance.Critical("Application crashed due to unhandled exception!");
        }

        public static void PerformBusinessLogic()
        {
            ApplicationLogger.Instance.Info("Executing complex business rules.");
            // ... some logic ...
            ApplicationLogger.Instance.Debug("Validation passed for transaction #123.");
        }

        public static void AccessDatabase()
        {
            ApplicationLogger.Instance.Info("Attempting to connect to database.");
            // ... database operations ...
            ApplicationLogger.Instance.Error("Failed to retrieve data from 'Customers' table.");
        }
    }
    ```

**How Events Achieve Loosely Coupled Logging:**

  * **Decoupling:** The code that *generates* log messages (`ApplicationLogger.Instance.Info(...)`) has no direct dependency on the code that *consumes* or persists those messages (e.g., `ConsoleLogSink`, `FileLogSink`). The `ApplicationLogger` simply raises an event, fulfilling its publisher role.
  * **Flexibility and Extensibility:**
      * Adding a new logging destination (e.g., a cloud logging service like Azure Log Analytics, AWS CloudWatch, or a custom analytics system) simply involves creating a new subscriber and hooking it up to the `LogMessageReceived` event. No modifications are needed to the `ApplicationLogger` or any of the code that *emits* logs.
      * Logging destinations can be changed at runtime (e.g., subscribing/unsubscribing sinks based on configuration or environment) without recompiling the application.
  * **Separation of Concerns:** The responsibility of *what* to log is separate from *how* to log it. This makes both parts of the system easier to develop, test, and maintain independently.
  * **Scalability:** If an application generates a high volume of logs, you can implement asynchronous log sinks or batching within the subscribers to handle the load without blocking the main application thread.
  * **Testability:** You can easily test that your application logic correctly emits log messages by subscribing a mock log sink and asserting that it received the expected messages, without actually writing to files or databases during unit tests.

This event-driven approach forms the foundation of many robust logging frameworks.

### 5\. In a multi-module system, how do you prevent one module’s event from unintentionally affecting another?

In multi-module systems, especially those using an event-driven architecture, preventing unintentional side effects is critical for maintaining module independence and avoiding "spaghetti code." Here's how to do it:

1.  **Well-Defined Event Contracts (EventArgs):**

      * **Explanation:** Each event should have a clear `EventArgs` class (or a specific delegate signature) that defines *exactly* what information is conveyed. Avoid generic `EventArgs` if specific data is needed.
      * **Prevention:** Ensures subscribers only receive relevant data. If Module A needs `ProductId` and `Quantity`, its event should provide only that, not irrelevant data that could be misused by Module B. This limits the "surface area" of information that could unintentionally impact another module.

2.  **Specific Event Naming and Purpose:**

      * **Explanation:** Events should be named clearly to indicate their purpose and what has happened. E.g., `OrderPlaced`, `InventoryAdjusted`, `UserAuthenticated`.
      * **Prevention:** Helps modules subscribe only to events that are genuinely relevant to them. A module interested in `OrderPlaced` won't accidentally process an `InventoryAdjusted` event if the names are distinct. Vague event names like `DataChanged` make it harder to discriminate.

3.  **Strict Contextual Data in `EventArgs`:**

      * **Explanation:** `EventArgs` should contain all necessary context for the subscriber to make an informed decision *without querying the publisher or other modules*. For example, `OrderPlacedEventArgs` should include the `OrderId`, `CustomerId`, `TotalAmount`, etc., rather than forcing subscribers to go back to an `OrderService` to fetch these details using just an `OrderId`.
      * **Prevention:** Prevents subscribers from making assumptions or performing complex lookups that might inadvertently trigger other, unintended side effects. If a subscriber has all data, it's self-contained.

4.  **Avoiding Mutable `EventArgs` (or Clear Guidelines):**

      * **Explanation:** If `EventArgs` properties are mutable, a subscriber could modify the event data, affecting subsequent subscribers down the invocation chain. This is highly problematic.
      * **Prevention:** Make `EventArgs` properties **read-only** (get-only, often set via constructor). If mutability is absolutely necessary (e.g., a "cancelable" event), document it clearly and use patterns like `CancelEventArgs`.
      * **Example of Mutable EventArgs Issue:**
        ```csharp
        public class MutableDataEventArgs : EventArgs { public int Value {get; set;} } // PROBLEM: settable
        // ...
        publisher.MyEvent += (s,e) => e.Value = 100; // Subscriber changes data
        publisher.MyEvent += (s,e) => Console.WriteLine(e.Value); // This listener sees 100, not original
        ```

5.  **Targeted Subscriptions and Granularity:**

      * **Explanation:** Subscribers should subscribe only to the *specific events* they need. If a module is only interested in "User Login Failed" and not "User Logged In," it should only subscribe to the former.
      * **Prevention:** Reduces the chance of a module reacting to irrelevant events. Designing events with appropriate granularity helps here (e.g., separate events for "ItemAddedToCart" and "ItemRemovedFromCart" rather than a single "CartChanged" event).

6.  **Event Aggregators/Message Buses with Message Types:**

      * **Explanation:** In larger multi-module systems, a dedicated Event Aggregator or Message Bus (e.g., using libraries like MediatR, Prism's EventAggregator, or a simple custom one) can sit between publishers and subscribers. Instead of direct event subscriptions, publishers "publish messages" to the bus, and subscribers "subscribe to message types" from the bus.
      * **Prevention:**
          * **Decoupling from Publisher:** Subscribers don't even need a direct reference to the publisher; they subscribe to a message type from the aggregator.
          * **Type Safety:** Messages are often strong-typed, ensuring only handlers for that specific message type are invoked.
          * **Explicit Intent:** It makes the flow of messages very explicit.
          * **Filtering/Routing:** More advanced aggregators can include features for filtering messages based on content or routing them to specific handlers, providing another layer of control.

7.  **Clear Documentation and Architectural Guidelines:**

      * **Explanation:** Document the purpose of each event, the data it carries, and expected typical use cases. Establish architectural guidelines for inter-module communication.
      * **Prevention:** Educates developers on the intended use of events and discourages misuse or unintentional reactions.

8.  **Limiting Event Visibility (Internal):**

      * **Explanation:** If an event is only intended for use within the same assembly (module), declare it as `internal`.
      * **Prevention:** Prevents other assemblies from even seeing or subscribing to the event, enforcing modular boundaries at compile time.

By combining these strategies, you can leverage the power of events for loosely coupled communication while effectively managing complexity and preventing unintended side effects in multi-module systems.