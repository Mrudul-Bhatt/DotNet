Let's explore these common object-oriented design and debugging scenarios in C\#.

-----

### 1\. You are asked to model a Student object for a university system. What properties and methods would you include in the class?

When modeling a `Student` object, we need to consider both the data (properties) that defines a student and the actions (methods) that a student object can perform or that can be performed on it within the university system.

**Considerations for a `Student` Class:**

  * **Identity:** Unique identifiers.
  * **Personal Information:** Basic biographical data.
  * **Academic Information:** Data related to their studies.
  * **Contact Information:** Ways to reach the student.
  * **Enrollment Status:** Their current relationship with the university.
  * **Financial Information (Optional, sometimes separate):** Tuition, fees, scholarships.
  * **Behavior:** Actions related to their student life (e.g., enrolling, dropping, checking grades).

**Example `Student` Class Definition:**

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

public class Student
{
    // --- Properties (Data/State) ---

    // Identity
    public int StudentId { get; private set; } // Unique identifier, usually set by the system
    public string UniversityId { get; private set; } // University-assigned ID (e.g., 'U1234567')

    // Personal Information
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public DateTime DateOfBirth { get; set; }
    public Gender Gender { get; set; } // Using an enum for clarity

    // Contact Information
    public string Email { get; set; }
    public string PhoneNumber { get; set; }
    public Address HomeAddress { get; set; } // Complex type for address

    // Academic Information
    public Department MajorDepartment { get; set; } // Reference to a Department object
    public DegreeProgram EnrolledProgram { get; set; } // Reference to a DegreeProgram object
    public int CurrentCredits { get; private set; } // Total credits currently enrolled in
    public List<CourseEnrollment> Enrollments { get; private set; } // List of courses they are enrolled in
    public Dictionary<string, decimal> CourseGrades { get; private set; } // Key: CourseCode, Value: GPA for course
    public decimal GPA { get; private set; } // Computed property for overall GPA

    // Enrollment Status
    public EnrollmentStatus Status { get; private set; } // Using an enum

    // Financial (simplified, might be in a separate FinancialRecord class)
    public bool HasOutstandingBalance { get; private set; }


    // --- Constructors ---

    // Parameterized constructor for initial creation
    public Student(int studentId, string universityId, string firstName, string lastName, DateTime dob, Gender gender,
                   string email, string phoneNumber, Address homeAddress,
                   Department majorDepartment, DegreeProgram enrolledProgram)
    {
        StudentId = studentId;
        UniversityId = universityId;
        FirstName = firstName;
        LastName = lastName;
        DateOfBirth = dob;
        Gender = gender;
        Email = email;
        PhoneNumber = phoneNumber;
        HomeAddress = homeAddress;
        MajorDepartment = majorDepartment;
        EnrolledProgram = enrolledProgram;

        Enrollments = new List<CourseEnrollment>();
        CourseGrades = new Dictionary<string, decimal>();
        CurrentCredits = 0;
        GPA = 0.0m;
        Status = EnrollmentStatus.Active; // Default status
        HasOutstandingBalance = false;
    }

    // Default constructor (if needed, but parameterized is often better for domain objects)
    public Student()
    {
        StudentId = GenerateNewStudentId(); // Assuming a helper for ID generation
        UniversityId = GenerateNewUniversityId();
        FirstName = string.Empty;
        LastName = string.Empty;
        Email = string.Empty;
        PhoneNumber = string.Empty;
        HomeAddress = new Address();
        Enrollments = new List<CourseEnrollment>();
        CourseGrades = new Dictionary<string, decimal>();
        CurrentCredits = 0;
        GPA = 0.0m;
        Status = EnrollmentStatus.Prospective;
    }

    // --- Methods (Behavior) ---

    /// <summary>
    /// Enrolls the student in a specified course.
    /// </summary>
    public void EnrollInCourse(Course course)
    {
        if (course == null)
            throw new ArgumentNullException(nameof(course));
        if (Enrollments.Any(e => e.Course.CourseCode == course.CourseCode))
        {
            Console.WriteLine($"{FirstName} is already enrolled in {course.CourseCode}.");
            return;
        }
        Enrollments.Add(new CourseEnrollment(course, this));
        CurrentCredits += course.Credits;
        Console.WriteLine($"{FirstName} enrolled in {course.CourseCode} - {course.Title}.");
    }

    /// <summary>
    /// Drops a student from a course.
    /// </summary>
    public void DropCourse(string courseCode)
    {
        var enrollment = Enrollments.FirstOrDefault(e => e.Course.CourseCode == courseCode);
        if (enrollment != null)
        {
            Enrollments.Remove(enrollment);
            CurrentCredits -= enrollment.Course.Credits;
            Console.WriteLine($"{FirstName} dropped {courseCode}.");
        }
        else
        {
            Console.WriteLine($"{FirstName} is not enrolled in {courseCode}.");
        }
    }

    /// <summary>
    /// Records a grade for a course and updates GPA.
    /// </summary>
    public void RecordGrade(string courseCode, decimal gradePoint) // e.g., 4.0 for A, 3.0 for B
    {
        if (string.IsNullOrWhiteSpace(courseCode))
            throw new ArgumentException("Course code cannot be empty.", nameof(courseCode));
        if (gradePoint < 0 || gradePoint > 4.0m) // Assuming 0-4 scale
            throw new ArgumentOutOfRangeException(nameof(gradePoint), "Grade point must be between 0.0 and 4.0.");

        if (CourseGrades.ContainsKey(courseCode))
        {
            CourseGrades[courseCode] = gradePoint;
        }
        else
        {
            CourseGrades.Add(courseCode, gradePoint);
        }
        UpdateOverallGPA(); // Recalculate GPA after new grade
        Console.WriteLine($"Recorded grade {gradePoint} for {courseCode} for {FirstName}.");
    }

    /// <summary>
    /// Internal method to recalculate overall GPA.
    /// </summary>
    private void UpdateOverallGPA()
    {
        if (CourseGrades.Any())
        {
            // Simplified GPA calculation: sum of grade points / number of courses.
            // A real system would weigh by credits.
            GPA = CourseGrades.Values.Average();
        }
        else
        {
            GPA = 0.0m;
        }
    }

    /// <summary>
    /// Changes the student's enrollment status.
    /// </summary>
    public void ChangeStatus(EnrollmentStatus newStatus)
    {
        Status = newStatus;
        Console.WriteLine($"{FirstName}'s status changed to {newStatus}.");
    }

    /// <summary>
    /// Displays a summary of the student's information.
    /// </summary>
    public void DisplayStudentSummary()
    {
        Console.WriteLine($"\n--- Student Summary: {FirstName} {LastName} ({UniversityId}) ---");
        Console.WriteLine($"  Status: {Status}");
        Console.WriteLine($"  Major: {MajorDepartment?.Name}");
        Console.WriteLine($"  Program: {EnrolledProgram?.Name}");
        Console.WriteLine($"  Current GPA: {GPA:F2}");
        Console.WriteLine($"  Enrolled Courses ({CurrentCredits} credits):");
        if (!Enrollments.Any())
        {
            Console.WriteLine("    No current enrollments.");
        }
        foreach (var enrollment in Enrollments)
        {
            Console.WriteLine($"    - {enrollment.Course.CourseCode}: {enrollment.Course.Title}");
        }
        Console.WriteLine("------------------------------------------");
    }


    // --- Helper Methods (often static or in a separate utility class) ---
    private static int _nextStudentId = 1000;
    private static int GenerateNewStudentId() => _nextStudentId++;
    private static int _nextUniversityId = 100000;
    private static string GenerateNewUniversityId() => $"U{_nextUniversityId++}";

    // --- Nested/Supporting Enums and Classes ---
    public enum Gender { Male, Female, Other }
    public enum EnrollmentStatus { Prospective, Active, OnLeave, Graduated, Suspended, Alumni }

    // Simplified supporting classes (would be full classes in a real system)
    public class Address { public string Street { get; set; } = ""; public string City { get; set; } = ""; /* ... */ }
    public class Department { public string Name { get; set; } = ""; public string Code { get; set; } = ""; }
    public class DegreeProgram { public string Name { get; set; } = ""; public string Level { get; set; } = ""; }
    public class Course { public string CourseCode { get; set; } = ""; public string Title { get; set; } = ""; public int Credits { get; set; } }
    public class CourseEnrollment
    {
        public Course Course { get; }
        public Student Student { get; }
        public DateTime EnrollmentDate { get; } = DateTime.Now;
        public CourseEnrollment(Course course, Student student) { Course = course; Student = student; }
    }
}

public class StudentModelingDemo
{
    public static void Main(string[] args)
    {
        // Example usage
        var csDept = new Student.Department { Name = "Computer Science", Code = "CS" };
        var bachelorsCS = new Student.DegreeProgram { Name = "B.Sc. Computer Science", Level = "Undergraduate" };
        var mastersCS = new Student.DegreeProgram { Name = "M.Sc. Computer Science", Level = "Graduate" };

        var introToProgramming = new Student.Course { CourseCode = "CS101", Title = "Introduction to Programming", Credits = 3 };
        var dataStructures = new Student.Course { CourseCode = "CS201", Title = "Data Structures", Credits = 4 };
        var algorithms = new Student.Course { CourseCode = "CS301", Title = "Algorithms", Credits = 4 };
        var machineLearning = new Student.Course { CourseCode = "CS501", Title = "Machine Learning", Credits = 3 };

        var student1 = new Student(1, "U1001", "Alice", "Smith", new DateTime(2003, 5, 10), Student.Gender.Female,
                                   "alice@uni.edu", "123-456-7890", new Student.Address { Street = "123 Main St", City = "Anytown" },
                                   csDept, bachelorsCS);

        student1.EnrollInCourse(introToProgramming);
        student1.EnrollInCourse(dataStructures);
        student1.DisplayStudentSummary();

        student1.RecordGrade("CS101", 3.5m);
        student1.RecordGrade("CS201", 4.0m);
        student1.DisplayStudentSummary();

        student1.DropCourse("CS101");
        student1.DisplayStudentSummary();

        var student2 = new Student(2, "U1002", "Bob", "Johnson", new DateTime(2000, 1, 15), Student.Gender.Male,
                                   "bob@uni.edu", "987-654-3210", new Student.Address { Street = "456 Oak Ave", City = "Someville" },
                                   csDept, mastersCS);

        student2.EnrollInCourse(machineLearning);
        student2.DisplayStudentSummary();
        student2.ChangeStatus(Student.EnrollmentStatus.OnLeave);
        student2.DisplayStudentSummary();
    }
}
```

**Key Design Decisions in the Example:**

  * **Encapsulation:** Private setters for IDs, `CurrentCredits`, `GPA`, and `Enrollments` ensures that these are managed internally by the class methods (e.g., `EnrollInCourse` updates `CurrentCredits`).
  * **Complex Properties:** Using custom classes (`Address`, `Department`, `Course`) for properties like address and major promotes better organization and reusability.
  * **Enums:** Using enums (`Gender`, `EnrollmentStatus`) makes the code more readable and prevents invalid string values.
  * **Read-only Collections:** `Enrollments` is `List<CourseEnrollment>` but exposed via a `public List<CourseEnrollment> { get; private set; }`. This means outside code can *read* the list, but not directly `Add` or `Remove` from it. Instead, they use methods like `EnrollInCourse` or `DropCourse`.
  * **Computed Properties:** `GPA` is calculated on demand or updated internally, preventing inconsistencies.
  * **Clear Method Signatures:** Methods like `EnrollInCourse` or `RecordGrade` perform specific actions related to the student.
  * **Error Handling:** Basic validation with `ArgumentNullException` and `ArgumentOutOfRangeException`.

-----

### 2\. You have a bug where updating an object in one place is unexpectedly affecting other parts of the system. How would you debug this?

This is a classic symptom of **unintended shared state** in object-oriented programming, usually stemming from **reference type behavior**. Since classes are reference types, multiple variables can point to the same object in memory. If one part of the code modifies that shared object, all other parts holding a reference to it will see the change.

**Debugging Approach:**

1.  **Reproduce the Bug Consistently:** The first step is always to reliably reproduce the bug. Understand the exact sequence of operations that leads to the unexpected modification.

2.  **Identify the "Shared" Object:**

      * **What object is being modified?** Pinpoint the exact instance of the class that's exhibiting the unexpected behavior.
      * **Where is it created?** Find the `new` keyword that instantiates this object.
      * **Where is it passed around?** Trace all the places where this object (or a reference to it) is passed as a method argument, stored in a collection, or assigned to another variable.

3.  **Use Debugging Tools Effectively:**

      * **Breakpoints:** Set breakpoints at key locations:
          * Where the object is instantiated.
          * Before and after methods that interact with the object.
          * Before and after any assignment operations involving the object (`=`).
          * Inside the properties or methods that are being unexpectedly modified (e.g., in a property setter, `set { _value = value; }`).
      * **Watch Windows:** Add the suspicious object and its relevant properties to the "Watch" window in your IDE (e.g., Visual Studio). Observe their values as you step through the code.
      * **Object IDs (Memory Addresses):** In Visual Studio, you can enable Object IDs. When debugging, you'll see a unique ID next to each object reference. If `obj1` and `obj2` have the same Object ID, they refer to the exact same object in memory. This is crucial for confirming if you're dealing with a shared object.
          * Right-click in the Locals/Watch window -\> "Make Object ID".
          * Look for `#1`, `#2`, etc., next to the object names.
      * **Call Stack:** When a breakpoint is hit, examine the call stack to see the sequence of method calls that led to the current point. This helps understand the flow of execution.
      * **Conditional Breakpoints:** If the bug only happens under specific conditions, use conditional breakpoints (e.g., break only if `myObject.Property == unexpectedValue`).

4.  **Isolate the Problem (Binary Search Debugging):**

      * Start by commenting out sections of code or simplifying the workflow.
      * If the bug disappears, you've narrowed down the problematic area. Gradually reintroduce code until the bug reappears. This helps pinpoint the exact line or block of code responsible for the unexpected modification.

5.  **Examine Object Lifecycle:**

      * Is the object being stored in a static variable? Static variables have a single instance across the entire application domain, making them common sources of unintended shared state.
      * Is it being passed into a long-lived service or singleton?
      * Is it accidentally being cached?

6.  **Review Code for Shallow vs. Deep Copies:**

      * If you *intended* to create a new, independent copy of an object but are still seeing shared state issues, you might have performed a **shallow copy** when a **deep copy** was needed.
          * **Shallow Copy:** Copies only the values of the fields. If a field is a reference type, only its *reference* is copied, meaning both the original and the copy point to the same nested object.
          * **Deep Copy:** Creates entirely new instances for all nested reference types, ensuring complete independence. Implementing deep copy can be complex (e.g., using serialization, copy constructors, or custom `Clone` methods).

**Example Scenario & Debugging Trace:**

```csharp
public class Settings
{
    public string Theme { get; set; } = "Light";
    public List<string> Features { get; set; } = new List<string> { "Dashboard", "Reports" };

    public Settings Clone() // Simple shallow clone for demonstration
    {
        return new Settings { Theme = this.Theme, Features = this.Features };
    }

    public Settings DeepClone() // Example of a deep clone
    {
        return new Settings { Theme = this.Theme, Features = new List<string>(this.Features) };
    }
}

public class ConfigManager
{
    private Settings _currentSettings;

    public ConfigManager(Settings initialSettings)
    {
        _currentSettings = initialSettings;
    }

    public void ApplyUserPreferences(Settings userSettings)
    {
        // Bug: We are directly using the userSettings reference.
        // If userSettings is modified elsewhere, _currentSettings will also change.
        _currentSettings = userSettings; // <--- POTENTIAL BUG SOURCE (shallow copy assignment)
        Console.WriteLine($"ConfigManager: Applied new settings. Theme: {_currentSettings.Theme}");
    }

    public Settings GetCurrentSettings()
    {
        // Bug: Returning the internal reference directly.
        // External code can modify this returned object, affecting internal state.
        return _currentSettings; // <--- POTENTIAL BUG SOURCE (returning internal reference)
    }

    public Settings GetCurrentSettingsSafe()
    {
        // Correct: Return a deep clone to prevent external modification
        return _currentSettings.DeepClone();
    }

    public void PrintInternalSettings(string label)
    {
        Console.WriteLine($"\n--- {label} ---");
        Console.WriteLine($"  Internal Theme: {_currentSettings.Theme}");
        Console.WriteLine($"  Internal Features: {string.Join(", ", _currentSettings.Features)}");
    }
}

public class BugDemo
{
    public static void Main(string[] args)
    {
        Console.WriteLine("--- Shared Object Bug Demo ---");

        var defaultSettings = new Settings();
        var manager = new ConfigManager(defaultSettings);
        manager.PrintInternalSettings("Initial Manager Settings");

        // SCENARIO 1: Modifying external object affects internal state
        Console.WriteLine("\nScenario 1: External modification of an object given to ConfigManager.");
        var userOverrideSettings = new Settings { Theme = "Dark", Features = new List<string> { "Dashboard" } };
        manager.ApplyUserPreferences(userOverrideSettings); // manager._currentSettings now points to userOverrideSettings
        manager.PrintInternalSettings("Manager Settings After User Override (Direct Assignment)");

        Console.WriteLine("Now, external code modifies 'userOverrideSettings' list:");
        userOverrideSettings.Features.Add("NewFeatureX"); // This directly modifies the list pointed to by manager._currentSettings!
        userOverrideSettings.Theme = "Blue"; // This also modifies the shared theme.

        manager.PrintInternalSettings("Manager Settings After External Modification (OH NO!)");
        // Debugging point: Set breakpoint here. Look at manager._currentSettings and userOverrideSettings.
        // Observe they have the same Object ID and values.

        // SCENARIO 2: Modifying object obtained directly from GetCurrentSettings()
        Console.WriteLine("\nScenario 2: External modification of an object returned by GetCurrentSettings().");
        manager = new ConfigManager(new Settings()); // Reset manager
        manager.PrintInternalSettings("Manager Settings Before GetCurrentSettings() Demo");

        var settingsFromManager = manager.GetCurrentSettings(); // Gets a reference to manager's internal _currentSettings
        Console.WriteLine("External code gets settings from manager, then modifies them:");
        settingsFromManager.Theme = "Green";
        settingsFromManager.Features.Add("Analytics");

        manager.PrintInternalSettings("Manager Settings After External Modification of Returned Object (OH NO!)");
        // Debugging point: Set breakpoint here. Look at manager._currentSettings and settingsFromManager.
        // Observe they have the same Object ID and values.

        // SCENARIO 3: Correct approach using DeepClone
        Console.WriteLine("\nScenario 3: Correct approach using GetCurrentSettingsSafe() (DeepClone).");
        manager = new ConfigManager(new Settings { Theme = "Red", Features = new List<string> { "Initial" } }); // Reset manager
        manager.PrintInternalSettings("Manager Settings Before GetCurrentSettingsSafe() Demo");

        var safeSettingsFromManager = manager.GetCurrentSettingsSafe(); // Gets a new, independent copy
        Console.WriteLine("External code gets settings safely, then modifies the copy:");
        safeSettingsFromManager.Theme = "Purple";
        safeSettingsFromManager.Features.Add("Reporting");

        manager.PrintInternalSettings("Manager Settings After Safe External Modification (Correct!)");
        // Debugging point: Set breakpoint here. Look at manager._currentSettings and safeSettingsFromManager.
        // Observe they have *different* Object IDs. manager._currentSettings is untouched.
    }
}
```

By using breakpoints, watch windows, and especially Object IDs, you can visually trace the memory references and pinpoint exactly where an object is being shared and modified unexpectedly. The solution often involves either creating new instances (deep copies) or making sure objects are immutable.

-----

### 3\. How would you structure a class to represent a bank account, enforcing rules like minimum balance?

To represent a bank account and enforce rules like a minimum balance, we need to apply principles of **encapsulation** and **validation**.

**Key Design Elements:**

1.  **Private Fields:** Store the account's internal state (balance, account number, owner).
2.  **Public Properties (with controlled access):** Expose data where appropriate, potentially with private setters for fields that are set internally or at construction.
3.  **Constructors:** Initialize the account, potentially enforcing initial balance rules.
4.  **Methods:** Implement operations (deposit, withdraw) with built-in validation.
5.  **Constants/Read-only Fields:** Define fixed rules like `MinimumBalance`.
6.  **Events (Optional):** To notify other parts of the system about account activities (e.g., low balance, withdrawal success).

**Example `BankAccount` Class:**

```csharp
using System;

public class BankAccount
{
    // --- Constants / Rules ---
    private const decimal MINIMUM_BALANCE_REQUIRED = 100.00m; // Example rule: minimum $100

    // --- Private Fields ---
    private string _accountNumber;
    private string _accountHolderName;
    private decimal _balance; // Actual balance, private for encapsulation

    // --- Properties ---
    public string AccountNumber
    {
        get { return _accountNumber; }
        // Private set because account number should ideally not change after creation.
        // Can be set in constructor or object initializer.
        private set
        {
            if (string.IsNullOrWhiteSpace(value))
            {
                throw new ArgumentException("Account number cannot be empty.", nameof(value));
            }
            _accountNumber = value;
        }
    }

    public string AccountHolderName
    {
        get { return _accountHolderName; }
        set
        {
            if (string.IsNullOrWhiteSpace(value))
            {
                throw new ArgumentException("Account holder name cannot be empty.", nameof(value));
            }
            _accountHolderName = value;
        }
    }

    // Public getter for balance, but no public setter.
    // Balance can only be changed via Deposit/Withdraw methods.
    public decimal Balance
    {
        get { return _balance; }
        private set { _balance = value; } // Private setter: only methods within this class can change balance
    }

    // --- Constructors ---
    public BankAccount(string accountNumber, string accountHolderName, decimal initialDeposit)
    {
        AccountNumber = accountNumber; // Use property setters for validation
        AccountHolderName = accountHolderName;

        if (initialDeposit < MINIMUM_BALANCE_REQUIRED)
        {
            throw new ArgumentException($"Initial deposit must be at least {MINIMUM_BALANCE_REQUIRED:C}.", nameof(initialDeposit));
        }
        Balance = initialDeposit; // Use private setter
        Console.WriteLine($"Account {AccountNumber} created for {AccountHolderName} with initial deposit of {initialDeposit:C}.");
    }

    // --- Methods (with Validation) ---

    /// <summary>
    /// Deposits money into the account.
    /// </summary>
    /// <param name="amount">The amount to deposit.</param>
    public void Deposit(decimal amount)
    {
        if (amount <= 0)
        {
            throw new ArgumentOutOfRangeException(nameof(amount), "Deposit amount must be positive.");
        }
        Balance += amount; // Update balance via private setter
        Console.WriteLine($"Deposited {amount:C}. New balance: {Balance:C}");
    }

    /// <summary>
    /// Withdraws money from the account, enforcing minimum balance rule.
    /// </summary>
    /// <param name="amount">The amount to withdraw.</param>
    /// <returns>True if withdrawal was successful, false otherwise.</returns>
    public bool Withdraw(decimal amount)
    {
        if (amount <= 0)
        {
            throw new ArgumentOutOfRangeException(nameof(amount), "Withdrawal amount must be positive.");
        }

        // Rule Enforcement: Check against minimum balance after withdrawal
        if (Balance - amount < MINIMUM_BALANCE_REQUIRED)
        {
            Console.WriteLine($"Withdrawal failed: Insufficient funds. Balance would go below minimum of {MINIMUM_BALANCE_REQUIRED:C}.");
            return false;
        }

        Balance -= amount; // Update balance via private setter
        Console.WriteLine($"Withdrew {amount:C}. New balance: {Balance:C}");
        return true;
    }

    /// <summary>
    /// Displays account details.
    /// </summary>
    public void DisplayAccountInfo()
    {
        Console.WriteLine($"\n--- Account Details ---");
        Console.WriteLine($"Account No: {AccountNumber}");
        Console.WriteLine($"Holder: {AccountHolderName}");
        Console.WriteLine($"Balance: {Balance:C}");
        Console.WriteLine("-----------------------");
    }
}

public class BankAccountDemo
{
    public static void Main(string[] args)
    {
        try
        {
            // Try creating an account with insufficient initial deposit
            BankAccount account1 = new BankAccount("ACC001", "Alice Wonderland", 50.00m);
        }
        catch (ArgumentException ex)
        {
            Console.WriteLine($"Error creating account: {ex.Message}");
        }

        Console.WriteLine();

        // Create a valid account
        BankAccount account2 = new BankAccount("ACC002", "Bob The Builder", 500.00m);
        account2.DisplayAccountInfo();

        account2.Deposit(200.00m);
        account2.DisplayAccountInfo();

        // Attempt a valid withdrawal
        account2.Withdraw(150.00m);
        account2.DisplayAccountInfo();

        // Attempt an invalid withdrawal (would go below minimum balance)
        account2.Withdraw(500.00m); // Current balance is 550, but 550-500=50, which is < 100.
        account2.DisplayAccountInfo();

        // Attempt a valid withdrawal again
        account2.Withdraw(100.00m); // 550 - 100 = 450 (still > 100)
        account2.DisplayAccountInfo();
    }
}
```

**Benefits of this Structure:**

  * **Encapsulation:** The `_balance` field is private, and its modification is strictly controlled by `Deposit` and `Withdraw` methods. No external code can directly set `account.Balance = -500;`.
  * **Data Integrity:** Business rules (like minimum balance) are enforced directly within the methods that modify the relevant data.
  * **Readability:** The `BankAccount` object clearly defines its state and the allowed operations.
  * **Maintainability:** If the minimum balance rule changes, only the constant `MINIMUM_BALANCE_REQUIRED` needs to be updated (and potentially related validation logic).
  * **Testability:** The `BankAccount` class can be tested in isolation, verifying that deposits and withdrawals correctly update the balance and enforce rules.

-----

### 4\. What would you do if multiple parts of the codebase need to access the same instance of a configuration class?

When multiple parts of your codebase need to access the *same instance* of a configuration class, you are dealing with a **Singleton pattern** or, more generally, a need for **Dependency Injection (DI)** with a **singleton lifetime**.

**Problem:**
Directly instantiating `new Configuration()` in multiple places would lead to each part having its *own, separate copy* of the configuration, which might not be consistent or reflect changes made elsewhere. You need a single, shared source of truth.

**Solutions:**

1.  **Singleton Pattern (Traditional, Manual Implementation):**
    This design pattern restricts the instantiation of a class to a single object and ensures that this single instance is accessible globally.

    **How to implement (basic version):**

      * Make the constructor `private` to prevent external instantiation.
      * Create a `private static` field to hold the single instance.
      * Provide a `public static` property or method to get that single instance, creating it lazily if it doesn't already exist.

    **Code Example (Basic Singleton):**

    ```csharp
    using System;
    using System.Collections.Generic;

    public class AppConfiguration
    {
        // 1. Private static field to hold the single instance
        private static AppConfiguration? _instance; // Nullable for initial null state

        // 2. Private constructor to prevent external instantiation
        private AppConfiguration()
        {
            // Initialize default configuration settings here
            DatabaseConnectionString = "DefaultDbConnection";
            LogLevel = "Info";
            ApiKeys = new Dictionary<string, string>
            {
                { "WeatherApi", "default_weather_key" },
                { "MapsApi", "default_maps_key" }
            };
            Console.WriteLine("AppConfiguration: Initializing (Singleton instance created).");
        }

        // 3. Public static property to get the instance (thread-safe version below)
        public static AppConfiguration Instance
        {
            get
            {
                // Lazy initialization: create instance only if it's null
                if (_instance == null)
                {
                    _instance = new AppConfiguration();
                }
                return _instance;
            }
        }

        // Configuration properties
        public string DatabaseConnectionString { get; set; }
        public string LogLevel { get; set; }
        public Dictionary<string, string> ApiKeys { get; set; }


        // Method to demonstrate modifying config (often done through admin panel or config files)
        public void LoadFromSettings(string dbConn, string logLevel)
        {
            DatabaseConnectionString = dbConn;
            LogLevel = logLevel;
            Console.WriteLine("AppConfiguration: Settings updated.");
        }

        public void DisplaySettings()
        {
            Console.WriteLine($"\n--- Current Configuration ---");
            Console.WriteLine($"  DB Connection: {DatabaseConnectionString}");
            Console.WriteLine($"  Log Level: {LogLevel}");
            Console.WriteLine($"  Weather API Key: {ApiKeys["WeatherApi"]}");
            Console.WriteLine("------------------------------");
        }
    }

    public class SingletonDemo
    {
        public static void Main(string[] args)
        {
            Console.WriteLine("Part 1: Accessing the singleton instance");
            // First access creates the instance
            AppConfiguration config1 = AppConfiguration.Instance;
            config1.DisplaySettings();

            Console.WriteLine("\nPart 2: Accessing the singleton instance again");
            // Subsequent accesses return the *same* instance
            AppConfiguration config2 = AppConfiguration.Instance;
            config2.DisplaySettings();

            // Prove they are the same instance by modifying through one and seeing change in other
            Console.WriteLine("\nPart 3: Modifying settings via one reference and observing through another");
            config1.LoadFromSettings("NewProdDbConnection", "Error");
            config2.DisplaySettings(); // config2 reflects the change made by config1

            Console.WriteLine($"Are config1 and config2 the same instance? {ReferenceEquals(config1, config2)}");
            Console.WriteLine($"Hash code of config1: {config1.GetHashCode()}");
            Console.WriteLine($"Hash code of config2: {config2.GetHashCode()}");


            // Thread-safe singleton (e.g., using Lazy<T>) - preferred for thread safety
            Console.WriteLine("\n--- Thread-Safe Singleton using Lazy<T> (Recommended) ---");
            LazySingleton.Instance.DisplaySettings();
            LazySingleton.Instance.LoadFromSettings("LazyDb", "Warning");
            LazySingleton.Instance.DisplaySettings();
        }
    }

    // Recommended Thread-Safe Singleton using Lazy<T>
    public class LazySingleton
    {
        private static readonly Lazy<LazySingleton> _lazyInstance = new Lazy<LazySingleton>(() => new LazySingleton());

        public static LazySingleton Instance => _lazyInstance.Value;

        private LazySingleton()
        {
            DatabaseConnectionString = "DefaultLazyDbConnection";
            LogLevel = "Debug";
            Console.WriteLine("LazySingleton: Initializing (instance created lazily and thread-safely).");
        }

        public string DatabaseConnectionString { get; set; }
        public string LogLevel { get; set; }

        public void LoadFromSettings(string dbConn, string logLevel)
        {
            DatabaseConnectionString = dbConn;
            LogLevel = logLevel;
            Console.WriteLine("LazySingleton: Settings updated.");
        }
         public void DisplaySettings()
        {
            Console.WriteLine($"\n--- LazySingleton Current Configuration ---");
            Console.WriteLine($"  DB Connection: {DatabaseConnectionString}");
            Console.WriteLine($"  Log Level: {LogLevel}");
            Console.WriteLine("------------------------------------------");
        }
    }
    ```

    **Drawbacks of Traditional Singleton:**

      * **Global State:** Introduces global state, which can make testing harder (dependencies are hidden, not easily replaceable).
      * **Tight Coupling:** Classes directly `AppConfiguration.Instance` become tightly coupled to the `AppConfiguration` class.
      * **Difficult to Test:** Hard to mock or substitute `AppConfiguration` in unit tests.

2.  **Dependency Injection (DI) with Singleton Lifetime (Recommended for Modern Apps):**
    This is the preferred approach in modern C\# applications (especially ASP.NET Core). Instead of the class managing its own single instance, an Inversion of Control (IoC) container manages the lifecycle of objects.

    **How it works:**

      * You define your configuration class as a regular class (no private constructor, no static `Instance` property).
      * You register this class with your DI container (e.g., in `Program.cs` or `Startup.cs` in ASP.NET Core) specifying a "singleton" lifetime.
      * Any class that *needs* the configuration simply declares it as a constructor parameter. The DI container automatically provides the *same instance* every time it's requested.

    **Code Example (Conceptual for ASP.NET Core DI):**

    ```csharp
    // 1. Define the Configuration Class (just a regular class)
    public class MyConfiguration
    {
        public string ApiKey { get; set; }
        public int MaxRetries { get; set; }

        public MyConfiguration()
        {
            Console.WriteLine("MyConfiguration instance created (by DI container).");
        }
    }

    // 2. Class that needs MyConfiguration
    public class MyService
    {
        private readonly MyConfiguration _config;

        public MyService(MyConfiguration config) // DI container injects the instance here
        {
            _config = config;
            Console.WriteLine($"MyService created. Using API Key: {_config.ApiKey}");
        }

        public void DoSomething()
        {
            Console.WriteLine($"  MyService.DoSomething: Current Max Retries: {_config.MaxRetries}");
        }
    }

    public class AnotherService
    {
        private readonly MyConfiguration _config;

        public AnotherService(MyConfiguration config) // DI container injects the same instance here
        {
            _config = config;
            Console.WriteLine($"AnotherService created. Using API Key: {_config.ApiKey}");
        }

        public void DoAnotherThing()
        {
            Console.WriteLine($"  AnotherService.DoAnotherThing: Current API Key: {_config.ApiKey}");
        }
    }

    // 3. Register with DI container (example for ASP.NET Core Program.cs)
    /*
    public class Program
    {
        public static void Main(string[] args)
        {
            var builder = WebApplication.CreateBuilder(args);

            // Register MyConfiguration as a singleton
            builder.Services.AddSingleton<MyConfiguration>();

            // Register other services
            builder.Services.AddTransient<MyService>();
            builder.Services.AddTransient<AnotherService>();

            var app = builder.Build();

            // Simulate resolution and usage
            using (var scope = app.Services.CreateScope())
            {
                var service1 = scope.ServiceProvider.GetRequiredService<MyService>();
                service1.DoSomething();

                var service2 = scope.ServiceProvider.GetRequiredService<AnotherService>();
                service2.DoAnotherThing();

                // If MyConfiguration was configured externally (e.g., from appsettings.json)
                // it would be setup using IConfiguration patterns.
                // For direct instance:
                var directConfig = scope.ServiceProvider.GetRequiredService<MyConfiguration>();
                directConfig.ApiKey = "Actual_Production_Key";
                directConfig.MaxRetries = 5;

                // Re-resolve to see the effect (though directConfig already is the singleton)
                var service3 = scope.ServiceProvider.GetRequiredService<MyService>();
                service3.DoSomething();
            }

            app.Run();
        }
    }
    */
    ```

    **Benefits of DI with Singleton Lifetime:**

      * **Loose Coupling:** Classes don't know *how* the configuration is instantiated; they just declare they need it.
      * **Testability:** In unit tests, you can easily provide a mock or fake `MyConfiguration` instance without complex setups.
      * **Flexibility:** Easily change the lifetime (e.g., to `Scoped` or `Transient`) without modifying the consuming classes.
      * **Centralized Management:** The DI container manages object creation and lifetimes.
      * **Configuration Flexibility:** Easily load configuration from `appsettings.json`, environment variables, etc., and bind it to `MyConfiguration` using built-in ASP.NET Core features.

**Conclusion:**

While the traditional Singleton pattern works, **Dependency Injection with a singleton lifetime is the modern, more robust, and testable approach** for managing shared instances of configuration (or any other) classes in C\# applications. It leverages the power of inversion of control to provide a cleaner and more maintainable architecture.