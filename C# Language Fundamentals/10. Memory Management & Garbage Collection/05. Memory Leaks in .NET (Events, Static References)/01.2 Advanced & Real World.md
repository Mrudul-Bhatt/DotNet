Let's explore these common memory leak scenarios in .NET applications, especially prevalent in UI frameworks like WPF, and discuss how to identify and fix them.

-----

### ðŸ”¹ Your WPF app gets slower over time. Memory usage keeps growing. Whatâ€™s a common cause?

(Event handlers in views/viewmodels arenâ€™t being unsubscribed, preventing GC.)

**Explanation:**

In WPF (and other UI frameworks like WinForms, UWP, etc.), the most common cause for a "slow memory leak" (where memory usage steadily grows and performance degrades over time) is **unsubscribed event handlers, particularly between objects with different lifetimes.**

Here's why it happens:

1.  **Event Subscription Creates a Strong Reference:** When an object (the **subscriber**, e.g., a `ViewModel` or `View` component) subscribes to an event published by another object (the **publisher**, e.g., a service, a static class, a data source, or even another UI element), the publisher implicitly holds a **strong reference** to the subscriber's event handler method. This strong reference prevents the subscriber from being garbage collected.

2.  **Lifetime Mismatch:** The leak occurs when the **publisher has a longer lifetime than the subscriber.**

      * **Common Scenario:** A `View` or `ViewModel` is created for a specific screen or tab. It subscribes to an event on a `Singleton` service, a `static` event, or a service that lives for the entire application duration.
      * When the user navigates away from that screen, or the tab is closed, the `View` and `ViewModel` instances are logically no longer needed. However, if they don't explicitly unsubscribe from the `MessageBus` event, the `MessageBus` continues to hold a reference to them.
      * The `View`/`ViewModel` (and its entire object graph, including controls, data, etc.) remains in memory, even though it's no longer actively used, leading to a memory leak.

3.  **Accumulation:** As users interact with the app (opening/closing tabs, navigating, etc.), more and more "dead" `View` and `ViewModel` instances accumulate in memory, continuously consuming resources. This leads to:

      * **Increased Memory Consumption:** The working set of the application grows, potentially leading to `OutOfMemoryException` errors in extreme cases.
      * **Performance Degradation:** The Garbage Collector has to work harder and more frequently to manage the increasing number of live objects, leading to longer and more frequent GC pauses, which manifest as UI freezes or overall application sluggishness.

**Example:**

A `UserControl` ViewModel subscribes to a `LoggedInUserChanged` event on a static `ApplicationState` class. When the `UserControl` is removed from the UI, its ViewModel (if it doesn't unsubscribe) will still be referenced by the `ApplicationState` class, preventing its collection.

**Fix:**

The primary fix is to ensure **explicit unsubscription** when the subscriber is no longer needed. This is typically done in:

  * The `Dispose()` method if the `ViewModel`/`View` implements `IDisposable`.
  * The `Unloaded` event for WPF `UserControl`s or `Window`s.
  * A dedicated `Cleanup()` or `Deactivate()` method in your ViewModel lifecycle.

-----

### ðŸ”¹ You use a static cache to store reusable objects, but memory never drops. Whatâ€™s likely wrong?

(You're not cleaning or expiring static references, causing object lifetimes to extend indefinitely.)

**Explanation:**

A static cache is a common pattern for storing frequently accessed data or objects to improve performance. However, if not managed carefully, it's a very common source of memory leaks.

When memory never drops after using a static cache, it typically means:

1.  **Strong References from Static Field:** A static field, by its nature, exists for the lifetime of the application domain. If this static field (e.g., a `static Dictionary<K, V>`, `static List<T>`, or a simple `static MyObject _cacheInstance`) holds a strong reference to objects, those objects will *never* be garbage collected. They become roots in the GC graph.

2.  **No Eviction/Expiration Policy:** Unlike an in-memory cache solution (like `MemoryCache` in .NET Core/Framework) which has built-in eviction policies (e.g., time-based expiration, size limits, least-recently-used), a simple custom static collection has no such mechanism by default.

      * You add items to it, but you never explicitly remove them.
      * Even if the cached objects are no longer used anywhere else in the application, the static cache continues to hold a strong reference, preventing their collection.

3.  **Accumulation of Stale Objects:** Over time, the cache accumulates more and more objects, including those that are no longer relevant or actively used. This continuous accumulation leads to:

      * **Ever-increasing memory footprint:** The application's memory usage grows unbounded.
      * **Performance Degradation:** The GC has to traverse larger object graphs, leading to more frequent and longer collection pauses.

**Example:**

```csharp
public static class MyLeakyStaticCache
{
    // PROBLEM: This dictionary holds strong references.
    // Objects added here will never be collected until the app shuts down.
    private static Dictionary<string, byte[]> _dataCache = new Dictionary<string, byte[]>();

    public static void AddData(string key, byte[] data)
    {
        _dataCache[key] = data; // Adds or updates, but never removes
    }

    public static byte[] GetData(string key)
    {
        _dataCache.TryGetValue(key, out byte[] data);
        return data;
    }
    // No mechanism to clear old data or limit size
}
```

**Fixes:**

  * **Implement an Eviction Strategy:**
      * **Time-based:** Remove items after a certain time (e.g., last accessed time, creation time).
      * **Size-based:** Remove least-recently-used (LRU) items when the cache reaches a certain size limit.
      * **Manual/Event-driven:** Clear items when an underlying data source changes or when a specific event signals data invalidation.
  * **Use `System.Runtime.Caching.MemoryCache`:** This class (available in .NET Framework and as a NuGet package for .NET Core) provides built-in expiration and eviction policies.
  * **Use `WeakReference` (for value types or very specific scenarios):** If you want to cache objects but allow them to be collected if no other strong references exist, you can store `WeakReference<T>` in your cache. This requires checking `TryGetTarget` before use. This is generally more complex than an eviction strategy and suited for unique cases.
  * **Clear the cache explicitly:** If the cache is truly for temporary application-lifetime data, ensure it's cleared when the data is no longer needed (e.g., on logout, or at key application lifecycle events).

-----

### ðŸ”¹ You notice that a class meant to be short-lived lives until the app shuts down. What tools or techniques help confirm the leak?

(Use memory profilers (dotMemory, Visual Studio), check reference graphs, watch for static/event roots.)

**Explanation:**

When a short-lived object (like a `ViewModel`, a UI control, a temporary service instance, etc.) persists in memory until application shutdown, it's a clear indication of a memory leak. Confirming such leaks requires specialized tools and a systematic approach.

**Tools and Techniques:**

1.  **Memory Profilers (Essential):** These are your primary weapons.

      * **dotMemory (JetBrains):** Excellent for detailed analysis, showing object graphs, diffs between snapshots, and automatic leak detection.
      * **Visual Studio Diagnostic Tools (Memory Usage):** Built-in and convenient for basic analysis. Can take snapshots, show object counts, and common roots.
      * **ANTS Memory Profiler (Redgate):** Another powerful commercial option with good visualization.
      * **PerfView (Microsoft, Free):** A comprehensive performance analysis tool that can also capture memory snapshots and identify leaks, though it has a steeper learning curve.

    **How to use them:**

      * **Take a baseline snapshot:** Start your app, let it settle, and take the first memory snapshot.
      * **Perform the leaking action:** Execute the action that you suspect causes the leak (e.g., open a UI tab, close it, repeat several times).
      * **Take subsequent snapshots:** Take a second snapshot after the action, and perhaps a third after repeating it multiple times and forcing a GC (`GC.Collect()` if testing, but avoid in production).
      * **Compare Snapshots (Diff):** The most powerful feature. Compare the snapshots to see which object types have increased significantly in count and memory usage, even after GCs. This will quickly point you to the "leaking" class.
      * **Analyze Reference Graphs (Paths to Root):** For the suspected leaking objects, the profiler will show you the "path to root" â€“ the chain of strong references that prevents them from being garbage collected. This is the crucial step that tells you *why* they're alive. Look for:
          * **Static fields:** A reference from a static field is a common root.
          * **Event delegates:** References from event subscriptions.
          * **Collections:** Objects stuck in collections that are never cleared.
          * **Closures:** Lambdas holding references to outer instances.
          * **Long-lived singletons/services:** Objects that live for the app's lifetime but are holding onto short-lived objects.

2.  **Manual Code Inspection:**

      * **Review `IDisposable` implementations:** Ensure `Dispose()` is called on all instances, especially for objects that hold unmanaged resources or other disposable objects. Look for missing `using` statements or `try-finally` blocks.
      * **Event Subscriptions:** Scrutinize any `+=` event subscriptions, especially those between objects with different lifetimes. Look for corresponding `-=` unsubscriptions.
      * **Static Fields and Properties:** Check all static fields and properties for instances of classes that should be temporary.
      * **Collections:** Identify any collections (lists, dictionaries) where objects are added but never removed.
      * **Async/Await Context:** Be aware of how `async` methods and `Task` continuations can capture execution contexts, sometimes inadvertently holding references.

3.  **WeakReferences (for confirming rather than fixing):**

      * Temporarily introduce `WeakReference` for the suspected leaking object type. If the `WeakReference.Target` becomes `null` after a GC when it *should* have, then you know it's not being strongly referenced, indicating a bug elsewhere. If it *doesn't* become `null` (and you know there are no direct references), then it's being held somewhere else. This is more for experimentation.

By combining profiler analysis with targeted code review based on the profiler's findings, you can efficiently pinpoint the exact cause of the memory leak.

-----

### ðŸ”¹ How can anonymous methods or closures cause memory leaks?

(Closures capture variables and sometimes keep them alive longer than expected â€” especially in async/task continuations.)

**Explanation:**

Anonymous methods (like lambdas) and local functions in C\# can create "closures." A closure happens when an anonymous method or local function captures (references) variables from its surrounding scope (the "outer scope" or "enclosing context").

**The Mechanism of Leakage:**

When a lambda captures an outer variable, the C\# compiler generates a hidden, compiler-generated class (a "closure class"). An instance of this class is created, and it holds:

1.  **Fields for the captured variables:** These fields hold the actual values or references of the variables captured from the outer scope.
2.  **A reference to the lambda's method code.**
3.  **Crucially, if the captured variable is `this` (the instance of the outer class), the closure class will have a field holding a strong reference back to that outer instance.**

The leak occurs when this generated **closure class instance** (and thus the `this` reference it holds) is unintentionally kept alive for too long by a long-lived object.

**Common Scenarios for Leaky Closures:**

1.  **Event Subscriptions (Most Common):**

      * A lambda captures `this` (an instance of `MyViewModel`).
      * This lambda is subscribed to an event on a `static` class, a `singleton` service, or a long-lived UI element (the publisher).
      * The publisher holds a strong reference to the lambda (the generated closure class).
      * The closure class, in turn, holds a strong reference to `MyViewModel`.
      * Result: `MyViewModel` (and its entire object graph) cannot be garbage collected even if it's no longer used, because the long-lived publisher indirectly holds it via the lambda.

    <!-- end list -->

    ```csharp
    public class LeakyViewModel // This instance will leak
    {
        private string _name;
        // Assume AppEvents is a static class with static events
        public LeakyViewModel(string name)
        {
            _name = name;
            Console.WriteLine($"  LeakyViewModel '{_name}' created.");

            // PROBLEM: This lambda captures 'this' (the LeakyViewModel instance)
            // If AppEvents.GlobalMessage is long-lived and never unsubscribed from,
            // this LeakyViewModel will be leaked.
            AppEvents.GlobalMessage += (sender, args) =>
            {
                Console.WriteLine($"  {_name} received global message: {args}");
                // Accessing _name implicitly captures 'this'
            };
        }
        ~LeakyViewModel() => Console.WriteLine($"  LeakyViewModel '{_name}' finalized.");
    }
    public static class AppEvents // Long-lived publisher
    {
        public static event EventHandler<string> GlobalMessage;
        public static void RaiseGlobalMessage(string msg) => GlobalMessage?.Invoke(null, msg);
    }
    ```

2.  **`async`/`await` Continuations:**

      * When you `await` an asynchronous operation, the compiler captures the current context (including local variables and `this`) to resume execution after the `await`. This captured context (a closure-like object) can potentially hold references.
      * If a `Task` (or its continuation) is somehow kept alive for a very long time (e.g., stored in a static list, or part of a long-running background process that never completes), it can keep its captured context (and thus the outer object) alive indefinitely. This is less common with standard `await` usage if tasks complete, but can happen if `Task` objects are not properly handled or if you use `ConfigureAwait(false)` inappropriately in UI contexts.

3.  **Background Tasks/Timers:**

      * A lambda used as a callback for a `Timer` (like `System.Threading.Timer`) or a long-running `Task.Run` might capture `this` or other local variables. If the timer keeps firing or the `Task` never finishes, the closure will persist, preventing collection of the captured objects.

**Fixes:**

  * **Explicit Unsubscription:** For event handlers, *always* unsubscribe when the subscriber is no longer needed. This is the most effective and common solution.
  * **Avoid Capturing `this`:** If the lambda doesn't need to access instance members, make it a non-capturing lambda (e.g., it only accesses static members or takes all necessary data as arguments).
  * **Weak References for Delegates (Complex):** In rare cases where explicit unsubscription is impossible, you could use a weak reference to the target object within the delegate, but this adds significant complexity.
  * **Dispose Long-Lived Tasks/Timers:** Ensure any background tasks, timers, or long-running processes are properly cancelled and disposed when their owning components are no longer needed.

-----

### ðŸ”¹ Your team uses a static logger that hooks into application-wide events. After a restart, memory isnâ€™t released. What went wrong?

(The logger still holds references via events or static fields â€” needs to unsubscribe or be cleaned manually.)

**Explanation:**

This scenario points directly to the combination of static references and event subscription leaks.

1.  **Static Logger Instance:** The logger itself is `static`. This means it lives for the entire duration of the application domain. It's never garbage collected unless the app domain unloads (which typically only happens on full application shutdown).
2.  **Hooking into Application-Wide Events:** The logger subscribes to "application-wide events." These events are almost certainly published by other long-lived objects (e.g., a static `AppDomain.CurrentDomain.UnhandledException`, a static `Application.Current.DispatcherUnhandledException` in WPF, or a custom static `MessageBus` event).
3.  **The Leak:** When the static logger subscribes to these long-lived events, the event sources (the publishers) gain a strong reference to the logger instance (or, more precisely, to the delegate that points to the logger's event handler method).
      * Since the logger *is* static, it already has a root reference. So, the direct leak isn't the logger itself being collected (it won't be until app domain unload).
      * **The real leak occurs if the logger's event handlers themselves capture references to other short-lived objects.** For example, if a log message includes details from a temporary `UserSession` object, and the lambda processing that event captures the `UserSession`, then the `UserSession` might be leaked via the static logger's event subscription.
      * More commonly, the "memory isn't released after a restart" part of the question implies a **hot-reloading or multiple-instance scenario** where an old application domain might not fully unload, or that even after a simulated "restart" (e.g., closing and reopening a main window but the process stays alive), the static logger instance from the *previous logical run* continues to hold onto accumulated data or references.
      * If the logger itself maintains an internal cache of log entries (e.g., for batching or display), and that cache isn't cleared on a "soft restart" (i.e., not a full process restart), those log entries will accumulate.

**What went wrong (specific points):**

  * **No Unsubscription (if dynamic event sources):** If the logger subscribes to events from non-static, but still long-lived, objects that *might* be re-created during a "soft restart" cycle, the old instances could still be holding references to the static logger. This is less common for truly application-wide events, but possible with custom frameworks.
  * **Internal Buffering/Caching:** The static logger likely has internal buffers or collections (e.g., a `List<LogEntry>` or a `ConcurrentQueue<LogMessage>`) to store log messages before writing them to disk or sending them to a remote service. If these internal collections are never cleared, or their contents never explicitly released, they will grow indefinitely.
  * **Static Field Accumulation:** Any other static fields within the logger that are designed to hold temporary data but are not explicitly cleared will also contribute to the leak.
  * **Process, Not AppDomain, Restart:** The "restart" is likely a logical application restart, not a full process termination and relaunch. The static logger (and anything it holds) persists across these logical restarts.

**Fixes:**

  * **Clear Internal State:** Implement a `Clear()` or `Reset()` method on your static logger. Call this method during your application's "soft restart" sequence to clear any internal buffers, caches, or accumulated data.
  * **Managed Lifetime for Logger:** If the logger is not truly meant to be static for the *entire process*, consider making it a `Singleton` registered with a Dependency Injection container that can manage its lifetime, including calling `Dispose()` when the application scope ends.
  * **Careful Event Management:** Ensure that any event subscriptions made by the logger are either to truly static, long-lived event sources, or that they are properly unsubscribed if the event source's lifetime is not perfectly aligned with the static logger.
  * **Weak References (Rare for Loggers):** For a logger that observes many transient objects, using `WeakReference` for its observers might be considered, but it makes logging less reliable as objects can disappear. This is not for a logger as a *subscriber* to events, but rather if the logger *holds onto* things it observes.

-----

### ðŸ”¹ What are WeakReferences, and how can they help prevent leaks in observer patterns or caches?

(They allow access to objects without preventing GC â€” useful when you donâ€™t want to strongly hold references.)

**Explanation:**

In .NET, `WeakReference` (and its generic counterpart `WeakReference<T>`) provides a way to refer to an object without preventing it from being garbage collected. Normally, a "strong reference" (a regular variable assignment) ensures an object stays alive. A "weak reference" does not.

**How WeakReferences Work:**

  * When you create a `WeakReference` to an object, you are telling the GC: "I'd like to be able to access this object if it's still alive, but if no one else is holding a strong reference to it, you are free to collect it."
  * If the object is collected by the GC, the `Target` property of the `WeakReference` will become `null`.
  * You must always check if `Target` is `null` before trying to use the referenced object, because the object might have been collected at any time.

**Syntax:**

```csharp
// Strong reference (prevents GC)
MyObject strongRef = new MyObject();

// Weak reference (does NOT prevent GC)
WeakReference<MyObject> weakRef = new WeakReference<MyObject>(strongRef);

// Now, remove the strong reference
strongRef = null;

// Later, try to access the object via the weak reference
if (weakRef.TryGetTarget(out MyObject obj)) // Safe way to check and get
{
    Console.WriteLine("Object is still alive: " + obj.Id);
}
else
{
    Console.WriteLine("Object has been garbage collected.");
}
```

**How they help prevent leaks (in Observer Patterns or Caches):**

1.  **Observer Patterns (e.g., Events):**

      * **The Problem:** In a typical event subscription, the publisher holds a strong reference to the subscriber's event handler delegate, preventing the subscriber from being collected as long as the publisher lives.
      * **The Solution with WeakReferences:** Instead of holding strong references to event delegates or subscriber instances, the publisher can hold `WeakReference`s to them.
      * **Benefit:** If the subscriber is no longer referenced elsewhere (e.g., it goes out of scope, a UI element is closed), the GC can collect it, and the publisher's weak reference will automatically become `null`. The publisher can then periodically clean up its list of `null` weak references. This prevents the subscriber from being leaked by the publisher.
      * **Complexity:** Implementing a `WeakEventManager` (like WPF has internally) is more complex than direct subscription/unsubscription.

2.  **Caches:**

      * **The Problem:** A common custom cache (`Dictionary<K, V>`) holds strong references to its cached items, preventing them from being collected even if they're no longer used anywhere else in the application. This causes a memory leak if the cache isn't explicitly managed.
      * **The Solution with WeakReferences:** Store `WeakReference<T>` to your cached objects (the `V` in `Dictionary<K, V>`) instead of direct `T` instances.
      * **Benefit:** If an object is in the cache but is no longer needed by any other part of the application (no strong references elsewhere), the GC is free to collect it. When you try to retrieve it from the cache, you check `TryGetTarget()`. If it returns `false`, the item has been collected and you can re-fetch/re-create it. This makes the cache self-pruning based on GC activity.
      * **Drawbacks:** It's non-deterministic (you don't know *when* an item will be collected). Also, the cache itself needs a mechanism to clean up `null` weak references periodically to avoid accumulating empty entries.

**When to Use Them:**

  * When you need to maintain a reference to an object, but you explicitly **do not want that reference to keep the object alive** (i.e., you want it to be collectible if no one else cares about it).
  * In **cache implementations** where you prefer a "soft" cache that releases memory under pressure rather than holding onto everything indefinitely.
  * In certain **observer/event patterns** where explicit unsubscription is impractical or extremely difficult due to complex object lifetimes.

-----

### ðŸ”¹ How do you safely unsubscribe from events in `IDisposable` objects?

(Override `Dispose()`, and in it, call `publisher.Event -= handler;` â€” avoids leaks from long-lived publishers.)

**Explanation:**

Safely unsubscribing from events is crucial to prevent memory leaks, especially when a short-lived `IDisposable` object (the subscriber) listens to events from a long-lived publisher. The correct place to perform this unsubscription is within the `Dispose()` method of the `IDisposable` subscriber.

**Why `Dispose()`?**

  * **Deterministic Cleanup:** `IDisposable` is designed for deterministic cleanup. When you use a `using` block or explicitly call `Dispose()`, you are signalling that the object is no longer needed and its resources should be released immediately.
  * **Resource Release:** Unsubscribing from an event is effectively releasing a "resource" (the strong reference held by the publisher).
  * **Guaranteed Execution (with proper usage):** If the `IDisposable` pattern is followed (using `using` or `try-finally`), `Dispose()` is guaranteed to be called when the object's logical lifetime ends.

**Steps to Safely Unsubscribe in `Dispose()`:**

1.  **Implement `IDisposable`:** Your subscriber class should implement `IDisposable`.
2.  **Declare a `_disposed` flag:** To ensure idempotence (`Dispose()` can be called multiple times without error).
3.  **Hold a Reference to the Publisher:** The subscriber needs a reference to the publisher to unsubscribe. This is often passed in the constructor.
4.  **Subscribe using a Named Method:** While lambdas are convenient, unsubscribing from a lambda requires the *exact same delegate instance* used for subscription, which is difficult with anonymous lambdas. Using a named method makes unsubscription straightforward.
5.  **Perform Unsubscription in `Dispose(bool disposing)`:**
      * Inside the `if (disposing)` block (for explicit disposal), call `publisher.Event -= YourEventHandlerMethod;`.
      * Set the publisher reference to `null` to help the GC if the publisher's lifetime is tied to the subscriber in some way, or to avoid accidental re-subscription.

**Code Example:**

```csharp
using System;
using System.Threading;

// Long-lived publisher
public class DataService
{
    public event EventHandler<string> DataUpdated;

    public void SimulateDataUpdate(string data)
    {
        Console.WriteLine("  [DataService]: Simulating data update...");
        DataUpdated?.Invoke(this, data);
    }

    ~DataService()
    {
        Console.WriteLine("  [DataService]: DataService finalized.");
    }
}

// Short-lived subscriber implementing IDisposable
public class DataConsumer : IDisposable
{
    private bool _disposed = false;
    private DataService _dataService; // Reference to the long-lived publisher
    private string _name;

    public DataConsumer(string name, DataService dataService)
    {
        _name = name;
        _dataService = dataService;

        // Subscribe to the event using a named method
        _dataService.DataUpdated += HandleDataUpdated;
        Console.WriteLine($"  [DataConsumer]: '{_name}' subscribed to DataService.");
    }

    private void HandleDataUpdated(object sender, string e)
    {
        Console.WriteLine($"  [DataConsumer]: '{_name}' received data: {e}");
    }

    // Public Dispose method
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this); // Prevent finalizer from running
        Console.WriteLine($"  [DataConsumer]: '{_name}' public Dispose() called.");
    }

    // Protected virtual Dispose method (where cleanup happens)
    protected virtual void Dispose(bool disposing)
    {
        if (_disposed) return;

        if (disposing)
        {
            // Clean up managed resources, including unsubscribing from events
            Console.WriteLine($"  [DataConsumer]: '{_name}' unsubscribing from DataService...");
            if (_dataService != null)
            {
                _dataService.DataUpdated -= HandleDataUpdated; // Crucial unsubscription
                _dataService = null; // Release reference to publisher
            }
        }

        // Clean up unmanaged resources here (if any)

        _disposed = true;
    }

    // Finalizer (only if directly owning unmanaged resources, as a fallback)
    ~DataConsumer()
    {
        Console.WriteLine($"  [DataConsumer]: '{_name}' Finalizer called (forgotten Dispose).");
        Dispose(false); // Only unmanaged cleanup
    }
}

public static class EventUnsubscribeExample
{
    public static void Run()
    {
        Console.WriteLine("--- Safe Event Unsubscription ---");

        DataService globalService = new DataService(); // This service is long-lived

        Console.WriteLine("\nScenario 1: DataConsumer is created and properly disposed.");
        using (var consumerA = new DataConsumer("ConsumerA", globalService))
        {
            globalService.SimulateDataUpdate("Message 1 for A");
        } // consumerA.Dispose() is called automatically here
        globalService.SimulateDataUpdate("Message AFTER ConsumerA disposed"); // ConsumerA should not receive this

        Console.WriteLine("\nScenario 2: DataConsumer is created but NOT disposed (will leak if no finalizer or unmanaged resource).");
        var consumerB = new DataConsumer("ConsumerB", globalService);
        globalService.SimulateDataUpdate("Message 1 for B");
        consumerB = null; // Remove direct reference, but DataService still holds reference

        Console.WriteLine("  (Forcing GC to demonstrate leak for ConsumerB)");
        GC.Collect();
        GC.WaitForPendingFinalizers(); // Finalizer might run for ConsumerB if it has unmanaged resources
        GC.Collect();
        Thread.Sleep(100);
        globalService.SimulateDataUpdate("Message AFTER GC attempt for ConsumerB"); // ConsumerB still receives this if leaked

        // Stop the global service and make it eligible for GC
        globalService = null;
        Console.WriteLine("\n  (Forcing GC to collect DataService and remaining objects)");
        GC.Collect();
        GC.WaitForPendingFinalizers();
        GC.Collect();

        Console.WriteLine("\n--- End of Safe Event Unsubscription Demo ---");
    }
}
```