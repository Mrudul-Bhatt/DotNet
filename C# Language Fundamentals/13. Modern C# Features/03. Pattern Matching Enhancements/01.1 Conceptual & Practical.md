## What is pattern matching in C\#? How is it different from traditional type checking?

**Pattern matching** in C\# is a powerful set of features that allows you to **test an expression against various "patterns" and, if a match is found, extract data from the expression into new variables or perform specific actions.** It combines type checking, casting, and conditional logic into a single, more concise, and expressive syntax.

**How it's different from traditional type checking (`is` + cast):**

Traditional type checking often involves a two-step process:

1.  **Check the type:** Use the `is` operator to determine if an object is of a particular type.
2.  **Cast and use:** If the type matches, cast the object to that type to access its members.

**Traditional `is` + cast:**

```csharp
object obj = "Hello, Pattern Matching!";

if (obj is string) // Step 1: Type check
{
    string s = (string)obj; // Step 2: Cast
    Console.WriteLine(s.Length);
}
else if (obj is int)
{
    int i = (int)obj;
    Console.WriteLine(i * 2);
}
```

**Pattern Matching (`is` expression, `switch` expression/statement):**

Pattern matching combines these steps, making the code more fluid and often reducing the need for explicit casting:

```csharp
object obj = "Hello, Pattern Matching!";

// 'is' type pattern (introduced in C# 7.0)
if (obj is string s) // Checks if obj is a string AND if it is, assigns it to a new 's' variable
{
    Console.WriteLine(s.Length); // 's' is already typed as string
}
else if (obj is int i)
{
    Console.WriteLine(i * 2);
}

// 'switch' expression (introduced in C# 8.0)
string result = obj switch
{
    string s => $"String length: {s.Length}", // Pattern: string s
    int i => $"Integer doubled: {i * 2}",     // Pattern: int i
    _ => "Unknown type"                        // Discard pattern for default case
};
Console.WriteLine(result);
```

**Key Advantages of Pattern Matching:**

  * **Conciseness:** Reduces boilerplate code (`if (x is Y) { Y y = (Y)x; ... }`).
  * **Expressiveness:** Makes the intent of the code clearer by combining type checking and data extraction.
  * **Safety:** The new variable (e.g., `s` or `i` in the examples above) is only in scope if the pattern matches, preventing `NullReferenceException` from failed casts.
  * **Flexibility:** Goes beyond simple type checks to include value checks, property checks, and more complex logical combinations.

## What are some built-in patterns in C\# 7â€“12?

Pattern matching has evolved significantly across C\# versions 7 through 12, introducing a rich set of patterns. Here are some of the most important built-in patterns:

1.  **Type Pattern (C\# 7.0):**

      * Tests if an expression is of a specific type.
      * Syntax: `expression is Type variableName`
      * Example: `if (obj is string s) { ... }`

2.  **Constant Pattern (C\# 7.0):**

      * Tests if an expression's value is equal to a specified constant.
      * Syntax: `expression is constantValue`
      * Example: `case 5:` or `case null:` in a `switch` statement.
      * Example with `is`: `if (statusCode is 200) { ... }`

3.  **Var Pattern (C\# 7.0):**

      * Always matches, and captures the value of the expression into a new `var` local variable. Useful for debugging or when you want to name the result of an expression within a `switch` statement or `if` statement.
      * Syntax: `expression is var variableName`
      * Example: `case var x: Console.WriteLine($"Value is {x}"); break;`

4.  **Relational Patterns (C\# 9.0):**

      * Tests if an expression's value satisfies a relational condition (less than, greater than, etc.).
      * Syntax: `expression is < | <= | > | >= constantValue`
      * Example:
        ```csharp
        int score = 85;
        string grade = score switch
        {
            >= 90 => "A",
            >= 80 => "B",
            >= 70 => "C",
            _ => "F"
        };
        ```

5.  **Logical Patterns (`and`, `or`, `not`) (C\# 9.0):**

      * Combines multiple patterns using logical operators.
      * Syntax: `pattern1 and pattern2`, `pattern1 or pattern2`, `not pattern`
      * Example:
        ```csharp
        object item = 15;
        if (item is int i and > 10 and < 20) { // int AND greater than 10 AND less than 20
            Console.WriteLine($"Number is between 10 and 20: {i}");
        }
        if (item is string s or int { } n) { // string OR int (any int)
            Console.WriteLine("Item is a string or an int.");
        }
        if (item is not null) { // NOT null
            Console.WriteLine("Item is not null.");
        }
        ```

6.  **Property Patterns (C\# 8.0):**

      * Tests if an expression matches a certain type *and* if its properties (or fields) match nested patterns.
      * Syntax: `{ PropertyName: nestedPattern, AnotherProperty: anotherNestedPattern }`
      * Example:
        ```csharp
        public class Point { public int X { get; set; } public int Y { get; set; } }
        Point p = new Point { X = 10, Y = 20 };
        if (p is { X: 10, Y: > 15 }) // If p is a Point and X is 10 and Y is greater than 15
        {
            Console.WriteLine("Point matches criteria.");
        }
        ```

7.  **Positional Patterns (C\# 8.0):**

      * Tests against deconstructed values of a type. Requires the type to have a `Deconstruct` method.
      * Syntax: `(pattern1, pattern2, ...)`
      * Example:
        ```csharp
        // Point struct with a Deconstruct method
        public record Point(int X, int Y); // Records automatically provide Deconstruct

        Point p = new(5, 10);
        string quadrant = p switch
        {
            (0, 0) => "Origin",
            (int x, int y) when x > 0 && y > 0 => "Quadrant 1", // Capture and guard
            _ => "Other"
        };
        ```

8.  **Var Pattern (C\# 9.0 - extended usage):**

      * The `var` pattern in a `switch` expression case can capture the result of a pattern match into a new local variable.

9.  **Parenthesized Patterns (C\# 9.0):**

      * Allows grouping of patterns to control precedence.
      * Example: `if (value is (int or string) and not null)`

10. **List Patterns (C\# 11):**

      * Matches against sequences of elements in arrays or lists.
      * Syntax: `[pattern1, pattern2, ..., patternN]` or `[pattern1, ..., patternN]` (range pattern) or `[pattern1, .., patternN]` (spread pattern)
      * Example:
        ```csharp
        int[] numbers = { 1, 2, 3, 4, 5 };
        if (numbers is [1, 2, _, 4, _]) // Matches if starts with 1, 2, then any, then 4, then any
        {
            Console.WriteLine("Matches a specific sequence pattern.");
        }
        if (numbers is [_, _, .., 5]) // Matches if ends with 5, ignoring first two
        {
            Console.WriteLine("Matches a sequence ending with 5.");
        }
        ```

11. **Ref Patterns (C\# 11):**

      * Matches against `ref` variables.

12. **`is not` Null Pattern (C\# 9.0):**

      * Combines the `is` operator with the `not` keyword to concisely check for non-null.
      * Example: `if (obj is not null) { ... }` (shorthand for `if (obj != null)`)

These patterns, when used with `is` expressions, `switch` statements, and `switch` expressions, make C\# code significantly more expressive and robust for handling various data shapes.

## Explain the difference between `switch` statements and `switch` expressions in the context of pattern matching.

Both `switch` statements and `switch` expressions leverage pattern matching, but they serve different purposes and have distinct syntaxes and behaviors.

### `switch` Statement (Traditional, Imperative)

  * **Purpose:** To execute **different blocks of code** based on matching a single value or a pattern. It's a control flow statement.
  * **Syntax:** Uses `case` labels with colons, and requires `break;` (or `return;`, `throw;`, `goto;`) to exit a `case` block to prevent fall-through.
  * **Returns Value:** No, a `switch` statement does not return a value. Each `case` executes a block of code.
  * **Exhaustiveness:** Not strictly exhaustive by default. If no `case` matches and there's no `default` case, nothing happens (or runtime error if no default for some pattern matches are possible).
  * **Flexibility with Patterns:** Supports all the pattern matching features.

**Example of `switch` Statement:**

```csharp
public void ProcessStatusCode(int statusCode)
{
    switch (statusCode) // Here statusCode is the *expression* being matched
    {
        case 200:
            Console.WriteLine("OK");
            break; // Must break
        case int s when s >= 400 && s < 500: // Type pattern with a 'when' clause
            Console.WriteLine("Client Error");
            break;
        case >= 500: // Relational pattern
            Console.WriteLine("Server Error");
            break;
        default: // Default case
            Console.WriteLine("Informational or Unknown");
            break;
    }
}
```

### `switch` Expression (Newer, Functional, Returns Value)

  * **Purpose:** To **evaluate an expression and return a single value** based on matching a pattern. It's an expression, not a statement.
  * **Syntax (C\# 8.0+):** Uses `=>` (lambda-like syntax) for each arm, and commas `,` to separate arms. No `break;` needed as it's an expression.
  * **Returns Value:** Yes, it *must* return a value. Each arm must produce a value.
  * **Exhaustiveness:** **Must be exhaustive** (C\# 8.0 introduced this). This means it must cover all possible input values for the type being matched. If not, the compiler will issue a warning. You often use a discard pattern (`_`) as the final arm to handle any unhandled cases, making it exhaustive.
  * **Conciseness:** Designed for conciseness, especially for mapping inputs to outputs.
  * **Flexibility with Patterns:** Supports all the pattern matching features, and often shines with property, positional, and logical patterns.

**Example of `switch` Expression:**

```csharp
public string GetStatusCodeDescription(int statusCode)
{
    // statusCode is the *expression* being matched
    string description = statusCode switch
    {
        200 => "OK", // Constant pattern
        >= 500 => "Server Error", // Relational pattern
        int s when s >= 400 && s < 500 => "Client Error", // Type pattern with 'when' clause
        _ => "Informational or Unknown" // Discard pattern, makes it exhaustive
    };
    return description;
}

// Example usage:
Console.WriteLine(GetStatusCodeDescription(200)); // Output: OK
Console.WriteLine(GetStatusCodeDescription(404)); // Output: Client Error
```

**Key Differences at a Glance:**

| Feature            | `switch` Statement                               | `switch` Expression                                 |
| :----------------- | :----------------------------------------------- | :-------------------------------------------------- |
| **Introduced** | C\# 1.0 (pattern matching features added later) | C\# 8.0                                              |
| **Nature** | Control flow statement                           | Expression (produces a value)                       |
| **Syntax** | `switch (value) { case pattern: code; break; }`  | `value switch { pattern => result, ... }`           |
| **Return Value** | No                                               | Yes, must return a value                            |
| **Fall-through** | Possible (if no `break`), but discouraged/rarely used with patterns | Not possible (each arm is a single expression)      |
| **Exhaustiveness** | Not inherently required, but `default` is common | Required (compiler warns if not exhaustive), `_` for default |
| **Primary Use** | Executing different actions/side effects         | Mapping inputs to outputs, assigning values         |
| **Conciseness** | More verbose                                     | More concise for value-producing logic              |