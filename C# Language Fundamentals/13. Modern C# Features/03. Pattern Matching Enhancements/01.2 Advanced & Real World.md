Today, July 17, 2025, let's explore how C\#'s pattern matching features elegantly solve common programming challenges, particularly those involving data validation, complex object structures, and flexible data processing.

-----

### ðŸ”¹ You're validating user input of different types (string, int, null). How can pattern matching make this cleaner?

(Use switch expressions or if with patterns like `is string s`, `is null`, or even `is > 0`.)

**Explanation:**

Validating user input often involves checking its type, its value, and handling `null`. Pattern matching provides a concise and readable way to perform these checks, replacing verbose `if-else if` blocks and explicit casts.

**How Pattern Matching Helps:**

1.  **`is` Type Patterns:** Directly checks the type and optionally captures the value in one go.

      * `if (input is string s)`: Checks if `input` is a string and, if so, assigns it to `s`.
      * `if (input is int i)`: Checks if `input` is an integer and captures it.

2.  **`is null` Pattern:** A clear and explicit way to check for `null`. This is preferred over `input == null` in pattern matching contexts.

3.  **Relational Patterns (`is > 0`, `is < 0`, `is >= 18`):** For numeric types, you can directly embed range checks.

4.  **`switch` Expressions:** The most powerful tool here. It allows you to define a single expression that evaluates to a result based on the input's type and properties. It inherently covers all cases (including `null` with `case null:`) and can be exhaustive.

**Code Example:**

```csharp
using System;

public static class InputValidationExample
{
    public static string ValidateInput(object? input)
    {
        Console.WriteLine($"\n--- Validating input: '{input ?? "null"}' (Type: {input?.GetType().Name ?? "null"}) ---");

        return input switch
        {
            // Case 1: Input is null
            null => "Input cannot be null.",

            // Case 2: Input is a non-empty string
            string s when !string.IsNullOrWhiteSpace(s) => $"Valid string input: '{s}'",

            // Case 3: Input is an empty or whitespace string
            string => "String input cannot be empty or whitespace.",

            // Case 4: Input is an int within a specific range
            int i when i > 0 && i <= 100 => $"Valid integer input: {i} (within range)",

            // Case 5: Input is an int outside the specific range
            int i => $"Invalid integer input: {i} (out of range)",

            // Case 6: Any other type
            _ => $"Invalid input type: {input.GetType().Name}"
        };
    }

    public static void Run()
    {
        Console.WriteLine("--- User Input Validation with Pattern Matching ---");

        Console.WriteLine(ValidateInput(null));
        Console.WriteLine(ValidateInput("Hello World"));
        Console.WriteLine(ValidateInput("   ")); // Empty/whitespace string
        Console.WriteLine(ValidateInput(""));    // Empty string
        Console.WriteLine(ValidateInput(42));
        Console.WriteLine(ValidateInput(150));
        Console.WriteLine(ValidateInput(-10));
        Console.WriteLine(ValidateInput(3.14)); // double
        Console.WriteLine(ValidateInput(true)); // bool

        Console.WriteLine("--- End User Input Validation ---");
    }
}
```

-----

### ðŸ”¹ You need to process a record with nested properties. How can property patterns simplify that?

(e.g., `if (person is { Address.ZipCode: "12345" })` â€” directly match nested values without null checks.)

**Explanation:**

Property patterns allow you to match against the values of an object's properties. When combined with the null-conditional operator (`?.`) implicitly handled by the pattern, or by explicitly matching `null` states, they provide an incredibly clean way to check for specific nested conditions without tedious null checks at each level.

**How Property Patterns Help:**

  * **Direct Nested Access:** You can directly specify `Parent.Child.Property: value` within the pattern. The pattern matching engine handles intermediate `null` checks gracefully; if any part of the path is `null`, the pattern simply doesn't match, preventing an NRE.
  * **Conciseness:** Reduces multiple `if` statements and temporary variables.
  * **Readability:** The condition is expressed declaratively, clearly stating the required state of the nested properties.

**Code Example:**

```csharp
using System;

#nullable enable // Enable nullable reference types for better analysis

public record Address(string Street, string City, string ZipCode); // C# 9.0+ records
public record ContactInfo(string Email, string Phone);

// Person record with nullable nested records
public record Person(string FirstName, string LastName)
{
    public Address? ResidentialAddress { get; init; } // Nullable Address
    public ContactInfo? ContactDetails { get; init; } // Nullable ContactInfo
}

public static class NestedPropertyPatternExample
{
    public static string CheckPersonEligibility(Person? person)
    {
        Console.WriteLine($"\n--- Checking eligibility for {person?.FirstName ?? "null"} ---");

        return person switch
        {
            // Case 1: Person is null
            null => "Person not found.",

            // Case 2: Person lives in a specific zip code
            // This directly checks nested properties. If ResidentialAddress is null, this case won't match.
            { ResidentialAddress.ZipCode: "90210" } => $"{person.FirstName} lives in Beverly Hills (90210).",

            // Case 3: Person has a specific email domain AND specific zip code (logical 'and')
            { ContactDetails.Email: var email, ResidentialAddress.ZipCode: "10001" } when email?.EndsWith("@example.com") == true =>
                $"{person.FirstName} is an Example.com user in NYC (10001).",

            // Case 4: Person has a contact phone number that starts with '555' (property pattern + type pattern)
            { ContactDetails.Phone: var phone } when phone?.StartsWith("555") == true =>
                $"{person.FirstName} has a '555' phone number.",

            // Case 5: Person has a non-null address in "Springfield"
            { ResidentialAddress.City: "Springfield" } => $"{person.FirstName} lives in Springfield.",

            // Case 6: Person has no residential address
            { ResidentialAddress: null } => $"{person.FirstName} has no residential address.",

            // Default case
            _ => $"{person.FirstName} does not meet specific criteria."
        };
    }

    public static void Run()
    {
        Console.WriteLine("--- Nested Property Patterns ---");

        Person person1 = new Person("Brenda", "Walsh")
        {
            ResidentialAddress = new Address("Main St", "Beverly Hills", "90210"),
            ContactDetails = new ContactInfo("brenda@example.org", "555-123-4567")
        };
        Console.WriteLine(CheckPersonEligibility(person1));

        Person person2 = new Person("Dylan", "McKay")
        {
            ResidentialAddress = new Address("Broadway", "New York", "10001"),
            ContactDetails = new ContactInfo("dylan@example.com", "555-987-6543")
        };
        Console.WriteLine(CheckPersonEligibility(person2));

        Person person3 = new Person("Marge", "Simpson")
        {
            ResidentialAddress = new Address("Evergreen Terrace", "Springfield", "62704"),
            ContactDetails = null
        };
        Console.WriteLine(CheckPersonEligibility(person3));

        Person person4 = new Person("Homer", "Simpson") { ResidentialAddress = null, ContactDetails = null };
        Console.WriteLine(CheckPersonEligibility(person4));

        Person person5 = new Person("Steve", "Rogers") { ResidentialAddress = new Address("Anywhere", "Anytown", "12345"), ContactDetails = new ContactInfo("steve@avengers.com", "111-222-3333") };
        Console.WriteLine(CheckPersonEligibility(person5));

        Console.WriteLine(CheckPersonEligibility(null));

        Console.WriteLine("--- End Nested Property Patterns ---");
    }
}
#nullable disable
```

-----

### ðŸ”¹ When processing HTTP responses with different result types, how can pattern matching with `switch` expression help?

(Cleanly handle types like `OkResult`, `NotFoundResult`, `BadRequestResult` by matching on their types and extracting values inline.)

**Explanation:**

In web APIs or client applications, handling various HTTP response types (e.g., from `IActionResult` in ASP.NET Core) can become cumbersome with traditional `if-else if` blocks. `switch` expressions with type patterns offer a clean, expressive, and exhaustive way to process these.

**How Pattern Matching Helps:**

  * **Type-Based Dispatch:** You can directly match the specific type of the response object (e.g., `OkObjectResult`, `NotFoundResult`, `BadRequestObjectResult`).
  * **Inline Value Extraction:** For types that contain data (like `OkObjectResult` or `BadRequestObjectResult`), you can simultaneously extract the inner value using type patterns (`case OkObjectResult okResult:`) or property patterns (`case BadRequestObjectResult { Value: string errorMessage }`).
  * **Exhaustiveness:** `switch` expressions are designed to be exhaustive. If you're switching on a sealed type hierarchy, the compiler can warn you if you haven't covered all cases. For open hierarchies, a discard pattern (`_`) handles unaddressed types.
  * **Readability:** The flow of logic is clear, making it easy to see how each response type is handled.

**Code Example:**

```csharp
using System;
using System.Collections.Generic;

// Simulate simplified ASP.NET Core IActionResult types
public abstract class IActionResult { }
public class OkResult : IActionResult { } // HTTP 200 OK without content
public class OkObjectResult : IActionResult { public object Value { get; } public OkObjectResult(object value) => Value = value; } // HTTP 200 OK with content
public class NotFoundResult : IActionResult { } // HTTP 404 Not Found
public class BadRequestResult : IActionResult { } // HTTP 400 Bad Request without content
public class BadRequestObjectResult : IActionResult { public object Value { get; } public BadRequestObjectResult(object value) => Value = value; } // HTTP 400 Bad Request with content
public class UnauthorizedResult : IActionResult { } // HTTP 401 Unauthorized


public static class HttpResponseProcessor
{
    public static string ProcessApiResponse(IActionResult result)
    {
        Console.WriteLine($"\n--- Processing API Response ({result.GetType().Name}) ---");

        return result switch
        {
            OkObjectResult okObject =>
                $"Success (200 OK) with data: {okObject.Value}", // Extracts 'Value'

            OkResult =>
                "Success (200 OK) with no content.",

            NotFoundResult =>
                "Error (404 Not Found): Resource not found.",

            BadRequestObjectResult badRequestObject when badRequestObject.Value is string msg =>
                $"Error (400 Bad Request) with message: '{msg}'", // Extracts string message

            BadRequestObjectResult badRequestObject =>
                $"Error (400 Bad Request) with generic data: {badRequestObject.Value}",

            UnauthorizedResult =>
                "Error (401 Unauthorized): Authentication failed.",

            // Discard pattern for any unhandled IActionResult type
            _ => $"Unhandled response type: {result.GetType().Name}"
        };
    }

    public static void Run()
    {
        Console.WriteLine("--- HTTP Response Processing with Pattern Matching ---");

        IActionResult response1 = new OkObjectResult(new { Message = "Data retrieved successfully", Count = 5 });
        Console.WriteLine(ProcessApiResponse(response1));

        IActionResult response2 = new OkResult();
        Console.WriteLine(ProcessApiResponse(response2));

        IActionResult response3 = new NotFoundResult();
        Console.WriteLine(ProcessApiResponse(response3));

        IActionResult response4 = new BadRequestObjectResult("Invalid input parameters provided.");
        Console.WriteLine(ProcessApiResponse(response4));

        IActionResult response5 = new UnauthorizedResult();
        Console.WriteLine(ProcessApiResponse(response5));

        IActionResult response6 = new BadRequestObjectResult(new List<string> { "Error1", "Error2" });
        Console.WriteLine(ProcessApiResponse(response6));

        Console.WriteLine("--- End HTTP Response Processing ---");
    }
}
```

-----

### ðŸ”¹ How do logical patterns like `and`, `or`, `not` improve expressiveness?

(e.g., `if (x is >= 0 and <= 100)` replaces verbose range checks.)

**Explanation:**

Logical patterns (`and`, `or`, `not`), introduced in C\# 9.0, allow you to combine existing patterns to form more complex and expressive conditions. They bring boolean logic directly into pattern matching syntax, making conditions incredibly concise and readable.

**How They Improve Expressiveness:**

1.  **`and` Pattern:**

      * Combines two patterns, both of which must match for the overall pattern to succeed.
      * **Improvement:** Replaces multiple nested `if` conditions or complex boolean expressions (`if (x >= 0 && x <= 100)`). It makes range checks (and other compound conditions) more declarative.
      * **Example:** `x is >= 0 and <= 100`

2.  **`or` Pattern:**

      * Combines two patterns, where either one matching is sufficient for the overall pattern to succeed.
      * **Improvement:** Replaces `||` (OR) operations with a more pattern-matching-centric syntax.
      * **Example:** `day is DayOfWeek.Saturday or DayOfWeek.Sunday`

3.  **`not` Pattern:**

      * Negates a pattern; it matches if the inner pattern does *not* match.
      * **Improvement:** Provides a direct way to express "is not of this type" or "does not have this value" within pattern matching.
      * **Example:** `if (obj is not null)` (preferred over `obj != null` in pattern matching context), `case string s and not ""` (matches non-empty strings).

**Code Example:**

```csharp
using System;
using System.Drawing; // For Color

public static class LogicalPatternsExample
{
    public static string DescribeNumber(int number) => number switch
    {
        // 'and' pattern for range checks
        >= 0 and <= 10 => "Small positive number (0-10)",
        > 10 and < 100 => "Medium positive number (11-99)",
        < 0 and > -100 => "Negative number (>-100)",
        // 'or' pattern
        100 or 1000 => "Exactly 100 or 1000",
        _ => "Other number"
    };

    public static string GetWeekendStatus(DayOfWeek day) => day switch
    {
        // 'or' pattern
        DayOfWeek.Saturday or DayOfWeek.Sunday => "It's the weekend!",
        // 'not' pattern
        not (DayOfWeek.Saturday or DayOfWeek.Sunday) => "It's a weekday.", // Explicitly not weekend
        _ => "Invalid day." // Should not be reached for DayOfWeek enum
    };

    public static string AnalyzeShapeCharacteristics(Shape shape)
    {
        Console.WriteLine($"\n--- Analyzing Shape: {shape.GetType().Name} (Color: {shape.Color}) ---");

        return shape switch
        {
            // Property pattern with logical 'and'
            Rectangle { Width: > 0 and <= 10, Height: > 0 and <= 10 } => "Small Square-like Rectangle",

            // Type pattern with logical 'and' and 'not'
            Circle c and not { Color: "Red" or "Blue" } => $"Non-red/blue Circle with radius {c.Radius}",

            // Property pattern with logical 'or'
            { Color: "Green" or "Yellow" } => "Green or Yellow shape",

            // 'not null' pattern (useful in 'if' statements or switch expressions)
            // if (shape is not null) ... (shown in earlier examples)
            _ => "Other shape characteristics."
        };
    }

    public static void Run()
    {
        Console.WriteLine("--- Logical Patterns (`and`, `or`, `not`) ---");

        Console.WriteLine($"Describe(5): {DescribeNumber(5)}");
        Console.WriteLine($"Describe(50): {DescribeNumber(50)}");
        Console.WriteLine($"Describe(-50): {DescribeNumber(-50)}");
        Console.WriteLine($"Describe(100): {DescribeNumber(100)}");
        Console.WriteLine($"Describe(1000): {DescribeNumber(1000)}");
        Console.WriteLine($"Describe(101): {DescribeNumber(101)}");

        Console.WriteLine($"\nMonday: {GetWeekendStatus(DayOfWeek.Monday)}");
        Console.WriteLine($"Saturday: {GetWeekendStatus(DayOfWeek.Saturday)}");

        Console.WriteLine(AnalyzeShapeCharacteristics(new Rectangle { Width = 8, Height = 8, Color = "Brown" }));
        Console.WriteLine(AnalyzeShapeCharacteristics(new Rectangle { Width = 15, Height = 15, Color = "Green" }));
        Console.WriteLine(AnalyzeShapeCharacteristics(new Circle { Radius = 5, Color = "Orange" }));
        Console.WriteLine(AnalyzeShapeCharacteristics(new Circle { Radius = 5, Color = "Red" }));

        Console.WriteLine("--- End Logical Patterns ---");
    }
}
```

-----

### ðŸ”¹ You want to match multiple unrelated types (e.g., `int` or `double`) and perform a calculation. How would you write that?

(e.g., `switch (value) { case int i: ..., case double d: ... }`)

**Explanation:**

Pattern matching with `switch` expressions (or statements) is excellent for handling disparate types. Each `case` can specify a different type pattern, allowing you to perform type-specific operations or calculations.

**How to Write It:**

Simply list the different type patterns as separate cases within your `switch` expression or statement. The compiler will ensure that the correct case is executed based on the runtime type of the input.

**Code Example:**

```csharp
using System;

public static class MultipleTypeMatchingExample
{
    public static double CalculateValue(object? value)
    {
        Console.WriteLine($"\n--- Calculating Value for '{value ?? "null"}' (Type: {value?.GetType().Name ?? "null"}) ---");

        return value switch
        {
            // Case 1: Input is an integer
            int i => (double)i * 2.0, // Double the integer

            // Case 2: Input is a double
            double d => d / 2.0, // Halve the double

            // Case 3: Input is a string that can be parsed as a number
            string s when double.TryParse(s, out double parsedValue) => parsedValue * 1.5, // Parse and multiply by 1.5

            // Case 4: Input is a string that cannot be parsed
            string => throw new ArgumentException("String cannot be parsed as a number."),

            // Case 5: Input is null
            null => throw new ArgumentNullException(nameof(value), "Input cannot be null."),

            // Case 6: Any other type
            _ => throw new ArgumentException($"Unsupported type: {value.GetType().Name}")
        };
    }

    public static void Run()
    {
        Console.WriteLine("--- Matching Multiple Unrelated Types ---");

        Console.WriteLine($"CalculateValue(10)      : {CalculateValue(10)}");       // int
        Console.WriteLine($"CalculateValue(20.0)    : {CalculateValue(20.0)}");     // double
        Console.WriteLine($"CalculateValue(\"50\")  : {CalculateValue("50")}");     // string (parsable)
        Console.WriteLine($"CalculateValue(\"10.5\") : {CalculateValue("10.5")}");   // string (parsable)

        try
        {
            Console.WriteLine($"CalculateValue(\"abc\") : {CalculateValue("abc")}"); // string (non-parsable)
        }
        catch (ArgumentException ex)
        {
            Console.WriteLine($"  Caught expected exception: {ex.Message}");
        }

        try
        {
            Console.WriteLine($"CalculateValue(true)  : {CalculateValue(true)}");   // bool (unsupported)
        }
        catch (ArgumentException ex)
        {
            Console.WriteLine($"  Caught expected exception: {ex.Message}");
        }

        try
        {
            Console.WriteLine($"CalculateValue(null)    : {CalculateValue(null)}");   // null
        }
        catch (ArgumentNullException ex)
        {
            Console.WriteLine($"  Caught expected exception: {ex.Message}");
        }

        Console.WriteLine("--- End Matching Multiple Unrelated Types ---");
    }
}
```

-----

### ðŸ”¹ You're building a DSL or interpreter with nodes like `BinaryExpr`, `UnaryExpr`, etc. How can pattern matching simplify evaluation?

(Use recursive patterns and type matching in switch expressions â€” eliminates a lot of manual casting.)

**Explanation:**

For Domain-Specific Languages (DSLs) or interpreters that process abstract syntax trees (ASTs), `switch` expressions with recursive patterns are incredibly powerful. They allow you to define evaluation logic for different types of expression nodes in a very natural, recursive manner, avoiding complex `if-else if` chains and manual type checking/casting.

**How Pattern Matching Simplifies Evaluation:**

1.  **Type-Based Dispatch:** Each `case` in the `switch` expression corresponds to a specific type of AST node (e.g., `NumberExpression`, `BinaryExpression`).
2.  **Recursive Patterns:** Crucially, within a pattern, you can nest *another* pattern. This is perfect for ASTs where an expression's operands are themselves expressions.
      * `case BinaryExpression { Left: var leftExpr, Right: var rightExpr, Operator: '+' }`: Matches a binary expression, extracts its left and right operands, and checks the operator. You can then recursively call `Evaluate` on `leftExpr` and `rightExpr`.
3.  **Inline Variable Declaration:** Variables for captured parts of the pattern (`var leftExpr`, `var rightExpr`) are directly available in the pattern's body.
4.  **Exhaustiveness:** Helps ensure all possible node types are handled.

**Code Example (Simplified Expression Tree):**

```csharp
using System;

// Define base expression node and derived types
public abstract record Expression;
public record NumberExpression(double Value) : Expression;
public record BinaryExpression(Expression Left, char Operator, Expression Right) : Expression;
public record UnaryExpression(char Operator, Expression Operand) : Expression;
public record VariableExpression(string Name) : Expression;

public static class DslInterpreterExample
{
    // A dictionary to store variable values (for a simple interpreter)
    private static Dictionary<string, double> _variables = new Dictionary<string, double>();

    public static double Evaluate(Expression expr)
    {
        return expr switch
        {
            // NumberExpression: Directly return its value
            NumberExpression(var value) => value,

            // BinaryExpression: Recursively evaluate left and right, then apply operator
            BinaryExpression(var left, '+', var right) => Evaluate(left) + Evaluate(right),
            BinaryExpression(var left, '-', var right) => Evaluate(left) - Evaluate(right),
            BinaryExpression(var left, '*', var right) => Evaluate(left) * Evaluate(right),
            BinaryExpression(var left, '/', var right) => Evaluate(left) / Evaluate(right),

            // UnaryExpression: Recursively evaluate operand, then apply operator
            UnaryExpression('-', var operand) => -Evaluate(operand),
            UnaryExpression('+', var operand) => +Evaluate(operand), // Unary plus

            // VariableExpression: Look up its value
            VariableExpression(var name) =>
                _variables.TryGetValue(name, out double varValue) ?
                    varValue :
                    throw new KeyNotFoundException($"Variable '{name}' not found."),

            // Discard pattern for unsupported expression types
            _ => throw new ArgumentException($"Unsupported expression type: {expr.GetType().Name}")
        };
    }

    public static void Run()
    {
        Console.WriteLine("--- DSL/Interpreter with Pattern Matching ---");

        // Example: 5 + (2 * 3) - 1
        Expression expression1 = new BinaryExpression(
            new BinaryExpression(
                new NumberExpression(5),
                '+',
                new BinaryExpression(
                    new NumberExpression(2),
                    '*',
                    new NumberExpression(3)
                )
            ),
            '-',
            new NumberExpression(1)
        );
        Console.WriteLine($"Result of (5 + (2 * 3) - 1): {Evaluate(expression1)}"); // Expected: 10

        // Example: -X + Y where X=10, Y=20
        _variables["X"] = 10;
        _variables["Y"] = 20;
        Expression expression2 = new BinaryExpression(
            new UnaryExpression('-', new VariableExpression("X")),
            '+',
            new VariableExpression("Y")
        );
        Console.WriteLine($"Result of (-X + Y) with X=10, Y=20: {Evaluate(expression2)}"); // Expected: 10

        // Example: Division by zero (will throw)
        Expression expression3 = new BinaryExpression(
            new NumberExpression(10),
            '/',
            new NumberExpression(0)
        );
        try
        {
            Console.WriteLine($"\nResult of (10 / 0): {Evaluate(expression3)}");
        }
        catch (DivideByZeroException)
        {
            Console.WriteLine("  Caught expected DivideByZeroException.");
        }

        Console.WriteLine("--- End DSL/Interpreter ---");
    }
}
```

-----

### ðŸ”¹ You refactor legacy `if-else` chains checking object types and properties. What pattern matching techniques would you use?

(Type patterns, property patterns, and `when` clauses to combine type checks and conditions cleanly.)

**Explanation:**

Legacy code often features long, unwieldy `if-else if` constructs that check an object's type, cast it, and then check its properties. Pattern matching is the ideal tool for refactoring such code, making it far more readable, maintainable, and less prone to errors.

**Pattern Matching Techniques for Refactoring:**

1.  **`is` Type Patterns (`if (obj is Type varName)`):**

      * **Replacement for:** `if (obj is Type) { Type varName = (Type)obj; ... }`
      * **Benefit:** Combines the type check and safe cast into a single, compact expression.

2.  **`switch` Expressions (or Statements with Type Patterns):**

      * **Replacement for:** Long `if-else if` ladders that dispatch based on type.
      * **Benefit:** Provides a more structured, readable, and often exhaustive way to handle multiple type-dependent branches.

3.  **Property Patterns (`case Type { Property1: value1, Property2: value2 }`):**

      * **Replacement for:** Nested `if` statements after a type check and cast (`if (myObj.Property1 == value1 && myObj.Property2 == value2)`).
      * **Benefit:** Allows direct matching against property values within the pattern, even for nested properties, reducing verbosity and eliminating manual null checks for intermediate properties.

4.  **`when` Clauses (`case Type varName when condition:`):**

      * **Replacement for:** `if` conditions *after* a type check and cast (`if (obj is Type) { Type varName = (Type)obj; if (condition) { ... } }`).
      * **Benefit:** Integrates an arbitrary boolean condition directly into the pattern, allowing more flexible matching logic within a single `case`.

5.  **Logical Patterns (`and`, `or`, `not`):**

      * **Replacement for:** Complex boolean expressions within `if` conditions or `when` clauses.
      * **Benefit:** Make compound conditions highly declarative and concise.

**Code Example:**

```csharp
using System;
using System.Collections.Generic;

// Reusing Shape hierarchy from previous examples
// public class Shape { public string Color { get; set; } = "Unknown"; }
// public class Circle : Shape { public double Radius { get; set; } }
// public class Rectangle : Shape { public double Width { get; set; } public double Height { get; set; } }
// public class Triangle : Shape { public double Base { get; set; } public double Height { get; set; } }

public static class RefactorLegacyIfElseExample
{
    // --- Legacy Code (pre-pattern matching) ---
    public static string ProcessShapeLegacy(Shape? shape)
    {
        if (shape == null)
        {
            return "No shape to process (legacy).";
        }
        else if (shape is Circle)
        {
            Circle circle = (Circle)shape; // Explicit cast
            if (circle.Radius > 10)
            {
                return $"Large circle (legacy) with radius {circle.Radius}.";
            }
            else
            {
                return $"Small/medium circle (legacy) with radius {circle.Radius}.";
            }
        }
        else if (shape is Rectangle)
        {
            Rectangle rect = (Rectangle)shape; // Explicit cast
            if (rect.Width == rect.Height)
            {
                if (rect.Color == "Red")
                {
                    return $"Red square (legacy) of size {rect.Width}.";
                }
                else
                {
                    return $"Non-red square (legacy) of size {rect.Width}.";
                }
            }
            else
            {
                return $"Non-square rectangle (legacy) {rect.Width}x{rect.Height}.";
            }
        }
        else
        {
            return $"Unknown shape type (legacy): {shape.GetType().Name}.";
        }
    }

    // --- Refactored Code (using Pattern Matching) ---
    public static string ProcessShapeRefactored(Shape? shape)
    {
        return shape switch
        {
            // Null pattern
            null => "No shape to process (refactored).",

            // Type pattern with 'when' clause for conditional logic
            Circle c when c.Radius > 10 => $"Large circle (refactored) with radius {c.Radius}.",
            Circle c => $"Small/medium circle (refactored) with radius {c.Radius}.",

            // Property patterns for nested conditions (C# 8.0+)
            Rectangle { Width: var w, Height: var h, Color: "Red" } when w == h => $"Red square (refactored) of size {w}.",
            Rectangle { Width: var w, Height: var h } when w == h => $"Non-red square (refactored) of size {w}.",

            // Any other rectangle (no property match needed beyond type)
            Rectangle r => $"Non-square rectangle (refactored) {r.Width}x{r.Height}.",

            // Discard pattern for any other Shape or object
            _ => $"Unknown shape type (refactored): {shape.GetType().Name}."
        };
    }

    public static void Run()
    {
        Console.WriteLine("--- Refactoring Legacy If-Else Chains ---");

        Shape s1 = new Circle { Radius = 15, Color = "Blue" };
        Shape s2 = new Circle { Radius = 7, Color = "Green" };
        Shape s3 = new Rectangle { Width = 5, Height = 5, Color = "Red" };
        Shape s4 = new Rectangle { Width = 7, Height = 7, Color = "Yellow" };
        Shape s5 = new Rectangle { Width = 4, Height = 8, Color = "Orange" };
        Shape s6 = new Triangle { Base = 3, Height = 4, Color = "Purple" };
        Shape s7 = null!;

        Console.WriteLine("\n--- Legacy Processing ---");
        Console.WriteLine(ProcessShapeLegacy(s1));
        Console.WriteLine(ProcessShapeLegacy(s2));
        Console.WriteLine(ProcessShapeLegacy(s3));
        Console.WriteLine(ProcessShapeLegacy(s4));
        Console.WriteLine(ProcessShapeLegacy(s5));
        Console.WriteLine(ProcessShapeLegacy(s6));
        Console.WriteLine(ProcessShapeLegacy(s7));

        Console.WriteLine("\n--- Refactored Processing ---");
        Console.WriteLine(ProcessShapeRefactored(s1));
        Console.WriteLine(ProcessShapeRefactored(s2));
        Console.WriteLine(ProcessShapeRefactored(s3));
        Console.WriteLine(ProcessShapeRefactored(s4));
        Console.WriteLine(ProcessShapeRefactored(s5));
        Console.WriteLine(ProcessShapeRefactored(s6));
        Console.WriteLine(ProcessShapeRefactored(s7));

        Console.WriteLine("--- End Refactoring Legacy If-Else Chains ---");
    }
}
```

The refactored `ProcessShapeRefactored` method is significantly more compact, readable, and safer than its legacy counterpart, clearly demonstrating the power of pattern matching.