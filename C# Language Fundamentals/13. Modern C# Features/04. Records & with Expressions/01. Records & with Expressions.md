Today, July 17, 2025, let's explore C\#'s `record` types and `with` expressions, features primarily focused on simplifying the creation and usage of immutable, value-based data types. These are powerful additions for modern C\# development, especially when dealing with data modeling and patterns like Domain-Driven Design (DDD).

-----

### Records & `with` Expressions

**Focus:** Immutable, value-based types

`record` types, introduced in C\# 9.0, are reference types (by default, can also be `record struct` in C\# 10+) that provide built-in functionality for working with data. Their primary goal is to make it easy to create immutable data models, offering benefits like value equality, concise syntax, and non-destructive mutation.

#### 1\. `record` vs `class`

| Feature           | `class` (Reference Type)                     | `record` (Reference Type by Default)    |
| :---------------- | :------------------------------------------- | :-------------------------------------- |
| **Equality** | **Reference equality** (default `Equals`, `==`) | **Value equality** (default `Equals`, `==`) |
| **Immutability** | Mutable by default (requires manual effort)  | Immutable by default (init-only setters) |
| **Syntax** | Traditional property/field declarations      | Concise positional or nominal syntax    |
| **`ToString()`** | Returns type name                             | Formatted string with property values   |
| **Deconstruction** | Manual `Deconstruct` method required         | Automatic for positional records        |
| **`with` Expression** | Not supported by default (`record` specific) | Built-in support for non-destructive mutation |
| **Inheritance** | Full inheritance supported                   | Inheritance supported, but with nuances for value equality |

#### 2\. `record struct` (C\# 10.0)

Introduced in C\# 10.0, `record struct` combines the benefits of `record` (value equality, concise syntax, `with` expressions) with the characteristics of `struct` (value type, stored on the stack or inline in arrays).

  * **When to use `record class` vs. `record struct`:**
      * **`record class` (default `record`):** For larger, more complex data models where reference semantics might still be desired in some contexts, or when you need inheritance in the traditional sense. Generally, `record class` is the go-to for data transfer objects (DTOs) or domain entities where immutability and value equality are paramount.
      * **`record struct`:** For small, immutable data types that behave like primitive values (e.g., a `Point` or `Money` type). They avoid heap allocations, which can be a performance benefit in performance-critical scenarios, but come with the typical struct caveats (e.g., copying behavior, mutable parts can break value equality if not handled carefully).

#### 3\. Positional Records

This is the most concise way to declare a record. Properties are defined directly in the record header, and a primary constructor is automatically generated. These properties are `init`-only by default, ensuring immutability after construction.

**Syntax:** `public record Person(string FirstName, string LastName, int Age);`

  * Automatically generates:
      * `public string FirstName { get; init; }`
      * `public string LastName { get; init; }`
      * `public int Age { get; init; }`
      * A primary constructor `public Person(string FirstName, string LastName, int Age)`.
      * Value-based `Equals`, `GetHashCode`, `ToString()`.
      * A `Deconstruct` method.

#### 4\. `with` Expressions for Non-Destructive Mutation

`with` expressions allow you to create a *new* instance of a `record` (or `record struct`) that is a copy of an existing instance, but with specified properties modified. The original instance remains unchanged. This is a cornerstone of immutable data patterns.

**Syntax:** `var newRecord = existingRecord with { PropertyToChange = newValue };`

**Code Examples:**

```csharp
using System;
using System.Collections.Generic;

// 1. Nominal Record (more like a traditional class, but with record features)
public record Product
{
    public int ProductId { get; init; }
    public string Name { get; init; } = string.Empty;
    public decimal Price { get; init; }
    public DateTime CreatedDate { get; init; } = DateTime.UtcNow; // Default value

    // Optional: Custom constructor for nominal record
    public Product(int productId, string name, decimal price)
    {
        ProductId = productId;
        Name = name;
        Price = price;
    }
}

// 2. Positional Record (most concise)
public record Person(string FirstName, string LastName, int Age);

// 3. Record Struct (C# 10+)
public record struct Point(double X, double Y);

// 4. Record with custom behavior (example with derived record)
public record Employee(string FirstName, string LastName, int Age, string EmployeeId)
    : Person(FirstName, LastName, Age) // Inherits from Person
{
    // Can add more properties specific to Employee
    public decimal Salary { get; init; }
}

public static class RecordExamples
{
    public static void Run()
    {
        Console.WriteLine("--- Records & with Expressions ---");

        // --- Positional Records ---
        Console.WriteLine("\n--- Positional Records ---");
        Person person1 = new("Alice", "Smith", 30);
        Person person2 = new("Bob", "Johnson", 25);
        Person person3 = new("Alice", "Smith", 30); // Same values as person1

        Console.WriteLine($"person1: {person1}"); // Uses generated ToString()
        Console.WriteLine($"person2: {person2}");

        // Value Equality
        Console.WriteLine($"person1 == person3: {person1 == person3}"); // True (value equality)
        Console.WriteLine($"person1.Equals(person3): {person1.Equals(person3)}"); // True
        Console.WriteLine($"person1 == person2: {person1 == person2}");   // False

        // Deconstruction
        var (fName, lName, age) = person1;
        Console.WriteLine($"Deconstructed person1: FirstName={fName}, LastName={lName}, Age={age}");

        // --- Nominal Records ---
        Console.WriteLine("\n--- Nominal Records ---");
        Product laptop = new(101, "Laptop", 1200.00m);
        Console.WriteLine($"Laptop: {laptop}"); // Uses generated ToString()

        Product desktop = new() { ProductId = 102, Name = "Desktop PC", Price = 900.00m };
        Console.WriteLine($"Desktop: {desktop}");

        // --- with Expressions (Non-destructive Mutation) ---
        Console.WriteLine("\n--- with Expressions ---");

        // Modifying a Person record
        Person updatedPerson1 = person1 with { Age = 31 }; // Create new Person instance with Age changed
        Console.WriteLine($"person1 (original): {person1}");
        Console.WriteLine($"updatedPerson1 (new instance): {updatedPerson1}");
        Console.WriteLine($"person1 == updatedPerson1: {person1 == updatedPerson1}"); // False (different instances, different Age)

        Person anotherUpdatedPerson1 = person1 with { FirstName = "Alicia" };
        Console.WriteLine($"anotherUpdatedPerson1: {anotherUpdatedPerson1}");

        // Modifying a Product record
        Product discountedLaptop = laptop with { Price = 1000.00m };
        Console.WriteLine($"Laptop (original): {laptop}");
        Console.WriteLine($"Discounted Laptop (new instance): {discountedLaptop}");
        Console.WriteLine($"Laptop == Discounted Laptop: {laptop == discountedLaptop}"); // False

        // --- Record Structs (C# 10+) ---
        Console.WriteLine("\n--- Record Structs ---");
        Point p1 = new(10.5, 20.0);
        Point p2 = new(10.5, 20.0);
        Point p3 = new(30.0, 40.0);

        Console.WriteLine($"p1: {p1}");
        Console.WriteLine($"p1 == p2: {p1 == p2}"); // True (value equality for structs)
        Console.WriteLine($"p1 == p3: {p1 == p3}"); // False

        // with expression on record struct
        Point p1Shifted = p1 with { X = p1.X + 5 };
        Console.WriteLine($"p1 (original): {p1}");
        Console.WriteLine($"p1Shifted (new struct): {p1Shifted}");
        Console.WriteLine($"p1 == p1Shifted: {p1 == p1Shifted}"); // False

        // --- Record Inheritance ---
        Console.WriteLine("\n--- Record Inheritance ---");
        Employee emp1 = new("Charlie", "Brown", 40, "EMP001") { Salary = 50000m };
        Console.WriteLine($"Employee emp1: {emp1}");

        // Can use with expression on inherited records, including base properties
        Employee emp2 = emp1 with { Salary = 55000m, Age = 41 };
        Console.WriteLine($"Employee emp2 (updated): {emp2}");

        Person personFromEmployee = emp1; // Upcast to base record
        Person samePersonFromEmployee = new Employee("Charlie", "Brown", 40, "EMP001") { Salary = 60000m };
        // Value equality for records compares types. So, Person and Employee are different types.
        Console.WriteLine($"personFromEmployee == samePersonFromEmployee: {personFromEmployee == samePersonFromEmployee}"); // True if comparing Person parts, but usually false because types differ.
                                                                                                                          // For record inheritance, value equality is structural and includes the runtime type.
                                                                                                                          // So this comparison will be false because emp1 is an Employee, even if base properties match.

        Console.WriteLine("--- End Records & with Expressions ---");
    }
}
```

### Interview Focus: Immutable Data Modeling, DDD Patterns

`record` types and `with` expressions are powerful tools for building robust and understandable applications, directly addressing common concerns in modern software design.

1.  **Immutable Data Modeling:**

      * **Question:** "Why is immutability beneficial, and how do records help enforce it?"
      * **Answer:**
          * **Benefits of Immutability:**
              * **Thread Safety:** Immutable objects can be shared across multiple threads without locks, as their state cannot change after creation, eliminating race conditions.
              * **Predictability:** The state of an object is fixed, making reasoning about code easier. You know an object won't unexpectedly change beneath your feet.
              * **Referential Transparency:** A function given an immutable object will always produce the same output for the same input, making debugging and testing simpler.
              * **Easier Caching:** Immutable objects are excellent candidates for caching because their hash code (for value types) won't change.
          * **How Records Help:**
              * **`init` Accessors:** By default, properties in records use `init` accessors, meaning they can only be set during object initialization (via constructor or object initializer) and are immutable thereafter. This is a compiler-enforced guarantee.
              * **Concise Syntax:** Records make defining these immutable types very succinct, especially positional records, reducing boilerplate.
              * **`with` Expressions:** Provide the mechanism for "non-destructive mutation," which is key to working with immutable data. Instead of modifying an object, you create a new, modified copy, preserving the original.

2.  **Domain-Driven Design (DDD) Patterns:**

      * **Question:** "How do records fit into Domain-Driven Design (DDD), especially for Value Objects?"
      * **Answer:**
          * **Value Objects:** Records are an *ideal* fit for **Value Objects** in DDD.

              * **Definition:** Value Objects are immutable objects that derive their identity from their properties (their value), not from a unique identifier. Examples: `Address`, `Money`, `Coordinates`, `ProductName`.
              * **Record Alignment:**
                  * **Value Equality:** Records inherently support value equality, meaning two record instances are considered equal if all their public property values are equal. This is the defining characteristic of Value Objects.
                  * **Immutability:** As discussed, records promote immutability, which is a key trait of Value Objects (their value doesn't change).
                  * **Conciseness:** Records allow you to define Value Objects with minimal code, reducing boilerplate.
                  * **`with` Expressions:** When a Value Object needs to be "changed" (e.g., an address is updated), `with` expressions allow you to easily create a new instance with the updated value, consistent with the immutability principle.

          * **Entities:** While less common, records *can* be used for **Entities** (objects with a distinct identity, usually a unique ID, that can change over time). However, you'd typically need to explicitly define mutable properties (e.g., `set` accessors) or choose a `class` if mutation is frequent and simple `with` expressions don't suffice. For entities, referential equality often matters more.

3.  **`record class` vs. `record struct`:**

      * **Question:** "When would you choose a `record struct` over a `record class`?"
      * **Answer:**
          * **`record struct`:** Choose when you need a small, immutable, value-type data carrier. Think of them as enhanced primitive types.
              * **Benefits:** Avoids heap allocations, potentially improving performance in scenarios with many small objects.
              * **Considerations:** Copying behavior (assigning a `record struct` creates a copy), and they don't support inheritance (like all structs).
              * **Use Cases:** `Point`, `Size`, `Money`, `RGBColor`.
          * **`record class`:** The default `record` behavior. Choose for larger data models, DTOs, or domain objects where you primarily care about value equality and immutability but don't strictly need value-type semantics (heap allocation is fine). They support inheritance.
              * **Use Cases:** `Person`, `Product`, `OrderHeader`.

4.  **Benefits of `with` expressions:**

      * **Question:** "Explain 'non-destructive mutation' and why `with` expressions are important for it."
      * **Answer:** Non-destructive mutation means that when you "change" an object, you don't modify the original instance. Instead, you create a *new* instance that incorporates the desired changes, leaving the original object in its immutable state. `with` expressions are the idiomatic C\# syntax for this. They allow you to succinctly specify which properties to change, and the compiler handles copying all other properties from the original instance to the new one. This pattern is fundamental for maintaining immutability.

By understanding these aspects, you can confidently discuss and apply records and `with` expressions to design clean, predictable, and robust data models in your C\# applications.