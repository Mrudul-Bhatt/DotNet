## What is an expression-bodied member in C\#? Give examples.

An **expression-bodied member** in C\# is a shorthand syntax that allows you to define methods, properties, constructors, finalizers, and indexers with a concise, single-expression body. Instead of using a traditional block body (`{ ... }`), you use a **fat arrow (`=>`)** followed by the single expression. This syntax is primarily for making code more readable and compact when the member's logic fits on one line.

**General Structure:**

```csharp
ReturnType MemberName(parameters) => expression;
```

**Examples:**

1.  **Expression-bodied Methods:**

      * For methods that return a value, the expression must evaluate to the return type.
      * For `void` methods, the expression must be a statement expression (e.g., a method call).

    <!-- end list -->

    ```csharp
    public class Calculator
    {
        // Traditional method
        public int AddTraditional(int a, int b)
        {
            return a + b;
        }

        // Expression-bodied method (returns a value)
        public int Add(int a, int b) => a + b;

        // Expression-bodied void method (statement expression)
        public void PrintMessage(string message) => Console.WriteLine(message);
    }
    ```

2.  **Expression-bodied Read-Only Properties:**

      * The expression is evaluated every time the property is accessed.

    <!-- end list -->

    ```csharp
    public class Person
    {
        public string FirstName { get; set; }
        public string LastName { get; set; }

        // Expression-bodied read-only property
        public string FullName => $"{FirstName} {LastName}";
    }
    ```

3.  **Expression-bodied Read/Write Properties (from C\# 7.0):**

      * Requires a `get` accessor with an expression body and an optional `set` accessor with an expression body (using `value` keyword for the setter).

    <!-- end list -->

    ```csharp
    public class Product
    {
        private decimal _price;

        public decimal Price
        {
            get => _price; // Expression-bodied getter
            set => _price = value >= 0 ? value : 0; // Expression-bodied setter with validation
        }
    }
    ```

4.  **Expression-bodied Indexers:**

    ```csharp
    public class MyCollection<T>
    {
        private List<T> _items = new List<T>();

        // Expression-bodied indexer
        public T this[int index]
        {
            get => _items[index];
            set => _items[index] = value;
        }
        public int Count => _items.Count;
        public void Add(T item) => _items.Add(item);
    }
    ```

Expression-bodied members make the code more compact and can improve readability for simple logic, but they should be used judiciously to avoid creating overly dense or complex one-liners.

-----

## What does target-typed `new()` mean? When was it introduced?

**Target-typed `new()`** is a C\# 9.0 feature that allows you to omit the type name in the `new` expression when the type can be inferred from the context (the "target" of the assignment or operation).

**Traditional `new` expression:**

```csharp
List<string> names = new List<string>(); // Type repeated: List<string>
Dictionary<string, int> ages = new Dictionary<string, int>(); // Type repeated
Person p = new Person("Alice"); // Type repeated
```

**Target-typed `new()` syntax:**

```csharp
List<string> names = new(); // Compiler infers List<string>
Dictionary<string, int> ages = new(); // Compiler infers Dictionary<string, int>
Person p = new("Alice"); // Compiler infers Person (constructor argument types help too)
```

**Key benefits:**

  * **Conciseness:** Reduces boilerplate and makes the code shorter and easier to read, especially with complex generic types.
  * **Readability:** The type is often obvious from the variable declaration, so repeating it on the right-hand side is redundant.

**When was it introduced?**

Target-typed `new()` was introduced in **C\# 9.0**.

**Where you can use it:**

  * Variable declarations and assignments (as shown above).
  * Field and property initializers:
    ```csharp
    public class MyContainer
    {
        public List<string> Items { get; set; } = new(); // Inferred List<string>
    }
    ```
  * Return statements:
    ```csharp
    public List<string> GetDefaultNames() => new(); // Inferred List<string>
    ```
  * Arguments to method calls:
    ```csharp
    void ProcessList(List<int> numbers) { /* ... */ }
    ProcessList(new() { 1, 2, 3 }); // Inferred List<int>
    ```

**Limitations:**

  * It can only be used when the type can be clearly inferred from the target context. If the compiler cannot determine the type unambiguously, you must use the full `new Type()` syntax.
  * Cannot be used for `var` declarations (as `var` itself infers the type, there's no "target" type for `new()` to infer from).
      * `var p = new();` // Error

-----

## Can you use expression-bodied members for constructors or destructors?

**Yes, you can use expression-bodied members for constructors and finalizers (which are similar to destructors in C\#).**

This capability was introduced in **C\# 7.0**.

### Expression-bodied Constructors:

  * Used for constructors that perform a single, concise action, typically just calling another constructor in the same class (constructor chaining) or performing a single assignment.

    ```csharp
    public class Logger
    {
        private readonly string _logFilePath;

        // Traditional constructor
        public Logger(string path)
        {
            _logFilePath = path;
        }

        // Expression-bodied constructor
        public Logger(string path, bool append) => _logFilePath = path; // More complex logic might still prefer a block
    }

    public class PersonWithCtor
    {
        public string Name { get; }
        public int Age { get; }

        // Expression-bodied constructor for constructor chaining
        public PersonWithCtor(string name) : this(name, 0) { }

        public PersonWithCtor(string name, int age) => (Name, Age) = (name, age); // Common for tuple deconstruction assignment
    }
    ```

### Expression-bodied Finalizers (Destructors):

  * Finalizers (declared with `~ClassName()`) are used for cleaning up unmanaged resources. An expression-bodied finalizer implies a single cleanup operation.

    ```csharp
    using System;
    using System.Runtime.InteropServices;

    public class UnmanagedResourceWrapper
    {
        private IntPtr _unmanagedBuffer; // Represents an unmanaged resource

        public UnmanagedResourceWrapper()
        {
            _unmanagedBuffer = Marshal.AllocHGlobal(100);
            Console.WriteLine("Unmanaged buffer allocated.");
        }

        // Expression-bodied finalizer
        ~UnmanagedResourceWrapper() => Marshal.FreeHGlobal(_unmanagedBuffer);
    }
    ```

While technically supported, expression-bodied finalizers are less common in practice, as finalizer logic often requires more complex `if (disposed)` checks and adherence to the full dispose pattern, which typically benefits from a block body for clarity and robustness.