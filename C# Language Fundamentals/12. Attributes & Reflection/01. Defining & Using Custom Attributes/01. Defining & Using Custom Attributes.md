Today, July 14, 2025, let's explore **Custom Attributes** in C\#. Custom attributes are a powerful feature that allows you to attach metadata to various elements in your code, such as classes, methods, properties, fields, and even assemblies. This metadata can then be queried at runtime using Reflection, enabling you to build highly flexible and metadata-driven logic.

-----

### Defining & Using Custom Attributes

**Focus:** Attaching metadata to types, methods, parameters, etc.

Attributes are essentially classes that inherit from `System.Attribute`. They provide a declarative way to add information to your code that doesn't affect its direct execution but can be read and acted upon by other parts of your application or by frameworks.

#### 1\. Creating Attributes with Optional and Required Parameters

Custom attributes are defined as classes that derive, directly or indirectly, from `System.Attribute`. By convention, their names end with "Attribute". When you apply an attribute, you can omit the "Attribute" suffix (e.g., `[MyValidation]` instead of `[MyValidationAttribute]`).

  * **Required Parameters:** These are defined as constructor parameters of your custom attribute class. When the attribute is applied, these parameters **must** be provided.
  * **Optional Parameters:** These are defined as public properties of your custom attribute class. They must have a public setter. When the attribute is applied, these parameters are optional and can be set using named arguments (e.g., `[MyAttribute(RequiredParam = "value", OptionalParam = "anotherValue")]`).

**Code Example:**

```csharp
using System;

// Define a custom attribute for tracking authors and their review status
// This attribute has a required parameter (AuthorName) and an optional parameter (IsReviewed)
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true)] // This attribute can be applied to classes and methods, and multiple times
public class AuthorInfoAttribute : Attribute
{
    public string AuthorName { get; } // Required parameter - set via constructor

    public bool IsReviewed { get; set; } // Optional parameter - set via public property

    public int LinesOfCode { get; set; } // Another optional parameter

    public AuthorInfoAttribute(string authorName)
    {
        if (string.IsNullOrWhiteSpace(authorName))
        {
            throw new ArgumentException("Author name cannot be null or empty.", nameof(authorName));
        }
        AuthorName = authorName;
        IsReviewed = false; // Default value for optional parameter
        LinesOfCode = 0;
    }
}

// Define another custom attribute for marking code as experimental
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, Inherited = false)] // Can be applied to classes/methods, but not inherited by derived types
public class ExperimentalFeatureAttribute : Attribute
{
    public string Reason { get; } // Required parameter

    public ExperimentalFeatureAttribute(string reason)
    {
        if (string.IsNullOrWhiteSpace(reason))
        {
            throw new ArgumentException("Reason for experimental feature cannot be null or empty.", nameof(reason));
        }
        Reason = reason;
    }
}

// Applying the custom attributes
[AuthorInfo("Alice Smith", IsReviewed = true, LinesOfCode = 250)]
[AuthorInfo("Bob Johnson")] // Alice reviewed, Bob's code is pending review
[ExperimentalFeature("This feature is still under development and may change.")]
public class OrderProcessor
{
    // Author attribute applied to a method
    [AuthorInfo("Charlie Brown", IsReviewed = true)]
    public void ProcessOrder(int orderId)
    {
        Console.WriteLine($"Processing order {orderId}...");
    }

    [AuthorInfo("David Lee")]
    [ExperimentalFeature("Authentication is pending implementation.")]
    public void AuthenticateUser(string username, string password)
    {
        Console.WriteLine($"Authenticating user {username}...");
    }
}

public class ShippingService
{
    [AuthorInfo("Emily White")]
    public void ShipOrder(int orderId)
    {
        Console.WriteLine($"Shipping order {orderId}...");
    }
}

// This class inherits from OrderProcessor.
// Since ExperimentalFeatureAttribute has Inherited = false, it won't apply here.
// AuthorInfoAttribute has AllowMultiple = true, so it could be re-applied.
[AuthorInfo("Frank Green")] // Adding a new author info for the derived class
public class AdvancedOrderProcessor : OrderProcessor
{
    [AuthorInfo("Grace Hopper", IsReviewed = true)]
    public void ProcessInternationalOrder(int orderId, string country)
    {
        Console.WriteLine($"Processing international order {orderId} for {country}...");
    }
}
```

#### 2\. Using `[AttributeUsage]`, `AllowMultiple`, `Inherited`

The `[AttributeUsage]` attribute is applied to your custom attribute class itself to control how your attribute can be used.

  * **`AttributeTargets`**: A flag enum (`enum`) that specifies the program elements on which the attribute can be applied. You can combine multiple targets using the `|` (bitwise OR) operator.
      * Examples: `Assembly`, `Module`, `Class`, `Struct`, `Enum`, `Constructor`, `Method`, `Property`, `Field`, `Event`, `Interface`, `Parameter`, `Delegate`, `ReturnValue`, `GenericParameter`.
      * `All` includes all possible targets.
  * **`AllowMultiple` (Boolean, Optional, default `false`):**
      * If `true`, the attribute can be applied more than once to the same target.
      * If `false` (default), applying the attribute multiple times to the same target will result in a compile-time error.
  * **`Inherited` (Boolean, Optional, default `true`):**
      * If `true` (default), the attribute is inherited by derived classes and overridden members. This means if you apply an attribute to a base class, a derived class will also be considered to have that attribute (unless overridden with `false`).
      * If `false`, the attribute is not inherited by derived types or overridden members.

In the example above:

  * `AuthorInfoAttribute` uses `AllowMultiple = true` (an element can have multiple authors).
  * `ExperimentalFeatureAttribute` uses `Inherited = false` (an experimental tag on a base class shouldn't necessarily apply to a derived class unless explicitly re-applied).

-----

### Interview Focus: How and why to create metadata-driven logic

The real power of custom attributes comes from their ability to be queried at runtime using **Reflection**. This allows you to build "metadata-driven" or "convention-over-configuration" logic, where your code's behavior is determined by the attributes applied to it, rather than hardcoded logic or configuration files.

**Why create metadata-driven logic?**

1.  **Separation of Concerns:** Attributes allow you to separate concerns. Business logic or framework behavior can be cleanly separated from the domain model or core application code. The attributes declaratively describe how the core code should be treated by the surrounding framework.
      * *Example:* A `[ValidateNotNull]` attribute on a property separates validation rules from the property's getter/setter.
2.  **Reduced Boilerplate/Repetition (DRY):** Instead of writing repetitive `if`/`switch` statements for different types/members, you can define a generic piece of logic that inspects attributes.
      * *Example:* A single piece of code that finds all methods marked with `[Cacheable]` and applies caching logic, rather than manual caching for each method.
3.  **Extensibility and Plug-in Architectures:** New behaviors or features can be added by simply defining new attributes and a corresponding runtime processor, without modifying existing classes.
      * *Example:* A plugin system where plugins are discovered by looking for assemblies with a specific `[Plugin]` attribute.
4.  **Readability and Clarity:** Attributes provide a concise and highly visible way to mark code with specific meanings or instructions.
      * *Example:* `[Obsolete("Use NewMethod instead")]` clearly indicates that a method should no longer be used.
5.  **Runtime Adaptability:** The application can dynamically adapt its behavior based on the metadata discovered at runtime.

**How to create metadata-driven logic (using Reflection):**

1.  **Define your custom attribute(s).**
2.  **Apply the attributes** to the relevant code elements.
3.  **At runtime, use Reflection** to:
      * Get `Type` objects for classes.
      * Get `MethodInfo`, `PropertyInfo`, `FieldInfo`, etc., for members.
      * Call `GetCustomAttributes()` method (e.g., `type.GetCustomAttributes(typeof(MyAttribute), inherit: true)`).
      * Inspect the retrieved attribute instances to drive your logic.

**Code Example (Metadata-Driven Logic - `AuthorInfoChecker`):**

```csharp
using System;
using System.Linq;
using System.Reflection; // Essential for Reflection

public static class MetadataProcessor
{
    public static void ProcessAuthorsAndExperimentalFeatures(Assembly assembly)
    {
        Console.WriteLine("\n--- Processing Metadata ---");

        // Iterate through all types (classes) in the assembly
        foreach (Type type in assembly.GetTypes())
        {
            // Check for AuthorInfoAttribute on the class itself
            AuthorInfoAttribute[] classAuthorAttrs = type.GetCustomAttributes<AuthorInfoAttribute>().ToArray();
            if (classAuthorAttrs.Any())
            {
                Console.WriteLine($"\nClass: {type.Name}");
                foreach (var attr in classAuthorAttrs)
                {
                    Console.WriteLine($"  Author: {attr.AuthorName}, Reviewed: {attr.IsReviewed}, LOC: {attr.LinesOfCode}");
                }
            }

            // Check for ExperimentalFeatureAttribute on the class itself
            ExperimentalFeatureAttribute classExperimentalAttr = type.GetCustomAttribute<ExperimentalFeatureAttribute>();
            if (classExperimentalAttr != null)
            {
                Console.WriteLine($"  [CLASS] Experimental Feature: {classExperimentalAttr.Reason}");
            }

            // Iterate through methods of the class
            foreach (MethodInfo method in type.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))
            {
                // Check for AuthorInfoAttribute on methods
                AuthorInfoAttribute[] methodAuthorAttrs = method.GetCustomAttributes<AuthorInfoAttribute>().ToArray();
                if (methodAuthorAttrs.Any())
                {
                    Console.WriteLine($"  Method: {method.Name}");
                    foreach (var attr in methodAuthorAttrs)
                    {
                        Console.WriteLine($"    Author: {attr.AuthorName}, Reviewed: {attr.IsReviewed}");
                    }
                }

                // Check for ExperimentalFeatureAttribute on methods
                ExperimentalFeatureAttribute methodExperimentalAttr = method.GetCustomAttribute<ExperimentalFeatureAttribute>();
                if (methodExperimentalAttr != null)
                {
                    Console.WriteLine($"    [METHOD] Experimental Feature: {methodExperimentalAttr.Reason}");
                }
            }
        }
        Console.WriteLine("--- End Processing Metadata ---");
    }

    // A simple method to simulate running the application
    public static void SimulateApplicationRun()
    {
        Console.WriteLine("\n--- Simulating Application Run ---");
        OrderProcessor op = new OrderProcessor();
        op.ProcessOrder(123);
        op.AuthenticateUser("testuser", "password");

        ShippingService ss = new ShippingService();
        ss.ShipOrder(456);

        AdvancedOrderProcessor aop = new AdvancedOrderProcessor();
        aop.ProcessOrder(789); // Base method call
        aop.ProcessInternationalOrder(1011, "Germany"); // Derived method call
        Console.WriteLine("--- End Simulation ---");
    }

    public static void Main(string[] args)
    {
        // Call the metadata processor to inspect attributes in the current assembly
        ProcessAuthorsAndExperimentalFeatures(Assembly.GetExecutingAssembly());

        // Simulate the actual application running
        SimulateApplicationRun();
    }
}
```

**Output Explanation from the Example:**

When you run `MetadataProcessor.Main()`, you'll see output like this (abbreviated):

```
--- Processing Metadata ---

Class: OrderProcessor
  Author: Alice Smith, Reviewed: True, LOC: 250
  Author: Bob Johnson, Reviewed: False, LOC: 0
  [CLASS] Experimental Feature: This feature is still under development and may change.
  Method: ProcessOrder
    Author: Charlie Brown, Reviewed: True
  Method: AuthenticateUser
    Author: David Lee, Reviewed: False
    [METHOD] Experimental Feature: Authentication is pending implementation.

Class: ShippingService
  Method: ShipOrder
    Author: Emily White, Reviewed: False

Class: AdvancedOrderProcessor
  Author: Frank Green, Reviewed: False, LOC: 0
  Method: ProcessInternationalOrder
    Author: Grace Hopper, Reviewed: True
--- End Processing Metadata ---

--- Simulating Application Run ---
Processing order 123...
Authenticating user testuser...
Shipping order 456...
Processing order 789...
Processing international order 1011 for Germany...
--- End Simulation ---
```

**Key takeaways from the output:**

  * **`OrderProcessor`**: Both `AuthorInfo` attributes (multiple allowed) and the `ExperimentalFeature` attribute applied to the class are found. For `ProcessOrder` and `AuthenticateUser`, their respective `AuthorInfo` attributes are found. `AuthenticateUser` also has its own `ExperimentalFeature` attribute.
  * **`ShippingService`**: Only the `AuthorInfo` attribute on its `ShipOrder` method is found.
  * **`AdvancedOrderProcessor`**:
      * It has its own `AuthorInfo` attribute (`Frank Green`).
      * Crucially, the `[ExperimentalFeature]` attribute from `OrderProcessor` is **NOT** inherited because we set `Inherited = false` on `ExperimentalFeatureAttribute`.
      * The `ProcessInternationalOrder` method has its `AuthorInfo` attribute (`Grace Hopper`).
      * Notice that `ProcessOrder` is listed as a method of `OrderProcessor` but not *explicitly* `AdvancedOrderProcessor` by `GetMethods(BindingFlags.DeclaredOnly)`. If we used `GetMethods()` without `DeclaredOnly`, it would show inherited methods too. This highlights the precise control Reflection offers.

This demonstrates how you can programmatically inspect your code's metadata and build logic around it. This pattern is fundamental to many frameworks, including ASP.NET Core (e.g., routing, authorization attributes), Entity Framework Core (annotations for mapping), validation libraries, and more.