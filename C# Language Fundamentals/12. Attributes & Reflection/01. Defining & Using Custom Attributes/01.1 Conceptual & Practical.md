## What is an Attribute in C\#, and why would you use a custom one?

An **attribute** in C\# is a special kind of class that allows you to add **declarative information (metadata)** to your code. Think of them as tags or annotations that you can apply to various code elements like classes, methods, properties, fields, events, or even assemblies. This metadata doesn't directly change the code's execution logic but can be read at compile-time or runtime by other tools, frameworks, or the .NET runtime itself.

You'd use a **custom attribute** when you need to:

1.  **Convey Domain-Specific Information:** Built-in attributes cover common scenarios (like `[Obsolete]`, `[Serializable]`, `[DllImport]`), but you often need to attach information relevant to *your specific application's logic or business rules*. For example, `[LoggingEnabled]`, `[RequiresPermission("Admin")]`, `[EntityVersion(1.2)]`.
2.  **Influence Runtime Behavior:** Custom attributes can be read using **reflection** at runtime. Your application's logic can then adapt its behavior based on the presence or properties of these attributes. This is a powerful way to implement **aspect-oriented programming (AOP)** or convention-over-configuration patterns.
3.  **Integrate with Tools/Frameworks:** Many frameworks (e.g., ORMs, validation frameworks, UI frameworks, testing frameworks like NUnit/xUnit) heavily rely on attributes to configure behavior without writing boilerplate code. Custom attributes allow you to extend this mechanism for your own tools or internal frameworks.
4.  **Improve Readability and Maintainability:** By using declarative attributes, you can reduce boilerplate code and make the intent of your code clearer. Instead of complex `if/else` logic, a simple attribute can indicate a particular behavior.

Essentially, custom attributes enable you to embed metadata directly into your code elements, which can then be interpreted by other parts of your system, providing flexibility, extensibility, and cleaner design.

-----

## How do you define a custom attribute, and what must it inherit from?

To define a custom attribute in C\#, it **must inherit from `System.Attribute`**. By convention, the class name of an attribute should end with "Attribute" (though you can omit "Attribute" when applying it, e.g., `[MyCustom]` instead of `[MyCustomAttribute]`).

Here's how you define one, including key elements:

```csharp
using System; // Essential for System.Attribute and AttributeUsage

// 1. Mark the class with [AttributeUsage] to control its applicability
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
public class MyCustomAttribute : Attribute // 2. Must inherit from System.Attribute
{
    // 3. Positional Parameters (via constructor arguments)
    public string RequiredDescription { get; }

    // 4. Named Parameters (via public properties)
    public int Version { get; set; }
    public bool IsExperimental { get; set; }

    // Constructor for positional parameters
    public MyCustomAttribute(string requiredDescription)
    {
        RequiredDescription = requiredDescription;
        // Provide default values for named parameters
        Version = 1;
        IsExperimental = false;
    }

    // You can have multiple constructors if you want different sets of positional parameters
    public MyCustomAttribute(string requiredDescription, int version)
        : this(requiredDescription) // Call base constructor
    {
        Version = version;
    }
}
```

**Key components:**

1.  **Inheritance from `System.Attribute`**: This is mandatory. It's the base class for all custom attributes.
2.  **`[AttributeUsage]` Attribute (Recommended):** Applied to your custom attribute class itself, this built-in attribute defines *where* your custom attribute can be applied (e.g., classes, methods, properties), whether it can be applied multiple times to the same target (`AllowMultiple`), and whether it's inherited by derived classes (`Inherited`).
3.  **Constructors for Positional Parameters:**
      * Arguments passed to the attribute's constructor when applied (e.g., `[MyCustom("This is required")]`).
      * These arguments must be compile-time constants (e.g., primitive types, `string`, `typeof()`, enums, or arrays of these types).
      * They typically map to read-only properties of the attribute.
4.  **Public Read/Write Properties for Named Parameters:**
      * Properties that can be set using `Name = value` syntax when applying the attribute (e.g., `[MyCustom("Desc", Version = 2, IsExperimental = true)]`).
      * These properties must have public setters.
      * Like positional parameters, their types must be compile-time constants.

**Applying the Custom Attribute:**

```csharp
// Applying the custom attribute
[MyCustom("This is a critical class.", Version = 2, IsExperimental = false)]
public class MyService
{
    [MyCustom("This is a key method.", IsExperimental = true)] // Omitting 'Version' uses default
    public void PerformOperation()
    {
        // ...
    }
}
```

-----

## What is the purpose of `[AttributeUsage]` in custom attributes?

The `[AttributeUsage]` attribute is a **built-in attribute** that you apply to **your custom attribute class** to **control how and where that custom attribute can be used**. It's crucial for defining the rules and constraints for applying your custom metadata.

Its purpose is to specify:

1.  **`AttributeTargets` (Where it can be applied):**

      * This enumeration determines the specific program elements to which your custom attribute can be applied. You can combine multiple `AttributeTargets` using the bitwise OR (`|`) operator.
      * **Examples:**
          * `AttributeTargets.Class`: Only on classes.
          * `AttributeTargets.Method`: Only on methods.
          * `AttributeTargets.Property`: Only on properties.
          * `AttributeTargets.Field`: Only on fields.
          * `AttributeTargets.Interface`: Only on interfaces.
          * `AttributeTargets.Enum`: Only on enumerations.
          * `AttributeTargets.Assembly`: Only on the entire assembly.
          * `AttributeTargets.All`: Can be applied to any target (default if `AttributeUsage` is not specified).
      * If you try to apply an attribute to a target not specified by `AttributeTargets`, the compiler will issue an error.

2.  **`AllowMultiple` (Repeatability):**

      * A boolean value that specifies whether multiple instances of your custom attribute can be applied to the **same target** code element.
      * `AllowMultiple = false` (default): Only one instance of the attribute can be applied to a given target. (e.g., `[MyCustom("A")]` is allowed, but `[MyCustom("A"), MyCustom("B")]` on the same method is not).
      * `AllowMultiple = true`: Multiple instances of the attribute can be applied to the same target. This is useful for attributes that represent a collection of items or distinct properties. (e.g., `[Permission("Read"), Permission("Write")]`).

3.  **`Inherited` (Inheritance Behavior):**

      * A boolean value that specifies whether the custom attribute, when applied to a base class or interface, is **inherited by derived classes or implementing types**.
      * `Inherited = false` (default): The attribute is not automatically applied to derived classes.
      * `Inherited = true`: If the attribute is applied to a base class, derived classes will automatically "have" that attribute unless explicitly overridden or removed. This applies to methods and properties in an inheritance hierarchy too.

**Example Revisited:**

```csharp
[AttributeUsage(
    AttributeTargets.Class | AttributeTargets.Method, // Can be applied to classes or methods
    AllowMultiple = false,                             // Only one instance per class/method
    Inherited = false                                  // Not inherited by derived classes/overrides
)]
public class MyCustomAttribute : Attribute
{
    public string RequiredDescription { get; }
    public int Version { get; set; }
    public MyCustomAttribute(string requiredDescription)
    {
        RequiredDescription = requiredDescription;
    }
}
```

If `Inherited` was `true`, a class inheriting from `MyService` would also implicitly have `MyCustomAttribute` applied, unless a different `MyCustomAttribute` was explicitly applied to the derived class (depending on `AllowMultiple` behavior and attribute logic).

By carefully setting `AttributeUsage`, you define a clear contract for how your custom attributes should be used, helping to ensure consistent and correct application of metadata throughout your codebase.