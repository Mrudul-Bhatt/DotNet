Let's delve into these scenarios, focusing on how to design and utilize custom attributes for various purposes, particularly for validation, logging, and providing metadata.

-----

### ðŸ”¹ You want to annotate properties as required for validation. How would you design a custom `[RequiredField]` attribute?

(Create the attribute, apply it to properties, and use reflection to validate them at runtime.)

**Explanation:**

This is a classic use case for custom attributes, commonly seen in frameworks like ASP.NET Core's Model Validation (`[Required]`, `[StringLength]`). The idea is to declare a validation rule directly on the property it applies to, and then have a centralized piece of logic that enforces these rules.

**Design Steps:**

1.  **Define the Custom Attribute:**

      * Create a class that inherits from `System.Attribute`.
      * By convention, name it `RequiredFieldAttribute`.
      * Use `[AttributeUsage(AttributeTargets.Property)]` to restrict its application only to properties.
      * The `[RequiredField]` attribute usually doesn't need any constructor parameters or properties if it's just a simple "required" flag. However, you could add an optional `ErrorMessage` property.

2.  **Apply the Attribute:**

      * Decorate the properties in your model classes or DTOs (Data Transfer Objects) that you want to mark as required.

3.  **Implement Runtime Validation Logic (using Reflection):**

      * Create a validation method or service that takes an object instance as input.
      * Use Reflection (`Type.GetProperties()`, `PropertyInfo.GetCustomAttribute<T>()`) to iterate through the object's properties.
      * For each property, check if it has the `[RequiredField]` attribute applied.
      * If it does, check the property's value. If the value is `null`, an empty string, or a default value for value types, then it's invalid.
      * Collect validation errors and return them.

**Code Example:**

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection; // For Reflection

// 1. Define the Custom [RequiredField] Attribute
[AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = true)]
public class RequiredFieldAttribute : Attribute
{
    public string ErrorMessage { get; set; } // Optional: Custom error message

    public RequiredFieldAttribute()
    {
        ErrorMessage = "This field is required.";
    }

    public RequiredFieldAttribute(string errorMessage)
    {
        ErrorMessage = errorMessage;
    }
}

// Model/DTO class
public class UserRegistration
{
    [RequiredField(ErrorMessage = "Username is mandatory.")]
    public string Username { get; set; }

    [RequiredField] // Uses default error message
    public string Password { get; set; }

    public string Email { get; set; } // Not required

    [RequiredField(ErrorMessage = "Age must be provided.")]
    public int Age { get; set; } // For value types, default (0) can be treated as 'not provided'
}

// 2. Runtime Validation Logic
public static class Validator
{
    public static List<string> Validate(object instance)
    {
        List<string> errors = new List<string>();
        if (instance == null)
        {
            errors.Add("Instance to validate cannot be null.");
            return errors;
        }

        Type type = instance.GetType();
        PropertyInfo[] properties = type.GetProperties(); // Get all public properties

        foreach (PropertyInfo property in properties)
        {
            // Check if the property has the RequiredFieldAttribute
            RequiredFieldAttribute requiredAttr = property.GetCustomAttribute<RequiredFieldAttribute>();
            if (requiredAttr != null)
            {
                object value = property.GetValue(instance);

                bool isInvalid = false;

                if (value == null)
                {
                    isInvalid = true;
                }
                else if (value is string strValue)
                {
                    if (string.IsNullOrWhiteSpace(strValue))
                    {
                        isInvalid = true;
                    }
                }
                else if (property.PropertyType.IsValueType &&
                         value.Equals(Activator.CreateInstance(property.PropertyType)))
                {
                    // For value types (like int, DateTime), check if it's the default value
                    isInvalid = true;
                }

                if (isInvalid)
                {
                    errors.Add($"{property.Name}: {requiredAttr.ErrorMessage}");
                }
            }
        }
        return errors;
    }
}

public static class RequiredFieldExample
{
    public static void Run()
    {
        Console.WriteLine("--- Custom RequiredField Attribute Example ---");

        // Case 1: Valid user
        Console.WriteLine("\nValid User:");
        UserRegistration validUser = new UserRegistration
        {
            Username = "john.doe",
            Password = "SecurePassword123",
            Email = "john@example.com",
            Age = 30
        };
        List<string> validErrors = Validator.Validate(validUser);
        if (validErrors.Any())
        {
            Console.WriteLine("Validation Errors:");
            validErrors.ForEach(Console.WriteLine);
        }
        else
        {
            Console.WriteLine("Validation successful! No errors.");
        }

        // Case 2: Invalid user (missing required fields)
        Console.WriteLine("\nInvalid User:");
        UserRegistration invalidUser = new UserRegistration
        {
            Username = "", // Empty username
            Email = "jane@example.com",
            Age = 0 // Default for int, treated as not provided
        };
        List<string> invalidErrors = Validator.Validate(invalidUser);
        if (invalidErrors.Any())
        {
            Console.WriteLine("Validation Errors:");
            invalidErrors.ForEach(Console.WriteLine);
        }
        else
        {
            Console.WriteLine("Validation successful! No errors.");
        }

        Console.WriteLine("--- End Custom RequiredField Attribute Example ---");
    }
}
```

-----

### ðŸ”¹ You created a `[Log]` attribute to track method calls. How can you enforce logging behavior dynamically?

(Use reflection + `MethodInfo` to check for `[Log]` and inject logging in a wrapper or interceptor method.)

**Explanation:**

To enforce logging behavior dynamically using a `[Log]` attribute, you need a mechanism that intercepts method calls and checks for the presence of the attribute. This is a common pattern in **Aspect-Oriented Programming (AOP)**.

**Techniques to Enforce Dynamically:**

1.  **Wrapper/Proxy Pattern (Manual Reflection):**

      * You create a wrapper method or a dynamic proxy that surrounds the actual method call.
      * Before or after invoking the target method, the wrapper uses Reflection (`MethodInfo.GetCustomAttribute<LogAttribute>()`) to see if the `[Log]` attribute is present.
      * If found, it executes the logging logic.

2.  **Dynamic Proxy Libraries (e.g., Castle.Core.DynamicProxy):**

      * For more complex AOP scenarios, libraries like Castle DynamicProxy can generate proxies at runtime that intercept method calls on interfaces or virtual methods. You define an "interceptor" class that gets invoked whenever a method is called on the proxied object. Inside the interceptor, you can check for your `[Log]` attribute.

3.  **Post-Compilation Weaving (e.g., AspectFody):**

      * Tools like Fody can inject code directly into your compiled assemblies during the build process. This is the most powerful but also most intrusive method, as it directly modifies IL. You define the aspect (e.g., logging) and the weaver injects it.

**Code Example (Manual Reflection with Wrapper):**

```csharp
using System;
using System.Linq;
using System.Reflection; // For Reflection

// 1. Define the [Log] Attribute
[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = true)]
public class LogAttribute : Attribute
{
    public string MessagePrefix { get; set; } = "Method Call";
}

// Class with methods to be logged
public class Calculator
{
    [Log(MessagePrefix = "Calc")]
    public int Add(int a, int b)
    {
        return a + b;
    }

    public int Subtract(int a, int b) // No Log attribute
    {
        return a - b;
    }

    [Log] // Uses default prefix
    public int Multiply(int a, int b)
    {
        return a * b;
    }
}

// 2. Dynamic Logging Enforcer (Wrapper/Interceptor Logic)
public static class MethodLogger
{
    public static T CreateLoggedInstance<T>(T instance) where T : class
    {
        // This is a simplified manual proxy approach.
        // For real-world, consider DynamicProxy or similar.
        // This example only works for directly called methods, not those invoked via interface dispatch
        // if T is an interface and the instance is a concrete class.

        // Get all public methods of the instance's type
        MethodInfo[] methods = typeof(T).GetMethods(BindingFlags.Public | BindingFlags.Instance);

        Console.WriteLine($"\n--- Creating Logged Instance for {typeof(T).Name} ---");

        return (T)new LoggingProxy<T>(instance).GetTransparentProxy();
    }
}

// A bare-bones, oversimplified dynamic proxy concept (not runnable as-is, requires RealProxy for actual interception)
// This is more to illustrate the *idea* of wrapping/intercepting.
// For a working solution, you'd use System.Runtime.Remoting.Proxies.RealProxy or a library like Castle.Core.DynamicProxy.
public class LoggingProxy<T> : RealProxy where T : class
{
    private readonly T _target;

    public LoggingProxy(T target) : base(typeof(T))
    {
        _target = target;
    }

    public override IMessage Invoke(IMessage msg)
    {
        IMethodCallMessage call = msg as IMethodCallMessage;
        MethodInfo method = call.MethodBase as MethodInfo;

        if (method != null)
        {
            LogAttribute logAttr = method.GetCustomAttribute<LogAttribute>();
            if (logAttr != null)
            {
                Console.WriteLine($"[{logAttr.MessagePrefix}] Entering method: {method.Name} with args: {string.Join(", ", call.Args)}");
            }

            object returnValue = method.Invoke(_target, call.Args);

            if (logAttr != null)
            {
                Console.WriteLine($"[{logAttr.MessagePrefix}] Exiting method: {method.Name}. Return value: {returnValue}");
            }
            return new ReturnMessage(returnValue, call.Args, call.ArgCount, call.LogicalCallContext, call);
        }
        return null;
    }
}


public static class LogAttributeExample
{
    public static void Run()
    {
        Console.WriteLine("--- Custom Log Attribute Example ---");

        // Without interception, no logging happens
        Console.WriteLine("\n--- Direct Calls (No Logging) ---");
        Calculator calculator = new Calculator();
        calculator.Add(5, 3);
        calculator.Subtract(10, 4);
        calculator.Multiply(2, 6);

        // This is just a conceptual way to illustrate it.
        // Real-world AOP requires a proper proxy framework or build-time weaving.
        // For simple demos, you might modify the Calculator methods to manually check,
        // but that defeats "dynamic enforcement".
        Console.WriteLine("\n--- Simulating Dynamic Logging Enforcement (Conceptual) ---");
        // Imagine 'loggedCalculator' is a proxy where every method call is intercepted
        // This exact line won't work without a full RealProxy/DynamicProxy setup
        // Calculator loggedCalculator = MethodLogger.CreateLoggedInstance(calculator); // This line is conceptual

        // For demonstration, let's just manually process the methods and simulate invocation
        Type calculatorType = typeof(Calculator);
        MethodInfo addMethod = calculatorType.GetMethod(nameof(Calculator.Add));
        MethodInfo subtractMethod = calculatorType.GetMethod(nameof(Calculator.Subtract));
        MethodInfo multiplyMethod = calculatorType.GetMethod(nameof(Calculator.Multiply));

        SimulateInvokeWithLogging(addMethod, calculator, 5, 3);
        SimulateInvokeWithLogging(subtractMethod, calculator, 10, 4);
        SimulateInvokeWithLogging(multiplyMethod, calculator, 2, 6);

        Console.WriteLine("--- End Custom Log Attribute Example ---");
    }

    // This method simulates the interception logic for demonstration purposes
    private static void SimulateInvokeWithLogging(MethodInfo method, object targetInstance, params object[] args)
    {
        LogAttribute logAttr = method.GetCustomAttribute<LogAttribute>();
        if (logAttr != null)
        {
            Console.WriteLine($"[{logAttr.MessagePrefix}] Entering method: {method.Name} with args: {string.Join(", ", args)}");
        }

        object returnValue = method.Invoke(targetInstance, args);

        if (logAttr != null)
        {
            Console.WriteLine($"[{logAttr.MessagePrefix}] Exiting method: {method.Name}. Return value: {returnValue}");
        }
    }
}
```

This example shows the core idea: at runtime, you inspect the method's metadata (`[Log]` attribute) and then execute your logging logic around the actual method invocation. For complex, production-ready AOP, dedicated libraries are highly recommended.

-----

### ðŸ”¹ Whatâ€™s the benefit of using `AllowMultiple = true` in `[AttributeUsage]`, and when would you use it?

(Allows attaching multiple instances of the same attribute â€” useful in tagging with different metadata, like `[Map("A")]`, `[Map("B")]`.)

**Explanation:**

The `AllowMultiple` property in the `[AttributeUsage]` attribute determines whether a custom attribute can be applied more than once to the *same* target element (e.g., the same class, the same method).

  * **`AllowMultiple = false` (Default):** You can apply the attribute only once to a given target. If you try to apply it again, it's a compile-time error.

      * **Use Cases:** Attributes that represent a singular state or configuration, like `[RequiredField]`, `[Obsolete]`, `[Serializable]`, or `[Log]` (if you only ever need one log configuration per method).

  * **`AllowMultiple = true`:** You can apply the attribute multiple times to the same target element. Each application creates a separate instance of the attribute.

      * **Use Cases:** When you need to associate **multiple pieces of distinct, but related, metadata** with a single code element.

**When to Use `AllowMultiple = true` (Examples):**

1.  **Multiple Mappings/Aliases:**

      * `[Map("LegacyName")]`, `[Map("NewName")]`: A property or class might have different names in different systems or versions, and you want to map all of them.
      * `[Route("/products")], [Route("/items")]`: A single controller action might respond to multiple URL routes.
      * `[JsonAlias("prod_id")], [JsonAlias("item_id")]`: A property might be deserialized from different JSON field names.

2.  **Multiple Permissions/Roles:**

      * `[Authorize(Roles = "Admin")]`, `[Authorize(Roles = "Manager")]`: A method requires a user to have *either* the Admin *or* Manager role. (Though `[Authorize]` itself often handles multiple roles in a single instance, this illustrates the conceptual need).

3.  **Multiple Notifications/Subscriptions:**

      * `[NotifyOnEvent("OrderCreated")]`, `[NotifyOnEvent("PaymentReceived")]`: A method should be triggered for different types of events.

4.  **Categorization/Tagging:**

      * `[Tag("FeatureX")], [Tag("BugFixY")]`: Categorizing a method or class with multiple arbitrary tags for reporting or analysis.

**Code Example:**

```csharp
using System;
using System.Reflection;
using System.Linq;

// Custom attribute to map a property to different external field names
[AttributeUsage(AttributeTargets.Property, AllowMultiple = true)] // Allows multiple mappings
public class FieldMapAttribute : Attribute
{
    public string ExternalFieldName { get; }

    public FieldMapAttribute(string externalFieldName)
    {
        if (string.IsNullOrWhiteSpace(externalFieldName))
            throw new ArgumentException("External field name cannot be empty.", nameof(externalFieldName));
        ExternalFieldName = externalFieldName;
    }
}

public class ProductDto
{
    [FieldMap("product_id")]
    [FieldMap("id")] // This property can be mapped from "product_id" or "id"
    public int ProductId { get; set; }

    [FieldMap("item_name")]
    public string Name { get; set; }

    [FieldMap("unit_price")]
    public decimal Price { get; set; }
}

public static class AllowMultipleExample
{
    public static void Run()
    {
        Console.WriteLine("--- AllowMultiple = true Example ---");

        Type dtoType = typeof(ProductDto);

        // Get properties that have the FieldMapAttribute
        foreach (PropertyInfo prop in dtoType.GetProperties())
        {
            // Get all instances of FieldMapAttribute on this property
            FieldMapAttribute[] fieldMaps = prop.GetCustomAttributes<FieldMapAttribute>().ToArray();

            if (fieldMaps.Any())
            {
                Console.WriteLine($"\nProperty: {prop.Name}");
                Console.WriteLine("  Mapped from external fields:");
                foreach (var map in fieldMaps)
                {
                    Console.WriteLine($"    - {map.ExternalFieldName}");
                }
            }
        }
        Console.WriteLine("--- End AllowMultiple = true Example ---");
    }
}
```

In this example, the `ProductId` property can be identified by both "product\_id" and "id" when processing data from an external source, thanks to `AllowMultiple = true`.

-----

### ðŸ”¹ You want to apply a `[Role("Admin")]` attribute on controller actions. How would you access the role info at runtime?

(Use reflection to read method-level attributes via `MethodInfo.GetCustomAttributes()` and extract the role value.)

**Explanation:**

This is a very common pattern in web frameworks like ASP.NET Core for authorization. You declare what roles are required on a specific action method, and then the framework (or your custom middleware/filter) intercepts the request and checks the user's roles against the attribute's information.

**Accessing Role Info at Runtime:**

1.  **Define the Custom `[Role]` Attribute:** It will need a constructor parameter to define the required role.
2.  **Apply the Attribute:** Decorate your controller action methods.
3.  **Use Reflection at Runtime:**
      * You'll typically have access to the `MethodInfo` object representing the currently executing action method (e.g., in an ASP.NET Core filter, this is available).
      * Use `MethodInfo.GetCustomAttribute<RoleAttribute>()` (or `GetCustomAttributes<RoleAttribute>()` if `AllowMultiple` is true) to retrieve the attribute instance(s).
      * Access the `Role` property of the retrieved attribute(s) to get the required role string.
      * Compare this with the current user's roles.

**Code Example:**

```csharp
using System;
using System.Linq;
using System.Reflection;
using System.Security.Claims; // Simulating user roles

// 1. Define the [Role] Attribute
[AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = false)] // Allows multiple roles for OR logic
public class RoleAttribute : Attribute
{
    public string RoleName { get; }

    public RoleAttribute(string roleName)
    {
        if (string.IsNullOrWhiteSpace(roleName))
            throw new ArgumentException("Role name cannot be null or empty.", nameof(roleName));
        RoleName = roleName;
    }
}

// 2. Simulate a Web Controller with Action Methods
public class AdminController
{
    public void ViewDashboard()
    {
        Console.WriteLine("  [Action] Viewing Dashboard.");
    }

    [Role("Admin")] // Requires Admin role
    public void ManageUsers()
    {
        Console.WriteLine("  [Action] Managing Users.");
    }

    [Role("Admin")]
    [Role("SuperUser")] // Requires either Admin OR SuperUser role
    public void DeleteRecords()
    {
        Console.WriteLine("  [Action] Deleting Records.");
    }

    [Role("Analyst")]
    public void GenerateReports()
    {
        Console.WriteLine("  [Action] Generating Reports.");
    }
}

// 3. Runtime Authorization Checker
public static class AuthorizationChecker
{
    public static bool HasAccess(MethodInfo actionMethod, ClaimsPrincipal currentUser)
    {
        Console.WriteLine($"\n--- Checking access for method: {actionMethod.Name} ---");

        // Get all RoleAttributes applied to the method
        RoleAttribute[] requiredRoles = actionMethod.GetCustomAttributes<RoleAttribute>().ToArray();

        // If no RoleAttribute is present, access is granted (no specific role required)
        if (!requiredRoles.Any())
        {
            Console.WriteLine($"  No specific role required for {actionMethod.Name}. Access granted.");
            return true;
        }

        // Check if the current user has ANY of the required roles (OR logic)
        foreach (var roleAttr in requiredRoles)
        {
            Console.WriteLine($"  Required Role: '{roleAttr.RoleName}'");
            if (currentUser.IsInRole(roleAttr.RoleName))
            {
                Console.WriteLine($"  User has role '{roleAttr.RoleName}'. Access granted.");
                return true; // User has at least one required role
            }
        }

        Console.WriteLine($"  User does not have any of the required roles for {actionMethod.Name}. Access denied.");
        return false; // User does not have any of the required roles
    }

    public static void Run()
    {
        Console.WriteLine("--- Role-Based Authorization with Attributes Example ---");

        AdminController controller = new AdminController();
        Type controllerType = typeof(AdminController);

        // Simulate different users
        ClaimsPrincipal adminUser = new ClaimsPrincipal(new ClaimsIdentity(new[] { new Claim(ClaimTypes.Role, "Admin") }, "TestAuth"));
        ClaimsPrincipal superUser = new ClaimsPrincipal(new ClaimsIdentity(new[] { new Claim(ClaimTypes.Role, "SuperUser") }, "TestAuth"));
        ClaimsPrincipal regularUser = new ClaimsPrincipal(new ClaimsIdentity(new[] { new Claim(ClaimTypes.Role, "User") }, "TestAuth"));
        ClaimsPrincipal analystUser = new ClaimsPrincipal(new ClaimsIdentity(new[] { new Claim(ClaimTypes.Role, "Analyst") }, "TestAuth"));


        MethodInfo viewDashboardMethod = controllerType.GetMethod(nameof(AdminController.ViewDashboard));
        MethodInfo manageUsersMethod = controllerType.GetMethod(nameof(AdminController.ManageUsers));
        MethodInfo deleteRecordsMethod = controllerType.GetMethod(nameof(AdminController.DeleteRecords));
        MethodInfo generateReportsMethod = controllerType.GetMethod(nameof(AdminController.GenerateReports));

        // Test cases:
        if (HasAccess(viewDashboardMethod, regularUser)) controller.ViewDashboard();
        if (HasAccess(manageUsersMethod, adminUser)) controller.ManageUsers();
        if (HasAccess(manageUsersMethod, regularUser)) controller.ManageUsers();
        if (HasAccess(deleteRecordsMethod, adminUser)) controller.DeleteRecords();
        if (HasAccess(deleteRecordsMethod, superUser)) controller.DeleteRecords();
        if (HasAccess(deleteRecordsMethod, regularUser)) controller.DeleteRecords();
        if (HasAccess(generateReportsMethod, analystUser)) controller.GenerateReports();
        if (HasAccess(generateReportsMethod, adminUser)) controller.GenerateReports();


        Console.WriteLine("--- End Role-Based Authorization Example ---");
    }
}
```

This example shows how to retrieve all instances of `[Role]` attributes on a method and implement OR logic (user needs *any* of the specified roles). For AND logic (user needs *all* roles), you'd iterate and ensure `currentUser.IsInRole(roleAttr.RoleName)` is true for every `roleAttr`.

-----

### ðŸ”¹ How would you apply a custom attribute to every enum field in a `Status` enum to provide human-readable labels?

(Apply attributes to each enum member and use `field.GetCustomAttribute<LabelAttribute>()` at runtime.)

**Explanation:**

Enums are excellent for defining a set of named constants. However, their `ToString()` representation is simply the member's name (e.g., "Pending", "Approved"). Often, you want a more user-friendly label (e.g., "Pending Approval", "Fully Approved") for display purposes. Custom attributes are perfect for this.

**Design Steps:**

1.  **Define a Custom `[Label]` Attribute:** This attribute will likely have a constructor parameter for the human-readable string.
2.  **Apply the Attribute to Enum Members:** Decorate each enum member with the `[Label]` attribute.
3.  **Implement a Utility Method (using Reflection):** Create an extension method or a static utility method that takes an enum value.
      * Use `Type.GetField()` to get the `FieldInfo` for the specific enum member.
      * Use `FieldInfo.GetCustomAttribute<LabelAttribute>()` to retrieve the attribute instance.
      * If found, return the label; otherwise, fall back to `ToString()` or an empty string.

**Code Example:**

```csharp
using System;
using System.Reflection; // For Reflection
using System.Linq;

// 1. Define the Custom [Label] Attribute
[AttributeUsage(AttributeTargets.Field, AllowMultiple = false, Inherited = false)]
public class LabelAttribute : Attribute
{
    public string Label { get; }

    public LabelAttribute(string label)
    {
        if (string.IsNullOrWhiteSpace(label))
            throw new ArgumentException("Label cannot be null or empty.", nameof(label));
        Label = label;
    }
}

// 2. Define the Enum with [Label] Attributes
public enum OrderStatus
{
    [Label("Pending Approval")]
    Pending,

    [Label("Processing Order")]
    Processing,

    [Label("Shipped to Customer")]
    Shipped,

    [Label("Order Delivered")]
    Delivered,

    [Label("Order Cancelled")]
    Cancelled,

    // No attribute for Unknown - will fall back to ToString()
    Unknown
}

// 3. Utility Method to Get Enum Label
public static class EnumExtensions
{
    public static string GetLabel(this Enum enumValue)
    {
        // Get the FieldInfo for the specific enum member
        FieldInfo field = enumValue.GetType().GetField(enumValue.ToString());

        if (field == null)
        {
            // Should not happen for valid enum values, but good for robustness
            return enumValue.ToString();
        }

        // Get the LabelAttribute applied to this field
        LabelAttribute labelAttr = field.GetCustomAttribute<LabelAttribute>();

        // Return the label if found, otherwise fall back to the enum member's name
        return labelAttr?.Label ?? enumValue.ToString();
    }
}

public static class EnumLabelExample
{
    public static void Run()
    {
        Console.WriteLine("--- Enum Label Attribute Example ---");

        OrderStatus status1 = OrderStatus.Pending;
        OrderStatus status2 = OrderStatus.Delivered;
        OrderStatus status3 = OrderStatus.Processing;
        OrderStatus status4 = OrderStatus.Unknown; // No label attribute

        Console.WriteLine($"Status '{status1}' label: '{status1.GetLabel()}'");
        Console.WriteLine($"Status '{status2}' label: '{status2.GetLabel()}'");
        Console.WriteLine($"Status '{status3}' label: '{status3.GetLabel()}'");
        Console.WriteLine($"Status '{status4}' label: '{status4.GetLabel()}' (No custom label)");

        Console.WriteLine("\n--- Listing all enum members with their labels ---");
        foreach (OrderStatus status in Enum.GetValues(typeof(OrderStatus)))
        {
            Console.WriteLine($"- {status}: {status.GetLabel()}");
        }

        Console.WriteLine("--- End Enum Label Attribute Example ---");
    }
}
```

This approach keeps the display logic tightly coupled with the enum definition itself, making it easy to maintain and consistent across your application.

-----

### ðŸ”¹ You built a `[MaxLength(50)]` attribute for string validation. What design ensures itâ€™s reusable for both models and DTOs?

(Design it with a constructor and apply it to `PropertyInfo`; keep logic in a shared validation utility.)

**Explanation:**

Reusability is key for validation attributes. A `[MaxLength(50)]` attribute should work equally well whether it's applied to a property in your core domain model, a request DTO coming from an API, or a view model for a UI.

**Design for Reusability:**

1.  **Attribute Design:**

      * **`AttributeTargets.Property`:** This is crucial. By targeting `Property`, the attribute can be applied to any public property on any class, whether it's a `User` model, a `CreateProductRequest` DTO, or a `UserViewModel`.
      * **Constructor for Required Parameters:** The `maxLength` value is essential, so it should be a constructor parameter.
      * **Optional Properties:** An `ErrorMessage` property is good for customization.
      * **Inheritance:** `Inherited = true` (default) is generally fine, meaning if you apply `[MaxLength]` to a base class property, it would apply to an overridden property in a derived class.

2.  **Validation Logic Design:**

      * **Shared Utility Class/Method:** The actual validation logic should reside in a separate, static utility class (e.g., `Validator` as shown in the `RequiredField` example) or a validation service.
      * **Reflection-Based:** This utility will use Reflection (`PropertyInfo`, `GetCustomAttribute<T>()`) to inspect any object passed to it, regardless of its specific type. This is what makes it reusable across `User`, `ProductDto`, etc.
      * **Focus on `PropertyInfo`:** The validation logic receives a `PropertyInfo` object and the instance value, allowing it to check the property's type and value against the attribute's rules.

**Code Example:**

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

// 1. Design the [MaxLength] Attribute
[AttributeUsage(AttributeTargets.Property, AllowMultiple = false, Inherited = true)]
public class MaxLengthAttribute : Attribute
{
    public int MaxLength { get; }
    public string ErrorMessage { get; set; }

    public MaxLengthAttribute(int maxLength)
    {
        if (maxLength < 0)
        {
            throw new ArgumentOutOfRangeException(nameof(maxLength), "Max length cannot be negative.");
        }
        MaxLength = maxLength;
        ErrorMessage = $"The field must be a string or array with a maximum length of {MaxLength}.";
    }

    public MaxLengthAttribute(int maxLength, string errorMessage) : this(maxLength)
    {
        ErrorMessage = errorMessage;
    }

    // Method to perform the actual validation logic for a property
    public bool IsValid(object value)
    {
        if (value == null)
        {
            return true; // Null strings are typically valid for MaxLength (RequiredField handles null)
        }

        if (value is string strValue)
        {
            return strValue.Length <= MaxLength;
        }
        else if (value is System.Collections.ICollection collection) // For arrays, lists, etc.
        {
            return collection.Count <= MaxLength;
        }
        // Could add more specific type checks (e.g., byte[] for file size)
        return true; // Consider other types always valid for MaxLength
    }
}

// Model for core business logic
public class Product
{
    public int Id { get; set; }

    [MaxLength(100, ErrorMessage = "Product Name cannot exceed 100 characters.")]
    public string Name { get; set; }

    [MaxLength(500)]
    public string Description { get; set; } // Uses default error message

    public decimal Price { get; set; }
}

// DTO for API requests
public class CreateProductRequest
{
    [RequiredField(ErrorMessage = "Product name is required.")]
    [MaxLength(100, ErrorMessage = "Product Name in request cannot exceed 100 characters.")]
    public string ProductName { get; set; }

    [MaxLength(500)]
    public string ProductDescription { get; set; }

    public decimal Price { get; set; }
}

// Shared Validation Utility (similar to the one in RequiredField example)
public static class ReusableValidator
{
    public static List<string> Validate(object instance)
    {
        List<string> errors = new List<string>();
        if (instance == null) return errors; // Or throw

        Type type = instance.GetType();
        foreach (PropertyInfo property in type.GetProperties())
        {
            object value = property.GetValue(instance);

            // Validate [RequiredField]
            RequiredFieldAttribute requiredAttr = property.GetCustomAttribute<RequiredFieldAttribute>();
            if (requiredAttr != null)
            {
                // Re-use logic from previous example
                bool isInvalid = false;
                if (value == null) isInvalid = true;
                else if (value is string strValue && string.IsNullOrWhiteSpace(strValue)) isInvalid = true;
                else if (property.PropertyType.IsValueType && value.Equals(Activator.CreateInstance(property.PropertyType))) isInvalid = true;

                if (isInvalid) errors.Add($"{property.Name}: {requiredAttr.ErrorMessage}");
            }

            // Validate [MaxLength]
            MaxLengthAttribute maxLengthAttr = property.GetCustomAttribute<MaxLengthAttribute>();
            if (maxLengthAttr != null)
            {
                if (!maxLengthAttr.IsValid(value))
                {
                    errors.Add($"{property.Name}: {maxLengthAttr.ErrorMessage}");
                }
            }
        }
        return errors;
    }
}

public static class MaxLengthExample
{
    public static void Run()
    {
        Console.WriteLine("--- Reusable MaxLength Attribute Example ---");

        // Validate a Product model
        Console.WriteLine("\n--- Validating Product Model ---");
        Product p1 = new Product { Id = 1, Name = "Short Name", Description = "A short description.", Price = 10.0m };
        List<string> p1Errors = ReusableValidator.Validate(p1);
        if (p1Errors.Any()) { Console.WriteLine("Errors:"); p1Errors.ForEach(Console.WriteLine); }
        else { Console.WriteLine("Product is valid."); }

        Product p2 = new Product { Id = 2, Name = new string('A', 150), Description = "Okay", Price = 20.0m };
        List<string> p2Errors = ReusableValidator.Validate(p2);
        Console.WriteLine("\n--- Validating Product Model (Too long name) ---");
        if (p2Errors.Any()) { Console.WriteLine("Errors:"); p2Errors.ForEach(Console.WriteLine); }
        else { Console.WriteLine("Product is valid."); }

        // Validate a CreateProductRequest DTO
        Console.WriteLine("\n--- Validating CreateProductRequest DTO ---");
        CreateProductRequest req1 = new CreateProductRequest
        {
            ProductName = "New Laptop Model X",
            ProductDescription = "This is a very detailed description for the new laptop. ".Repeat(10), // Too long
            Price = 1200.0m
        };
        List<string> req1Errors = ReusableValidator.Validate(req1);
        if (req1Errors.Any()) { Console.WriteLine("Errors:"); req1Errors.ForEach(Console.WriteLine); }
        else { Console.WriteLine("Request is valid."); }

        CreateProductRequest req2 = new CreateProductRequest
        {
            ProductName = "", // Required and too short
            ProductDescription = "Short desc",
            Price = 50.0m
        };
        Console.WriteLine("\n--- Validating CreateProductRequest DTO (Missing name) ---");
        List<string> req2Errors = ReusableValidator.Validate(req2);
        if (req2Errors.Any()) { Console.WriteLine("Errors:"); req2Errors.ForEach(Console.WriteLine); }
        else { Console.WriteLine("Request is valid."); }

        Console.WriteLine("--- End Reusable MaxLength Attribute Example ---");
    }

    // Helper for repeating strings
    public static string Repeat(this string s, int count)
    {
        return string.Concat(Enumerable.Repeat(s, count));
    }
}
```

The key to reusability is the attribute's narrow focus on `PropertyInfo` and the centralized, reflection-based validation logic that doesn't care about the specific class type, only the metadata it finds.

-----

### ðŸ”¹ You use `[Obsolete]` with and without parameters. Whatâ€™s the difference, and how would you implement similar overload behavior in a custom attribute?

(With message and `IsError`; use constructor overloads and optional parameters in your custom attribute.)

**Explanation:**

The built-in `[Obsolete]` attribute is a great example of an attribute with flexible usage due to its constructor overloads and optional parameters.

**Differences in `[Obsolete]` Usage:**

1.  **`[Obsolete]` (No parameters):**

      * **Effect:** Compiling code that uses the decorated member will generate a **warning**.
      * **Meaning:** The member is deprecated but can still be used. It's a soft deprecation.

2.  **`[Obsolete("Use NewMethod instead.")]` (With message parameter):**

      * **Effect:** Compiling code that uses the decorated member will generate a **warning**, and the provided string message will be part of that warning.
      * **Meaning:** Provides context to the developer about *why* it's obsolete and what to use instead.

3.  **`[Obsolete("This method is no longer supported.", true)]` (With message and `error` parameter set to `true`):**

      * **Effect:** Compiling code that uses the decorated member will generate a **compile-time error**.
      * **Meaning:** This is a hard deprecation. The member cannot be used anymore. This forces developers to update their code.

**Implementing Similar Overload Behavior in a Custom Attribute:**

You can mimic this behavior in your own custom attributes by:

1.  **Using Multiple Constructors (Overloads):** Provide different constructors that take varying numbers or types of parameters, allowing for different ways to initialize the attribute.
2.  **Using Optional Parameters (Public Properties with Setters):** For parameters that are not strictly required for every usage but can add extra information, expose them as public properties with public setters. These can then be set using named arguments when applying the attribute.

**Code Example (Custom `[FeatureFlag]` Attribute):**

Let's design a `[FeatureFlag]` attribute that can either just mark a feature, or mark it with a name, or mark it as disabled by default.

```csharp
using System;
using System.Reflection;
using System.Linq;

// 1. Define the Custom [FeatureFlag] Attribute
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method | AttributeTargets.Property, AllowMultiple = false, Inherited = true)]
public class FeatureFlagAttribute : Attribute
{
    public string FeatureName { get; } // Required (via constructor or default)
    public bool IsEnabledByDefault { get; set; } // Optional parameter (default false)
    public string Description { get; set; } // Optional parameter

    // Overload 1: Simplest usage - just marks a feature, uses target's name
    public FeatureFlagAttribute()
    {
        // FeatureName will be set dynamically via reflection later if not provided.
        // Or you could make it required and ensure it's always passed.
        // For this example, let's assume it can be inferred or left null.
        FeatureName = null;
        IsEnabledByDefault = false; // Default to off
    }

    // Overload 2: Specify a custom feature name
    public FeatureFlagAttribute(string featureName) : this() // Chain to default constructor for common defaults
    {
        if (string.IsNullOrWhiteSpace(featureName))
        {
            throw new ArgumentException("Feature name cannot be null or empty.", nameof(featureName));
        }
        FeatureName = featureName;
    }

    // Overload 3: Specify a custom feature name and whether it's enabled by default
    public FeatureFlagAttribute(string featureName, bool isEnabledByDefault) : this(featureName)
    {
        IsEnabledByDefault = isEnabledByDefault;
    }
}

// Applying the Custom FeatureFlag Attributes with different overloads/parameters
[FeatureFlag] // Uses default constructor
public class BetaFeatures
{
    [FeatureFlag("NewUserDashboard", IsEnabledByDefault = true)] // Overload 2 + optional parameter
    public void ShowNewDashboard()
    {
        Console.WriteLine("  Displaying the new user dashboard.");
    }

    [FeatureFlag(IsEnabledByDefault = false, Description = "Advanced search logic using AI.")] // Overload 1 + optional parameters
    public void PerformAdvancedSearch()
    {
        Console.WriteLine("  Performing advanced search.");
    }

    [FeatureFlag("ExperimentA")] // Overload 2
    public bool IsExperimentAEnabled { get; set; } = false;
}

public class StableFeatures
{
    // No feature flags here
    public void DisplayHomePage()
    {
        Console.WriteLine("  Displaying standard home page.");
    }
}

// Runtime Feature Flag Processor
public static class FeatureFlagProcessor
{
    public static void ProcessFeatures(Assembly assembly)
    {
        Console.WriteLine("\n--- Processing Feature Flags ---");

        foreach (Type type in assembly.GetTypes())
        {
            // Check for class-level feature flag
            FeatureFlagAttribute classAttr = type.GetCustomAttribute<FeatureFlagAttribute>();
            if (classAttr != null)
            {
                string featureName = classAttr.FeatureName ?? type.Name; // Use type name if not specified
                Console.WriteLine($"\nClass Feature: '{featureName}' (Type: {type.Name})");
                Console.WriteLine($"  Enabled by Default: {classAttr.IsEnabledByDefault}");
                if (!string.IsNullOrEmpty(classAttr.Description))
                    Console.WriteLine($"  Description: {classAttr.Description}");
            }

            // Check for method-level feature flags
            foreach (MethodInfo method in type.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))
            {
                FeatureFlagAttribute methodAttr = method.GetCustomAttribute<FeatureFlagAttribute>();
                if (methodAttr != null)
                {
                    string featureName = methodAttr.FeatureName ?? method.Name; // Use method name if not specified
                    Console.WriteLine($"  Method Feature: '{featureName}' (Method: {method.Name})");
                    Console.WriteLine($"    Enabled by Default: {methodAttr.IsEnabledByDefault}");
                    if (!string.IsNullOrEmpty(methodAttr.Description))
                        Console.WriteLine($"    Description: {methodAttr.Description}");
                }
            }

            // Check for property-level feature flags
            foreach (PropertyInfo prop in type.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))
            {
                FeatureFlagAttribute propAttr = prop.GetCustomAttribute<FeatureFlagAttribute>();
                if (propAttr != null)
                {
                    string featureName = propAttr.FeatureName ?? prop.Name; // Use property name if not specified
                    Console.WriteLine($"  Property Feature: '{featureName}' (Property: {prop.Name})");
                    Console.WriteLine($"    Enabled by Default: {propAttr.IsEnabledByDefault}");
                    if (!string.IsNullOrEmpty(propAttr.Description))
                        Console.WriteLine($"    Description: {propAttr.Description}");
                }
            }
        }
        Console.WriteLine("--- End Processing Feature Flags ---");
    }

    public static void Main(string[] args)
    {
        ProcessFeatures(Assembly.GetExecutingAssembly());

        Console.WriteLine("\n--- Simulating Application Logic Based on Flags ---");
        // In a real app, you'd use a FeatureFlagManager to check if a feature is enabled
        // and then conditionally call methods or display UI.
        BetaFeatures bf = new BetaFeatures();
        if (typeof(BetaFeatures).GetMethod(nameof(BetaFeatures.ShowNewDashboard))
                               .GetCustomAttribute<FeatureFlagAttribute>()?.IsEnabledByDefault == true)
        {
            bf.ShowNewDashboard();
        }
        else
        {
            Console.WriteLine("  NewUserDashboard is disabled or not found.");
        }

        if (typeof(BetaFeatures).GetMethod(nameof(BetaFeatures.PerformAdvancedSearch))
                               .GetCustomAttribute<FeatureFlagAttribute>()?.IsEnabledByDefault == true)
        {
             bf.PerformAdvancedSearch();
        }
        else
        {
            Console.WriteLine("  AdvancedSearch is disabled by default.");
        }

        Console.WriteLine("--- End Simulation ---");
    }
}
```

This example demonstrates how different constructors provide different ways to apply the `[FeatureFlag]` attribute, and how optional public properties extend that flexibility using named arguments. The runtime processor then dynamically interprets this metadata.