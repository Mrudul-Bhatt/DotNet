Today, July 16, 2025, let's explore more advanced scenarios of dynamic method invocation and object creation using Reflection, focusing on common challenges and powerful techniques.

-----

### ðŸ”¹ You are designing a plugin system. How do you dynamically load a class, create an instance, and invoke its `Execute()` method?

(Load type â†’ `Activator.CreateInstance()` â†’ get `MethodInfo` â†’ `Invoke()`.)

**Explanation:**

This is a fundamental pattern for any plugin system. The core idea is that your main application doesn't have compile-time knowledge of the specific plugin types, but it can discover them at runtime and interact with them through a common interface or a known method name.

**The Plugin System Flow:**

1.  **Define a Contract:** Create a shared interface or abstract base class (e.g., `IPlugin`, `IExecutable`) that defines the `Execute()` method (and any other common methods/properties) that all plugins must implement. Both your main application and the plugin assemblies will reference this contract.
2.  **Plugin Implementation:** Plugin developers create classes that implement this contract. These classes reside in separate assemblies (DLLs).
3.  **Dynamic Loading (Main App):**
      * Your main application scans a designated plugin folder for `.dll` files.
      * For each `.dll`, it loads the assembly using `Assembly.LoadFrom()`.
      * It then iterates through `assembly.GetTypes()` to find types that implement your plugin interface (e.g., `typeof(IPlugin).IsAssignableFrom(type)` and `type.IsClass && !type.IsAbstract`).
4.  **Instance Creation:** Once a valid plugin `Type` is found:
      * Use `Activator.CreateInstance(pluginType)` to create an instance of the plugin. If the plugin has a constructor with parameters, you'd use `Activator.CreateInstance(pluginType, constructorArgs)`.
5.  **Method Invocation:**
      * If you've cast the dynamically created instance to its interface (`(IPlugin)pluginInstance`), you can directly call `pluginInstance.Execute()`. This is the preferred "early-bound" way if you know the interface.
      * If you only know the method name (e.g., "Execute") as a string and don't want to cast, or if the method isn't part of a common interface, you'd use Reflection for invocation:
          * Get the `MethodInfo` object for the `Execute` method: `pluginType.GetMethod("Execute")`.
          * Invoke the method: `methodInfo.Invoke(pluginInstance, new object[] { /* method args */ })`.

**Code Example:**

```csharp
using System;
using System.Reflection;
using System.Linq;
using System.Collections.Generic;
using System.IO;

// --- Shared Contract (defined in a separate shared assembly/project) ---
public interface IPlugin
{
    string PluginName { get; }
    string Description { get; }
    void Execute();
}

// --- Plugin Implementation (defined in a separate plugin assembly/project) ---
// For this example, we'll place it in the same project, but imagine it's in "MyGreetingPlugin.dll"
public class GreetingPlugin : IPlugin
{
    public string PluginName => "Greeting Plugin";
    public string Description => "Prints a greeting message.";
    public void Execute()
    {
        Console.WriteLine($"  [Plugin Execute] Hello from {PluginName}!");
    }
}

public class FarewellPlugin : IPlugin
{
    public string PluginName => "Farewell Plugin";
    public string Description => "Prints a farewell message.";
    public void Execute()
    {
        Console.WriteLine($"  [Plugin Execute] Goodbye from {PluginName}!");
    }
}

// --- Main Application (consumes plugins) ---
public static class PluginHost
{
    public static void Run()
    {
        Console.WriteLine("--- Plugin System Example ---");

        // Simulate loading from a plugin directory
        // In a real scenario, this would be:
        // string pluginDirectory = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Plugins");
        // if (!Directory.Exists(pluginDirectory)) Directory.CreateDirectory(pluginDirectory);
        // string pluginDllPath = Path.Combine(pluginDirectory, "MyGreetingPlugin.dll");
        // File.Copy(Assembly.GetExecutingAssembly().Location, pluginDllPath, true); // Copy current for demo

        // For demo purposes, we'll just use the current assembly.
        Assembly assemblyToScan = Assembly.GetExecutingAssembly();
        List<IPlugin> loadedPlugins = new List<IPlugin>();

        Console.WriteLine($"\nScanning assembly: {assemblyToScan.FullName}");

        foreach (Type type in assemblyToScan.GetTypes())
        {
            // 1. Discover types that implement IPlugin and are concrete classes
            if (typeof(IPlugin).IsAssignableFrom(type) && type.IsClass && !type.IsAbstract)
            {
                Console.WriteLine($"  Found potential plugin type: {type.FullName}");
                try
                {
                    // 2. Create an instance of the plugin type
                    IPlugin pluginInstance = (IPlugin)Activator.CreateInstance(type);
                    loadedPlugins.Add(pluginInstance);
                    Console.WriteLine($"  Created instance: {pluginInstance.PluginName}");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"  Error creating plugin instance {type.FullName}: {ex.Message}");
                }
            }
        }

        Console.WriteLine($"\n--- Executing {loadedPlugins.Count} discovered plugins ---");
        foreach (IPlugin plugin in loadedPlugins)
        {
            // 3. Invoke the Execute() method (early-bound via interface)
            Console.WriteLine($"Executing plugin: {plugin.PluginName}");
            plugin.Execute();
        }

        // Alternative: Late-bound invocation if you only know method name as string
        Console.WriteLine("\n--- Late-bound invocation of Execute() (if interface not used) ---");
        foreach (IPlugin plugin in loadedPlugins)
        {
            Type pluginType = plugin.GetType();
            MethodInfo executeMethod = pluginType.GetMethod("Execute", BindingFlags.Public | BindingFlags.Instance);
            if (executeMethod != null)
            {
                Console.WriteLine($"Late-binding executing plugin: {plugin.PluginName}");
                executeMethod.Invoke(plugin, null); // No parameters for Execute()
            }
        }

        Console.WriteLine("--- End Plugin System Example ---");
    }
}
```

This comprehensive example walks through the full process from discovery to execution.

-----

### ðŸ”¹ You want to call a generic method via reflection, like `Process<T>()`. How would you do this dynamically with `T = Customer`?

(Get the `MethodInfo` for `Process<T>`, use `MakeGenericMethod(typeof(Customer))`, then `Invoke()`.)

**Explanation:**

Calling generic methods dynamically is a common requirement, especially in frameworks that deal with arbitrary types at runtime (e.g., ORMs, serializers, data processors). The key is the `MethodInfo.MakeGenericMethod()` method.

**Dynamic Generic Method Invocation Flow:**

1.  **Get the Generic `MethodInfo` Definition:** When a method is generic, you first need to get the `MethodInfo` for its *unbound* generic definition (e.g., `Process<>`). You cannot call `Invoke()` directly on this unbound definition.
      * Example: `typeof(MyProcessor).GetMethod("Process")`. If there are multiple overloads, you might need to specify parameter types.
2.  **Make it Concrete:** Use `genericMethodInfo.MakeGenericMethod(typeof(TConcrete))`. This takes the generic method definition and substitutes the generic type parameters (like `T`) with concrete `Type` objects (like `typeof(Customer)`). This returns a new `MethodInfo` object that is now "bound" to specific types.
3.  **Invoke the Concrete Method:** Use `concreteMethodInfo.Invoke(instance, args)` as you would with any other method.

**Code Example:**

```csharp
using System;
using System.Reflection;
using System.Linq;

public class DataProcessor
{
    // A generic method
    public void Process<T>(T data)
    {
        Console.WriteLine($"  [DataProcessor] Processing data of type '{typeof(T).Name}': {data?.ToString()}");
    }

    public void Process(int data) // An overload for int (non-generic)
    {
        Console.WriteLine($"  [DataProcessor] Processing int data: {data}");
    }

    // Another generic method with a return type
    public TResult Convert<TSource, TResult>(TSource source)
    {
        Console.WriteLine($"  [DataProcessor] Converting {typeof(TSource).Name} to {typeof(TResult).Name}");
        if (typeof(TResult) == typeof(string))
        {
            return (TResult)(object)$"Converted_{source?.ToString()}";
        }
        // Simplified conversion for example
        return default(TResult);
    }
}

public class Customer { public string Name { get; set; } = "John Doe"; }
public class Product { public int ProductId { get; set; } = 123; }

public static class DynamicGenericMethodExample
{
    public static void Run()
    {
        Console.WriteLine("--- Dynamic Generic Method Invocation ---");

        DataProcessor processor = new DataProcessor();
        Type processorType = typeof(DataProcessor);

        // Scenario 1: Calling Process<Customer>(customerInstance)

        // 1. Get the MethodInfo for the generic definition of Process<T>
        // Note: GetMethod("Process") might return the non-generic overload if it exists.
        // To ensure we get the generic one, we can look for methods with 1 generic parameter.
        MethodInfo genericProcessMethodDefinition = processorType.GetMethods()
            .FirstOrDefault(m => m.Name == "Process" && m.IsGenericMethodDefinition);

        if (genericProcessMethodDefinition != null)
        {
            Console.WriteLine("\nInvoking Process<Customer>:");
            // 2. Make the generic method concrete with typeof(Customer)
            MethodInfo processCustomerMethod = genericProcessMethodDefinition.MakeGenericMethod(typeof(Customer));

            // Create an instance of Customer
            Customer customerData = new Customer();

            // 3. Invoke the concrete method
            processCustomerMethod.Invoke(processor, new object[] { customerData });
        }
        else
        {
            Console.WriteLine("Generic 'Process' method not found.");
        }


        // Scenario 2: Calling Process<Product>(productInstance)
        if (genericProcessMethodDefinition != null)
        {
            Console.WriteLine("\nInvoking Process<Product>:");
            MethodInfo processProductMethod = genericProcessMethodDefinition.MakeGenericMethod(typeof(Product));
            Product productData = new Product();
            processProductMethod.Invoke(processor, new object[] { productData });
        }


        // Scenario 3: Calling Convert<int, string>(123)

        // Get the generic definition for Convert<TSource, TResult>
        MethodInfo genericConvertMethodDefinition = processorType.GetMethods()
            .FirstOrDefault(m => m.Name == "Convert" && m.IsGenericMethodDefinition && m.GetGenericArguments().Length == 2);

        if (genericConvertMethodDefinition != null)
        {
            Console.WriteLine("\nInvoking Convert<int, string>:");
            MethodInfo convertIntToStringMethod = genericConvertMethodDefinition.MakeGenericMethod(typeof(int), typeof(string));

            object result = convertIntToStringMethod.Invoke(processor, new object[] { 123 });
            Console.WriteLine($"  Convert result: {result} (Type: {result?.GetType().Name})");
        }
        else
        {
            Console.WriteLine("Generic 'Convert' method not found.");
        }

        Console.WriteLine("--- End Dynamic Generic Method Example ---");
    }
}
```

This example clearly shows the two-step process: getting the generic definition and then making it concrete before invoking.

-----

### ðŸ”¹ You receive type names from config (as strings). How do you create instances of those types dynamically?

(Use `Type.GetType("Namespace.ClassName")` or `Assembly.Load().GetType()` â†’ pass to `Activator.CreateInstance()`.)

**Explanation:**

This is a very common scenario for configurable applications. Instead of hardcoding types, you store their names (and potentially assembly names) in configuration files (e.g., `appsettings.json`, XML, database). At runtime, you read these strings and use Reflection to create the corresponding objects.

**Dynamic Instance Creation from String Flow:**

1.  **Retrieve Type Name(s):** Read the fully qualified type name (e.g., "MyNamespace.MyClass") and optionally the assembly name (e.g., "MyAssembly") from your configuration source.
2.  **Get `Type` Object:**
      * **If type is in the *currently loaded* assembly or a *referenced* assembly:**
          * `Type.GetType("MyNamespace.MyClass")`: This works if the type is already loaded in the current `AppDomain`.
          * `Type.GetType("MyNamespace.MyClass, MyAssembly")`: This explicitly specifies the assembly name, which is more robust.
      * **If type is in an *unloaded* assembly:**
          * First, load the assembly: `Assembly.LoadFrom("path/to/MyAssembly.dll")` or `Assembly.Load("MyAssembly")`.
          * Then, get the type from the loaded assembly: `loadedAssembly.GetType("MyNamespace.MyClass")`.
3.  **Create Instance:** Once you have the `Type` object, pass it to `Activator.CreateInstance()`:
      * `Activator.CreateInstance(type)` (for parameterless constructor)
      * `Activator.CreateInstance(type, constructorArgs)` (for parameterized constructor)

**Code Example:**

```csharp
using System;
using System.Reflection;
using System.Linq;

// A class to be dynamically created
public class ConfigurableService
{
    public string Message { get; }
    public int Value { get; }

    public ConfigurableService()
    {
        Message = "Default Configurable Service";
        Value = 0;
        Console.WriteLine("  ConfigurableService: Parameterless constructor used.");
    }

    public ConfigurableService(string message, int value)
    {
        Message = message;
        Value = value;
        Console.WriteLine($"  ConfigurableService: Constructor with '{message}', {value} used.");
    }

    public void RunService()
    {
        Console.WriteLine($"  Running service: Message='{Message}', Value={Value}");
    }
}

public static class DynamicConfigCreationExample
{
    public static void Run()
    {
        Console.WriteLine("--- Dynamic Object Creation from Config Strings ---");

        // Simulate reading from configuration
        string typeFullNameFromConfig1 = "ConfigurableService"; // Assumes in current assembly or well-known location
        string typeFullNameFromConfig2 = "ConfigurableService, " + Assembly.GetExecutingAssembly().GetName().Name; // Fully qualified
        string typeFullNameFromConfig3 = "NonExistentType"; // For error handling

        // Scenario 1: Using Type.GetType() with simple name (works if type is already loaded)
        Console.WriteLine("\n--- Creating 'ConfigurableService' using Type.GetType(string name) ---");
        Type type1 = Type.GetType(typeFullNameFromConfig1);
        if (type1 != null)
        {
            object instance1 = Activator.CreateInstance(type1);
            (instance1 as ConfigurableService)?.RunService();
        }
        else
        {
            Console.WriteLine($"  Error: Type '{typeFullNameFromConfig1}' not found in loaded assemblies.");
        }

        // Scenario 2: Using Type.GetType() with fully qualified name (more robust)
        Console.WriteLine("\n--- Creating 'ConfigurableService' using Type.GetType(string assemblyQualifiedName) ---");
        Type type2 = Type.GetType(typeFullNameFromConfig2);
        if (type2 != null)
        {
            object instance2 = Activator.CreateInstance(type2, "Config Message", 42); // With constructor parameters
            (instance2 as ConfigurableService)?.RunService();
        }
        else
        {
            Console.WriteLine($"  Error: Type '{typeFullNameFromConfig2}' not found.");
        }

        // Scenario 3: Error handling for non-existent type
        Console.WriteLine("\n--- Attempting to create 'NonExistentType' ---");
        Type type3 = Type.GetType(typeFullNameFromConfig3);
        if (type3 != null)
        {
            // This block will not be hit for a non-existent type
            object instance3 = Activator.CreateInstance(type3);
            Console.WriteLine($"  Created: {instance3.GetType().Name}");
        }
        else
        {
            Console.WriteLine($"  As expected: Type '{typeFullNameFromConfig3}' not found (returns null).");
        }

        // Scenario 4: Loading from an arbitrary assembly path (if not loaded yet)
        Console.WriteLine("\n--- Creating from specific assembly path (demonstration) ---");
        string currentAssemblyPath = Assembly.GetExecutingAssembly().Location;
        try
        {
            Assembly loadedAssembly = Assembly.LoadFrom(currentAssemblyPath); // Load the assembly
            Type typeFromLoadedAssembly = loadedAssembly.GetType(typeFullNameFromConfig1); // Get type from loaded assembly
            if (typeFromLoadedAssembly != null)
            {
                object instance4 = Activator.CreateInstance(typeFromLoadedAssembly);
                Console.WriteLine($"  Created instance from loaded assembly: {instance4.GetType().Name}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"  Error loading or creating from assembly: {ex.Message}");
        }

        Console.WriteLine("--- End Dynamic Config Creation Example ---");
    }
}
```

This highlights the different ways to obtain a `Type` object from a string and then use `Activator.CreateInstance()` to bring the object to life.

-----

### ðŸ”¹ Youâ€™re building a test runner that discovers and executes `[TestMethod]` methods. How do you handle parameterless vs parameterized methods?

(Use `MethodInfo.GetParameters()` to inspect method signature and pass args accordingly â€” throw if unsupported.)

**Explanation:**

Test runners must dynamically invoke test methods. Some frameworks support parameterized tests (e.g., `NUnit.TestCaseSource`, `Xunit.MemberData`), while others strictly require parameterless methods. Reflection allows you to inspect the method signature to determine how to invoke it.

**Test Runner Logic:**

1.  **Discover Test Methods:** Scan assemblies, find test classes (e.g., marked with `[TestFixture]`), and then find methods within those classes marked with `[TestMethod]`.
2.  **Inspect Parameters:** For each `MethodInfo` identified as a test method, call `MethodInfo.GetParameters()`.
3.  **Handle Scenarios:**
      * **Parameterless:** If `parameters.Length == 0`, simply call `methodInfo.Invoke(instance, null)`. This is the simplest case.
      * **Parameterized (Supported):** If `parameters.Length > 0` and your test runner *supports* parameterized tests:
          * You'll need a mechanism to provide the arguments for these parameters (e.g., from `[TestCase]` attributes, `[MemberData]`, or data generators).
          * Gather the `object[]` array of arguments.
          * Call `methodInfo.Invoke(instance, argsArray)`.
      * **Parameterized (Unsupported):** If `parameters.Length > 0` and your test runner *does not support* parameterized tests (or cannot resolve the parameters):
          * Throw an informative exception (e.g., "Test method '{methodName}' has parameters but no data source was provided.")
          * Skip the test and mark it as "Ignored" or "Skipped."

**Code Example:**

```csharp
using System;
using System.Reflection;
using System.Linq;
using System.Collections.Generic;

// Test framework attributes (simplified)
[AttributeUsage(AttributeTargets.Class)]
public class TestFixtureAttribute : Attribute { }

[AttributeUsage(AttributeTargets.Method)]
public class TestMethodAttribute : Attribute { }

[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
public class TestCaseAttribute : Attribute
{
    public object[] Args { get; }
    public TestCaseAttribute(params object[] args) => Args = args;
}

// Sample Test Class
[TestFixture]
public class MyTests
{
    [TestMethod]
    public void Test_NoParameters()
    {
        Console.WriteLine("    [TEST] Executing Test_NoParameters - Passed.");
        // Assert.IsTrue(true);
    }

    [TestMethod]
    [TestCase(1, 2, 3)]
    [TestCase(5, 5, 10)]
    public void Test_WithParameters(int a, int b, int expectedSum)
    {
        int actualSum = a + b;
        if (actualSum == expectedSum)
        {
            Console.WriteLine($"    [TEST] Test_WithParameters({a}, {b}, {expectedSum}) - Passed.");
        }
        else
        {
            Console.WriteLine($"    [TEST] Test_WithParameters({a}, {b}, {expectedSum}) - FAILED: Expected {expectedSum}, Got {actualSum}.");
            throw new Exception("Test failed."); // Simulate failure
        }
    }

    [TestMethod]
    public void Test_WithUnsupportedParameter(string unsupportedArg) // This test is not supported by our simple runner
    {
        Console.WriteLine($"    [TEST] Test_WithUnsupportedParameter - Should not execute if not supported.");
    }
}

public static class SimpleTestRunner
{
    public static void RunTests(Assembly assembly)
    {
        Console.WriteLine("--- Simple Test Runner Example ---");
        int passed = 0;
        int failed = 0;
        int skipped = 0;

        foreach (Type testFixtureType in assembly.GetTypes()
            .Where(t => t.IsClass && !t.IsAbstract && t.GetCustomAttribute<TestFixtureAttribute>() != null))
        {
            Console.WriteLine($"\n  Running tests in Test Fixture: {testFixtureType.Name}");
            object testFixtureInstance = null;
            try
            {
                testFixtureInstance = Activator.CreateInstance(testFixtureType);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"    ERROR: Could not create instance of test fixture {testFixtureType.Name}: {ex.Message}");
                continue;
            }

            foreach (MethodInfo testMethod in testFixtureType.GetMethods(BindingFlags.Public | BindingFlags.Instance)
                .Where(m => m.GetCustomAttribute<TestMethodAttribute>() != null))
            {
                Console.WriteLine($"  Executing test method: {testMethod.Name}");
                ParameterInfo[] parameters = testMethod.GetParameters();

                if (parameters.Length == 0)
                {
                    // Case 1: Parameterless method
                    try
                    {
                        testMethod.Invoke(testFixtureInstance, null);
                        passed++;
                    }
                    catch (TargetInvocationException ex) // Catches exceptions thrown by the test method itself
                    {
                        Console.WriteLine($"      Test FAILED: {ex.InnerException?.Message ?? ex.Message}");
                        failed++;
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"      Test ERROR: {ex.Message}");
                        failed++;
                    }
                }
                else
                {
                    // Case 2: Parameterized method - look for TestCase attributes
                    var testCases = testMethod.GetCustomAttributes<TestCaseAttribute>().ToArray();
                    if (testCases.Any())
                    {
                        foreach (var testCase in testCases)
                        {
                            try
                            {
                                // Validate argument count and types (simplified)
                                if (testCase.Args.Length != parameters.Length)
                                {
                                    Console.WriteLine($"      Test SKIPPED: Mismatch in argument count for {testMethod.Name}.");
                                    skipped++;
                                    continue;
                                }

                                testMethod.Invoke(testFixtureInstance, testCase.Args);
                                passed++;
                            }
                            catch (TargetInvocationException ex)
                            {
                                Console.WriteLine($"      Test FAILED: {ex.InnerException?.Message ?? ex.Message}");
                                failed++;
                            }
                            catch (Exception ex)
                            {
                                Console.WriteLine($"      Test ERROR: {ex.Message}");
                                failed++;
                            }
                        }
                    }
                    else
                    {
                        // Case 3: Parameterized method with no TestCase data (unsupported)
                        Console.WriteLine($"      Test SKIPPED: Method '{testMethod.Name}' has parameters but no [TestCase] attribute.");
                        skipped++;
                    }
                }
            }
        }
        Console.WriteLine($"\n--- Test Summary: Passed={passed}, Failed={failed}, Skipped={skipped} ---");
        Console.WriteLine("--- End Simple Test Runner Example ---");
    }

    public static void RunExample()
    {
        RunTests(Assembly.GetExecutingAssembly());
    }
}
```

This example shows how a test runner would use `GetParameters()` to determine invocation strategy and also demonstrates handling `TargetInvocationException`.

-----

### ðŸ”¹ How can you call a private method or constructor dynamically?

(Use `BindingFlags.NonPublic | BindingFlags.Instance` (or `BindingFlags.Static`) for `GetMethod()` or `GetConstructor()`, then call `Invoke()`.)

**Explanation:**

Reflection allows you to bypass normal access modifiers (public, private, protected, internal). This should be done with extreme caution as it breaks encapsulation and can lead to fragile code. However, it's sometimes necessary for testing private methods, interacting with legacy code, or in specific framework scenarios.

**The Process:**

1.  **Get `Type`:** Obtain the `Type` object of the class containing the private member.
2.  **Get `MethodInfo` or `ConstructorInfo`:**
      * For a private method: Use `type.GetMethod("methodName", BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Static)` (include `Static` if it's a static private method).
      * For a private constructor: Use `type.GetConstructor(BindingFlags.Instance | BindingFlags.NonPublic, null, parameterTypes, null)`. The `parameterTypes` array is crucial for selecting the correct constructor overload.
3.  **Invoke:**
      * For a method: `methodInfo.Invoke(instance, args)` (or `null` for static methods).
      * For a constructor: `constructorInfo.Invoke(args)`.

**Code Example:**

```csharp
using System;
using System.Reflection;

public class SecretAgent
{
    private string _codename;

    // Private constructor
    private SecretAgent(string codename)
    {
        _codename = codename;
        Console.WriteLine($"  [Agent] Private constructor called. Codename: {_codename}");
    }

    // Private instance method
    private string GetSecretMission()
    {
        Console.WriteLine($"  [Agent] Private method 'GetSecretMission' called.");
        return $"Mission: Infiltrate {Guid.NewGuid().ToString().Substring(0, 8)}";
    }

    // Private static method
    private static void LogActivity(string activity)
    {
        Console.WriteLine($"  [Agent] Static private method 'LogActivity' called: {activity}");
    }

    // Public method that internally calls private method (normal encapsulation)
    public void RevealMission()
    {
        string mission = GetSecretMission();
        Console.WriteLine($"  [Agent] Publicly revealing mission: {mission}");
    }
}

public static class PrivateMemberAccessExample
{
    public static void Run()
    {
        Console.WriteLine("--- Accessing Private Members via Reflection ---");
        Type agentType = typeof(SecretAgent);

        // 1. Calling a private constructor
        Console.WriteLine("\n--- Invoking Private Constructor ---");
        // Get the private constructor that takes a string parameter
        ConstructorInfo privateCtor = agentType.GetConstructor(
            BindingFlags.Instance | BindingFlags.NonPublic,
            null, // Binder
            new Type[] { typeof(string) }, // Parameter types
            null  // Modifiers
        );

        SecretAgent agent = null;
        if (privateCtor != null)
        {
            try
            {
                agent = (SecretAgent)privateCtor.Invoke(new object[] { "Eagle Eye" });
            }
            catch (Exception ex)
            {
                Console.WriteLine($"  Error invoking private constructor: {ex.Message}");
            }
        }
        else
        {
            Console.WriteLine("  Private constructor not found.");
        }


        // 2. Calling a private instance method
        if (agent != null)
        {
            Console.WriteLine("\n--- Invoking Private Instance Method ---");
            MethodInfo getSecretMissionMethod = agentType.GetMethod(
                "GetSecretMission",
                BindingFlags.Instance | BindingFlags.NonPublic
            );

            if (getSecretMissionMethod != null)
            {
                try
                {
                    string missionResult = (string)getSecretMissionMethod.Invoke(agent, null);
                    Console.WriteLine($"  Result from private method: {missionResult}");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"  Error invoking private method: {ex.Message}");
                }
            }
            else
            {
                Console.WriteLine("  Private method 'GetSecretMission' not found.");
            }
        }

        // 3. Calling a private static method
        Console.WriteLine("\n--- Invoking Private Static Method ---");
        MethodInfo logActivityMethod = agentType.GetMethod(
            "LogActivity",
            BindingFlags.Static | BindingFlags.NonPublic
        );

        if (logActivityMethod != null)
        {
            try
            {
                // For static methods, the instance object is null
                logActivityMethod.Invoke(null, new object[] { "Reporting from the field." });
            }
            catch (Exception ex)
            {
                Console.WriteLine($"  Error invoking private static method: {ex.Message}");
            }
        }
        else
        {
            Console.WriteLine("  Private static method 'LogActivity' not found.");
        }

        Console.WriteLine("--- End Private Member Access Example ---");
    }
}
```

This demonstrates the use of `BindingFlags.NonPublic` to gain access to otherwise inaccessible members.

-----

### ðŸ”¹ Your code invokes methods dynamically, but `TargetInvocationException` keeps occurring. How do you debug it?

(Check `InnerException` of the `TargetInvocationException` â€” it wraps the real exception thrown inside the method.)

**Explanation:**

This is a very common pitfall when using Reflection. When you invoke a method dynamically using `MethodInfo.Invoke()` (or a constructor using `ConstructorInfo.Invoke()`), if the *target method itself* throws an exception, that exception is *wrapped* inside a `System.Reflection.TargetInvocationException`. The `TargetInvocationException` itself doesn't tell you *what* went wrong inside the method; it just tells you that *something* went wrong during the reflected invocation.

**Debugging Strategy:**

1.  **Catch `TargetInvocationException`:** Always wrap your `Invoke()` calls in a `try-catch` block that specifically catches `TargetInvocationException`.
2.  **Inspect `InnerException`:** The `TargetInvocationException` has a crucial property called `InnerException`. This `InnerException` holds the *actual* exception that was thrown by the method you were trying to invoke.
3.  **Log or Rethrow `InnerException`:** Once you have the `InnerException`, you can log its details, rethrow it (to let higher layers handle it), or process it according to your application's error handling strategy.

**Code Example:**

```csharp
using System;
using System.Reflection;

public class FaultyService
{
    public void CauseArgumentException(string data)
    {
        if (string.IsNullOrEmpty(data))
        {
            throw new ArgumentException("Input 'data' cannot be null or empty.", nameof(data));
        }
        Console.WriteLine($"  Processed data: {data}");
    }

    public void CauseNullReferenceException()
    {
        string[] arr = null;
        Console.WriteLine(arr[0]); // This will cause NRE
    }
}

public static class ExceptionDebuggingExample
{
    public static void Run()
    {
        Console.WriteLine("--- Debugging TargetInvocationException ---");

        FaultyService service = new FaultyService();
        Type serviceType = typeof(FaultyService);

        // Scenario 1: Method throws ArgumentException
        Console.WriteLine("\n--- Invoking CauseArgumentException with invalid data ---");
        MethodInfo argExMethod = serviceType.GetMethod("CauseArgumentException");
        if (argExMethod != null)
        {
            try
            {
                argExMethod.Invoke(service, new object[] { "" }); // Pass empty string to cause exception
                Console.WriteLine("  Method completed successfully (unexpected).");
            }
            catch (TargetInvocationException ex)
            {
                Console.WriteLine("  Caught TargetInvocationException!");
                // THIS IS THE KEY: Inspect the InnerException
                Console.WriteLine($"    Actual exception type: {ex.InnerException?.GetType().Name}");
                Console.WriteLine($"    Actual exception message: {ex.InnerException?.Message}");
                Console.WriteLine($"    Stack Trace of actual exception:\n{ex.InnerException?.StackTrace}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"  Caught unexpected exception: {ex.GetType().Name}: {ex.Message}");
            }
        }

        // Scenario 2: Method throws NullReferenceException
        Console.WriteLine("\n--- Invoking CauseNullReferenceException ---");
        MethodInfo nreMethod = serviceType.GetMethod("CauseNullReferenceException");
        if (nreMethod != null)
        {
            try
            {
                nreMethod.Invoke(service, null);
                Console.WriteLine("  Method completed successfully (unexpected).");
            }
            catch (TargetInvocationException ex)
            {
                Console.WriteLine("  Caught TargetInvocationException!");
                // AGAIN, inspect InnerException
                Console.WriteLine($"    Actual exception type: {ex.InnerException?.GetType().Name}");
                Console.WriteLine($"    Actual exception message: {ex.InnerException?.Message}");
                Console.WriteLine($"    Stack Trace of actual exception:\n{ex.InnerException?.StackTrace}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"  Caught unexpected exception: {ex.GetType().Name}: {ex.Message}");
            }
        }
        Console.WriteLine("--- End Debugging TargetInvocationException Example ---");
    }
}
```

By consistently checking `InnerException`, you can effectively debug errors that occur within dynamically invoked code.

-----

### ðŸ”¹ You want to instantiate a class with the most parameters that match available services in a DI container. How would you select the right constructor?

(Use `GetConstructors()`, inspect parameter types, rank them based on resolvability, then use `ConstructorInfo.Invoke()`.)

**Explanation:**

This is the "greedy" constructor resolution strategy employed by many DI containers (e.g., Autofac, Unity by default, and as a fallback in Microsoft.Extensions.DependencyInjection). The idea is that the constructor with the most parameters explicitly declares all the dependencies needed, making it the preferred choice.

**The Constructor Selection Flow for a DI Container:**

1.  **Get All Constructors:** Call `Type.GetConstructors(BindingFlags.Public | BindingFlags.Instance)` on the implementation type.
2.  **Filter and Sort:**
      * **Filter by `[Inject]` (Optional but Recommended):** If your container supports an `[Inject]` attribute, prioritize any constructor marked with it. If multiple are marked, throw an error.
      * **Sort by Parameter Count (Greedy):** If no `[Inject]` attribute is found, sort the remaining constructors in *descending* order by the number of parameters.
      * **Filter by Resolvability:** For each constructor (starting with the one with most parameters):
          * Iterate through its `ParameterInfo[]` array.
          * For each parameter, check if your DI container can `Resolve` that parameter's `ParameterType` (i.e., is there a registered service for that type?).
          * If *all* parameters of a constructor can be resolved, this is your chosen constructor. Stop searching.
3.  **Handle Fallbacks/Errors:**
      * If no suitable constructor is found (e.g., no public constructors, no resolvable constructors), throw an `InvalidOperationException`.
      * Optionally, if no other constructor is found, try to use the parameterless constructor as a last resort.
4.  **Instantiate:** Once the best constructor is selected, resolve its parameters recursively through the container, build an `object[]` of resolved arguments, and then call `constructorInfo.Invoke(resolvedArgs)`.

**Code Example (Simplified DI Container Logic for Constructor Selection):**

```csharp
using System;
using System.Reflection;
using System.Linq;
using System.Collections.Generic;

// Minimalistic DI container (concept)
public class SimpleContainer
{
    private readonly Dictionary<Type, Type> _registrations = new Dictionary<Type, Type>();
    private readonly Dictionary<Type, object> _singletons = new Dictionary<Type, object>();

    public void Register<TInterface, TImplementation>()
        where TImplementation : TInterface
    {
        _registrations[typeof(TInterface)] = typeof(TImplementation);
    }

    // Dummy method to simulate service availability
    private bool CanResolve(Type type)
    {
        // In a real container, this checks _registrations, _singletons, and built-in types
        return _registrations.ContainsKey(type) ||
               _singletons.ContainsKey(type) ||
               type.IsPrimitive || // Can resolve int, string etc. directly (for demonstration)
               type == typeof(string) ||
               type == typeof(DateTime);
    }

    public object Resolve(Type serviceType)
    {
        if (_singletons.ContainsKey(serviceType))
        {
            return _singletons[serviceType];
        }

        Type implementationType;
        if (_registrations.TryGetValue(serviceType, out implementationType))
        {
            // Use implementation type for constructor lookup
        }
        else if (serviceType.IsClass && !serviceType.IsAbstract)
        {
            // If it's a concrete class and not registered, assume it's its own implementation
            implementationType = serviceType;
        }
        else
        {
            throw new Exception($"Cannot resolve type: {serviceType.Name}");
        }

        Console.WriteLine($"  [Container] Resolving: {implementationType.Name}");

        // 1. Get all public instance constructors
        ConstructorInfo[] constructors = implementationType.GetConstructors(BindingFlags.Public | BindingFlags.Instance);

        // 2. Prioritize [Inject] if present (simplified: just find first)
        ConstructorInfo chosenConstructor = constructors.FirstOrDefault(c => c.GetCustomAttribute<InjectAttribute>() != null);

        if (chosenConstructor == null)
        {
            // 3. If no [Inject], sort by parameter count descending (greedy)
            // Then find the first one where ALL parameters can be resolved
            chosenConstructor = constructors
                .OrderByDescending(c => c.GetParameters().Length)
                .FirstOrDefault(c => c.GetParameters().All(p => CanResolve(p.ParameterType)));
        }

        if (chosenConstructor == null)
        {
            throw new Exception($"No resolvable constructor found for {implementationType.Name}");
        }

        Console.WriteLine($"    Selected Constructor: {implementationType.Name}({string.Join(", ", chosenConstructor.GetParameters().Select(p => p.ParameterType.Name))})");

        // 4. Resolve constructor parameters recursively
        ParameterInfo[] parameters = chosenConstructor.GetParameters();
        object[] resolvedArgs = new object[parameters.Length];

        for (int i = 0; i < parameters.Length; i++)
        {
            // Recursively resolve dependency
            resolvedArgs[i] = Resolve(parameters[i].ParameterType);
        }

        // 5. Instantiate the object
        return chosenConstructor.Invoke(resolvedArgs);
    }
}

// Services for DI example
public interface IMessageService { string GetMessage(); }
public class GreetingService : IMessageService { public string GetMessage() => "Hello DI!"; }

public interface IDateTimeProvider { DateTime GetCurrentTime(); }
public class SystemDateTimeProvider : IDateTimeProvider { public DateTime GetCurrentTime() => DateTime.Now; }

// A class that SimpleContainer will resolve
public class ConsumerService
{
    private readonly IMessageService _messageService;
    private readonly IDateTimeProvider _dateTimeProvider;
    private readonly string _configName; // This parameter type is marked as 'CanResolve' in SimpleContainer

    public ConsumerService(IMessageService messageService, IDateTimeProvider dateTimeProvider, string configName)
    {
        _messageService = messageService;
        _dateTimeProvider = dateTimeProvider;
        _configName = configName;
        Console.WriteLine("  ConsumerService: Constructor with all dependencies called.");
    }

    // This constructor would be ignored by the greedy strategy if the above is resolvable
    public ConsumerService(IMessageService messageService)
    {
        _messageService = messageService;
        Console.WriteLine("  ConsumerService: Constructor with only message service called.");
    }

    public void DisplayInfo()
    {
        Console.WriteLine($"  ConsumerService Info: {_messageService.GetMessage()} at {_dateTimeProvider.GetCurrentTime()} (Config: {_configName})");
    }
}

public static class ConstructorSelectionExample
{
    public static void Run()
    {
        Console.WriteLine("--- DI Container Constructor Selection Example ---");
        SimpleContainer container = new SimpleContainer();

        container.Register<IMessageService, GreetingService>();
        container.Register<IDateTimeProvider, SystemDateTimeProvider>();
        // Simulate 'string' being resolvable by the container (e.g., from configuration)
        container._singletons[typeof(string)] = "MyCoolAppName"; // Directly add string as a 'service'

        ConsumerService service = (ConsumerService)container.Resolve(typeof(ConsumerService));
        service.DisplayInfo();

        Console.WriteLine("--- End DI Container Constructor Selection Example ---");
    }
}
```

This example shows the sophisticated logic a DI container employs to select the right constructor dynamically, making it a very powerful and flexible tool for managing application dependencies.