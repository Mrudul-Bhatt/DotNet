Today, July 16, 2025, let's delve into **Dynamic Method Invocation & Object Creation** using Reflection in C\#. This is where Reflection moves beyond just inspecting metadata to actually *executing* code and *instantiating* objects at runtime, without compile-time knowledge of their specific types.

-----

### Dynamic Method Invocation & Object Creation

**Focus:** Executing code reflectively

The ability to dynamically create objects and invoke methods is what makes Reflection so powerful for building extensible and flexible systems.

#### 1\. `Activator.CreateInstance()`

This static class provides methods to create instances of types at runtime. It's the go-to for "late-bound" object creation.

  * **`Activator.CreateInstance(Type type)`**: Creates an instance of the specified type using its parameterless constructor. The type must have a public parameterless constructor.
      * Example: `object myObject = Activator.CreateInstance(typeof(MyClass));`
  * **`Activator.CreateInstance(Type type, params object[] args)`**: Creates an instance of the specified type using the constructor that best matches the provided arguments. This allows you to call constructors with parameters dynamically.
      * Example: `object myObject = Activator.CreateInstance(typeof(MyClass), "value1", 123);`
  * **`Activator.CreateInstance(string assemblyName, string typeName)`**: Creates an instance of a type given its assembly name and full type name (namespace.type). This is useful for loading types from unknown assemblies.
      * Example: `object myObject = Activator.CreateInstance("MyAssembly", "MyNamespace.MyClass");`

**Late-Binding (Dynamic Object Creation):**

`Activator.CreateInstance()` is the primary mechanism for late-binding. "Late-binding" means that the specific type of an object is not known at compile time but is determined and used at runtime. This contrasts with "early-binding," where types are known and checked by the compiler.

#### 2\. `MethodInfo.Invoke()`

Once you have an object instance (either created dynamically or obtained otherwise) and a `MethodInfo` object representing a method, you can invoke that method dynamically.

  * **`MethodInfo.Invoke(object obj, params object[] parameters)`**: Invokes the method or constructor represented by the current `MethodInfo` instance, using the specified parameters.
      * `obj`: The object on which to invoke the method. If the method is `static`, this argument should be `null`.
      * `parameters`: An array of arguments to pass to the method. If the method takes no parameters, this can be `null` or an empty `object[]`.

**Late-Binding (Dynamic Method Invocation):**

Similar to object creation, `MethodInfo.Invoke()` enables late-bound method calls. You don't need to know the method name or its parameters at compile time; you discover them reflectively and then call them.

#### 3\. Constructor Discovery

When using `Activator.CreateInstance(Type type, params object[] args)`, the runtime automatically tries to find the best matching constructor. However, if you need more granular control or want to implement specific constructor selection logic (as in a DI container), you'll discover constructors explicitly:

  * **`Type.GetConstructors(BindingFlags flags)`**: Returns an array of `ConstructorInfo` objects, representing constructors of the type. You'll use `BindingFlags` (like `BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance`) to filter for specific constructors.
  * **`ConstructorInfo.GetParameters()`**: Returns an array of `ParameterInfo` objects, allowing you to inspect the constructor's parameters.
  * **`ConstructorInfo.Invoke(object[] parameters)`**: Invokes the constructor to create an instance. This is what `Activator.CreateInstance` often uses internally.

**Code Example:**

```csharp
using System;
using System.Reflection;
using System.Linq;

// A class to demonstrate dynamic creation and invocation
public class Calculator
{
    public string Name { get; set; }
    private int _internalValue;

    // Parameterless constructor
    public Calculator()
    {
        Name = "Default Calculator";
        _internalValue = 0;
        Console.WriteLine($"Calculator created: {Name}");
    }

    // Constructor with parameters
    public Calculator(string name, int initialValue)
    {
        Name = name;
        _internalValue = initialValue;
        Console.WriteLine($"Calculator created: {Name} with initial value {initialValue}");
    }

    // Public instance method
    public int Add(int a, int b)
    {
        Console.WriteLine($"  {Name} is adding {a} + {b}");
        return a + b + _internalValue;
    }

    // Public static method
    public static string GetVersion()
    {
        return "Calculator v1.0";
    }

    // Private instance method
    private void LogOperation(string operation)
    {
        Console.WriteLine($"  [{Name}] Operation logged: {operation}");
    }

    // Method with optional parameters
    public double Divide(double dividend, double divisor = 1.0)
    {
        LogOperation($"Dividing {dividend} by {divisor}");
        return dividend / divisor;
    }
}

public static class DynamicOperations
{
    public static void Run()
    {
        Console.WriteLine("--- Dynamic Method Invocation & Object Creation ---");

        // 1. Dynamic Object Creation using Activator.CreateInstance()

        Console.WriteLine("\n--- Creating Objects Dynamically ---");
        // Get the Type object for Calculator
        Type calculatorType = typeof(Calculator);

        // a) Using parameterless constructor
        Console.WriteLine("\nCreating Calculator with parameterless constructor:");
        object calc1 = Activator.CreateInstance(calculatorType);
        Calculator defaultCalc = (Calculator)calc1; // Cast to actual type for early-bound use
        Console.WriteLine($"  Object type: {defaultCalc.GetType().Name}, Name: {defaultCalc.Name}");

        // b) Using constructor with parameters
        Console.WriteLine("\nCreating Calculator with parameters (MyCalc, 10):");
        object calc2 = Activator.CreateInstance(calculatorType, "MyCustomCalc", 10);
        Calculator customCalc = (Calculator)calc2;
        Console.WriteLine($"  Object type: {customCalc.GetType().Name}, Name: {customCalc.Name}");


        // 2. Dynamic Method Invocation using MethodInfo.Invoke()

        Console.WriteLine("\n--- Invoking Methods Dynamically ---");

        // a) Invoke a public instance method (Add)
        Console.WriteLine("\nInvoking public instance method 'Add' on customCalc:");
        MethodInfo addMethod = calculatorType.GetMethod("Add");
        if (addMethod != null)
        {
            object[] addParams = { 5, 7 };
            object result = addMethod.Invoke(customCalc, addParams); // customCalc is the instance
            Console.WriteLine($"  Add result: {result}");
        }
        else
        {
            Console.WriteLine("  Method 'Add' not found.");
        }

        // b) Invoke a public static method (GetVersion)
        Console.WriteLine("\nInvoking public static method 'GetVersion':");
        MethodInfo getVersionMethod = calculatorType.GetMethod("GetVersion");
        if (getVersionMethod != null)
        {
            // For static methods, the first argument to Invoke is null
            object version = getVersionMethod.Invoke(null, null);
            Console.WriteLine($"  Calculator Version: {version}");
        }
        else
        {
            Console.WriteLine("  Method 'GetVersion' not found.");
        }

        // c) Invoke a private instance method (LogOperation) - requires BindingFlags.NonPublic
        Console.WriteLine("\nInvoking private instance method 'LogOperation' on defaultCalc (requires NonPublic flag):");
        MethodInfo logMethod = calculatorType.GetMethod("LogOperation", BindingFlags.Instance | BindingFlags.NonPublic);
        if (logMethod != null)
        {
            object[] logParams = { "First operation performed." };
            logMethod.Invoke(defaultCalc, logParams); // defaultCalc is the instance
        }
        else
        {
            Console.WriteLine("  Method 'LogOperation' not found or not accessible.");
        }

        // d) Invoke a method with optional parameters
        Console.WriteLine("\nInvoking 'Divide' method with and without optional parameter:");
        MethodInfo divideMethod = calculatorType.GetMethod("Divide");
        if (divideMethod != null)
        {
            // Calling with both parameters
            object divideResult1 = divideMethod.Invoke(customCalc, new object[] { 100.0, 5.0 });
            Console.WriteLine($"  Divide result (100/5): {divideResult1}");

            // Calling with only mandatory parameter (optional will use default)
            object divideResult2 = divideMethod.Invoke(customCalc, new object[] { 75.0 });
            Console.WriteLine($"  Divide result (75/default): {divideResult2}");
        }

        // 3. Explicit Constructor Discovery (for advanced scenarios like DI)

        Console.WriteLine("\n--- Explicit Constructor Discovery ---");
        ConstructorInfo[] constructors = calculatorType.GetConstructors(BindingFlags.Public | BindingFlags.Instance);
        foreach (ConstructorInfo ctor in constructors)
        {
            string paramList = string.Join(", ", ctor.GetParameters().Select(p => $"{p.ParameterType.Name} {p.Name}"));
            Console.WriteLine($"  Found Constructor: {calculatorType.Name}({paramList})");
        }

        // Selecting a specific constructor and invoking it
        // Example: Find the constructor that takes (string, int)
        ConstructorInfo specificCtor = constructors.FirstOrDefault(c =>
        {
            ParameterInfo[] parameters = c.GetParameters();
            return parameters.Length == 2 &&
                   parameters[0].ParameterType == typeof(string) &&
                   parameters[1].ParameterType == typeof(int);
        });

        if (specificCtor != null)
        {
            Console.WriteLine("\nInvoking specific (string, int) constructor via ConstructorInfo.Invoke:");
            object[] ctorArgs = { "SpecificCalc", 500 };
            object calc3 = specificCtor.Invoke(ctorArgs);
            Calculator specificCalc = (Calculator)calc3;
            Console.WriteLine($"  Created object name: {specificCalc.Name}");
        }
        else
        {
            Console.WriteLine("  Specific constructor not found.");
        }

        Console.WriteLine("--- End Dynamic Operations Example ---");
    }
}
```

**Output Observations from the Example:**

  * `Activator.CreateInstance()` successfully creates instances using both parameterless and parameterized constructors.
  * `MethodInfo.Invoke()` demonstrates calling public instance, public static, and even private instance methods (with appropriate `BindingFlags`). It also shows handling optional parameters.
  * `Type.GetConstructors()` allows you to list and then programmatically select a specific constructor based on its signature, providing fine-grained control over object creation.

-----

### Interview Focus: Implementing Extensible Frameworks like DI Containers or Test Runners

Dynamic method invocation and object creation are core capabilities for building highly flexible and extensible frameworks. Interviewers often probe your understanding of these concepts through real-world scenarios.

#### 1\. Implementing Extensible Frameworks (DI Containers)

**Concept:** A Dependency Injection (DI) container is a prime example of an extensible framework that heavily relies on dynamic object creation and method/constructor invocation.

**How Reflection is Used in a DI Container:**

1.  **Type Registration:** You register an interface to an implementation (e.g., `container.Register<ILogger, ConsoleLogger>()`). The container stores these `Type` mappings.
2.  **Resolution Request:** When you ask the container for an `ILogger` (`container.Resolve<ILogger>()`), it performs the following dynamic steps:
      * **Find Implementation Type:** It looks up `ILogger` and finds `ConsoleLogger`'s `Type`.
      * **Constructor Discovery:** It finds the "best" constructor for `ConsoleLogger`. This often involves:
          * Scanning all constructors using `ConsoleLoggerType.GetConstructors()`.
          * Applying a strategy:
              * Looking for a specific `[Inject]` or `[Autowired]` attribute.
              * Choosing the constructor with the most parameters (the "greedy" approach).
              * Falling back to a parameterless constructor.
      * **Parameter Resolution:** For the chosen constructor, it gets its `ParameterInfo` array (`constructorInfo.GetParameters()`). For each parameter, it recursively calls itself to `Resolve` that parameter's type (e.g., if `ConsoleLogger` needs `IOptions<LoggerSettings>`, it resolves `IOptions<LoggerSettings>`).
      * **Object Instantiation:** Once all constructor parameters are resolved, it uses `constructorInfo.Invoke(resolvedParameters)` (or `Activator.CreateInstance`) to create the `ConsoleLogger` instance.
      * **Property Injection (Optional):** Some containers also support injecting dependencies into public properties marked with an `[Inject]` attribute using `PropertyInfo.SetValue()`.
      * **Method Injection (Optional):** Less common, but some frameworks might call `[Inject]`-marked methods after construction using `MethodInfo.Invoke()`.

**Interview Focus:**

  * **Benefits:** Decoupling, testability, reusability, modularity, dynamic configuration.
  * **Challenges:** Performance (caching is crucial), complexity of object graphs, handling circular dependencies, constructor ambiguity.
  * **Alternative to Reflection for Performance:** Source Generators (new in .NET 5+) or compiled expression trees are used by modern DI containers (e.g., Microsoft.Extensions.DependencyInjection, Autofac) to achieve near-compile-time performance while still offering the flexibility of registration.

#### 2\. Implementing Extensible Frameworks (Test Runners)

**Concept:** A unit test runner is another great example of an extensible framework. It needs to discover, execute, and report on tests without knowing their exact types or method names at compile time.

**How Reflection is Used in a Test Runner:**

1.  **Assembly Scanning:** The test runner starts by loading test assemblies (e.g., `Assembly.LoadFrom("MyTests.dll")`).
2.  **Type Discovery:** It iterates through `assembly.GetTypes()` to find potential test classes.
3.  **Test Class Identification:**
      * It might look for classes decorated with a `[TestClass]` attribute.
      * Or, it might look for classes containing methods with a `[TestMethod]` attribute.
      * Filter for concrete, public classes.
4.  **Test Method Discovery:** For each identified test class:
      * It calls `testClassType.GetMethods()` with appropriate `BindingFlags` (e.g., `Public | Instance`).
      * It filters these `MethodInfo` objects to find methods decorated with `[TestMethod]` (or `[Fact]`, etc.).
      * It also typically filters for methods with no parameters (unless parametrized tests are supported).
5.  **Test Execution:**
      * **Instantiate Test Class:** For each test method, it creates an instance of the test class: `Activator.CreateInstance(testClassType)`.
      * **Invoke Test Method:** It then invokes the test method: `testMethodInfo.Invoke(testClassInstance, null)`.
      * **Setup/Teardown:** It might look for methods marked `[SetUp]` or `[TearDown]` and invoke them before/after each test or test class.
      * **Assertions:** It relies on exceptions (e.g., `Xunit.FactAttribute` for `Xunit` or `NUnit.Framework.Assert.Fail()`) or specific return values to determine test success or failure.
6.  **Reporting:** It collects results (pass/fail, execution time, errors) and presents them to the user.

**Interview Focus:**

  * **Benefits:** Allows developers to write tests in separate assemblies, extensibility (new test types, attributes), dynamic test discovery, integration with IDEs.
  * **Challenges:** Handling exceptions during test execution, reporting detailed results, supporting different test frameworks (JUnit/NUnit/xUnit), parallel execution.

In essence, whenever you see an application that dynamically loads, configures, or executes code based on runtime discovery (plugins, frameworks, configuration systems, ORMs, serializers), Reflection is likely playing a central role in its underlying implementation. Your ability to explain these concepts with concrete examples will be highly valued in an interview.