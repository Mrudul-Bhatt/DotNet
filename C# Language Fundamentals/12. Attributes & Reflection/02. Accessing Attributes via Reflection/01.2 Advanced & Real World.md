Today, July 15, 2025, let's explore practical applications of custom attributes and Reflection, focusing on common scenarios and optimization strategies.

-----

### ðŸ”¹ You want to log method execution only for those decorated with a `[Log]` attribute. How would you do that dynamically?

(Use reflection on `MethodInfo` to detect `[Log]` and wrap method execution in logging logic.)

**Explanation:**

This is a quintessential example of **Aspect-Oriented Programming (AOP)**. The logging logic (a "cross-cutting concern") is separated from the core business logic of the method. The `[Log]` attribute acts as a marker or a declarative instruction for the logging system.

**The Dynamic Process:**

1.  **Define the Contract:** A custom `[Log]` attribute is created to act as the marker.

2.  **Point of Interception:** You need a point in your code where you can "intercept" the method call before it executes. This can be achieved through various mechanisms:

      * **Dynamic Proxy:** Using a library like Castle.Core.DynamicProxy, you can create a proxy object for your class. When a method is called on the proxy, it invokes an `IInterceptor` first.
      * **Manual Wrapper/Decorator:** You manually create a wrapper class that has methods corresponding to your target class. The wrapper's methods then use Reflection to check for the `[Log]` attribute on the target class's methods.
      * **Dependency Injection (DI) Interception:** Modern DI containers often have built-in interception capabilities that can be configured to execute logic based on attributes.
      * **Post-Compilation Weaving:** A build-time tool modifies the IL (Intermediate Language) of your compiled assembly to inject the logging code directly, eliminating runtime Reflection overhead for every call.

3.  **Reflection-Based Logic:** Inside the interceptor or wrapper, you use Reflection on the `MethodInfo` object representing the called method.

      * Use `methodInfo.GetCustomAttribute<LogAttribute>()`.
      * If the attribute is not `null`, it means the method should be logged.
      * Execute your logging logic (e.g., `Console.WriteLine("Entering...")`) before invoking the method via `methodInfo.Invoke()`.
      * Execute your logging logic (e.g., `Console.WriteLine("Exiting...")`) after the invocation.

This dynamic approach allows you to add or remove logging just by changing the attribute on the method's declaration, without touching the core business logic.

**Code Example (Simplified Manual Interception Concept):**

```csharp
using System;
using System.Reflection;

// 1. Define the [Log] attribute
[AttributeUsage(AttributeTargets.Method)]
public class LogAttribute : Attribute { }

// 2. Class with business logic
public class MyService
{
    [Log]
    public void DoSomething(string data)
    {
        Console.WriteLine($"  [Business Logic] Processing '{data}'.");
    }

    public void DoSomethingElse()
    {
        Console.WriteLine("  [Business Logic] Doing something else (no logging).");
    }
}

// 3. A general-purpose method invoker that performs logging dynamically
public static class DynamicInvoker
{
    public static void InvokeMethodWithLogging(object instance, string methodName, params object[] args)
    {
        // Get the MethodInfo for the target method
        MethodInfo method = instance.GetType().GetMethod(methodName);

        if (method == null)
        {
            Console.WriteLine($"Error: Method '{methodName}' not found.");
            return;
        }

        // Check for the [Log] attribute
        LogAttribute logAttr = method.GetCustomAttribute<LogAttribute>();

        if (logAttr != null)
        {
            Console.WriteLine($"[LOG] Entering method: {method.Name}");
        }

        try
        {
            // Invoke the method
            method.Invoke(instance, args);
        }
        finally
        {
            if (logAttr != null)
            {
                Console.WriteLine($"[LOG] Exiting method: {method.Name}");
            }
        }
    }
}

public static class DynamicLogExample
{
    public static void Run()
    {
        Console.WriteLine("--- Dynamic Logging with Attributes ---");
        MyService service = new MyService();

        Console.WriteLine("\n--- Invoking method with [Log] attribute ---");
        DynamicInvoker.InvokeMethodWithLogging(service, nameof(MyService.DoSomething), "Hello World");

        Console.WriteLine("\n--- Invoking method without [Log] attribute ---");
        DynamicInvoker.InvokeMethodWithLogging(service, nameof(MyService.DoSomethingElse));

        Console.WriteLine("--- End Dynamic Logging Example ---");
    }
}
```

The `DynamicInvoker` class doesn't have specific knowledge of `MyService`'s methods. It's a generic piece of logic that inspects a method at runtime and takes action based on the metadata it finds.

-----

### ðŸ”¹ You have a `[Display(Name = "User Name")]` attribute on a model property. How would you retrieve that label for UI rendering?

(Access the `PropertyInfo` for the property, then use `GetCustomAttribute<DisplayAttribute>()?.Name`.)

**Explanation:**

This is a common pattern for building data-driven UI. Instead of hardcoding labels in your HTML/XAML, you store them as metadata on the model itself, making your UI components generic and reusable.

**The Retrieval Process:**

1.  **Get the `Type`:** Start with the type of your model object (e.g., `typeof(UserModel)`).
2.  **Get `PropertyInfo`:** Find the specific property you need (e.g., `type.GetProperty("UserName")`).
3.  **Get the Attribute:** Use the generic `GetCustomAttribute<T>()` method on the `PropertyInfo` object.
      * `PropertyInfo.GetCustomAttribute<DisplayAttribute>()`.
      * The `?` (null-conditional operator) is important here, as the attribute might not be present, in which case you should have a fallback (e.g., use the property's name).
4.  **Access the Property:** Once you have the attribute instance, access its `Name` property.

**Code Example:**

```csharp
using System;
using System.ComponentModel.DataAnnotations; // For the built-in [Display] attribute
using System.Reflection;

public class UserProfile
{
    [Display(Name = "User Name")]
    public string UserName { get; set; }

    [Display(Name = "First Name")]
    public string FirstName { get; set; }

    // No Display attribute
    public string LastName { get; set; }
}

public static class UiLabelExtractor
{
    public static string GetDisplayLabel(Type type, string propertyName)
    {
        // Get the PropertyInfo for the specified property
        PropertyInfo property = type.GetProperty(propertyName);

        if (property == null)
        {
            return propertyName; // Fallback to property name if not found
        }

        // Get the DisplayAttribute and access its Name property
        DisplayAttribute displayAttr = property.GetCustomAttribute<DisplayAttribute>();

        // Return the Name from the attribute, or fall back to the property name
        return displayAttr?.Name ?? propertyName;
    }

    public static void Run()
    {
        Console.WriteLine("--- Retrieving UI Labels from Attributes ---");
        Type userProfileType = typeof(UserProfile);

        string userNameLabel = GetDisplayLabel(userProfileType, "UserName");
        string firstNameLabel = GetDisplayLabel(userProfileType, "FirstName");
        string lastNameLabel = GetDisplayLabel(userProfileType, "LastName");
        string nonExistentLabel = GetDisplayLabel(userProfileType, "NonExistentProperty");

        Console.WriteLine($"Label for 'UserName': {userNameLabel}");
        Console.WriteLine($"Label for 'FirstName': {firstNameLabel}");
        Console.WriteLine($"Label for 'LastName': {lastNameLabel}");
        Console.WriteLine($"Label for 'NonExistentProperty': {nonExistentLabel}");
        Console.WriteLine("--- End UI Label Extraction Example ---");
    }
}
```

This simple, reusable method can be integrated into a templating engine or a UI component to automatically generate labels, column headers, or form fields based on the model's metadata.

-----

### ðŸ”¹ Youâ€™re building a serializer that respects `[IgnoreSerialization]` on certain fields. How would you skip those?

(Loop through properties/fields via reflection, check if the attribute is present, and skip accordingly.)

**Explanation:**

A custom serializer needs to be aware of the schema of the object it's serializing. Attributes provide a clean, declarative way to add rules to that schema. The `[IgnoreSerialization]` attribute tells the serializer, "Do not include this property in the output."

**The Skipping Process:**

1.  **Define the Attribute:** Create a simple `[IgnoreSerializationAttribute]`.
2.  **Get Members to Serialize:** Get all the public properties or fields of the object's type using `Type.GetProperties()` or `Type.GetFields()`.
3.  **Iterate and Filter:** Loop through the list of properties. Inside the loop, for each `PropertyInfo` object, check for the presence of the `[IgnoreSerialization]` attribute.
      * `property.GetCustomAttribute<IgnoreSerializationAttribute>()`
4.  **Conditional Logic:** Use a simple `if` statement. If the attribute is found (`!= null`), use `continue` to skip to the next iteration of the loop, effectively ignoring that property. Otherwise, proceed with serializing the property.

**Code Example:**

```csharp
using System;
using System.Reflection;
using System.Text;
using System.Linq;

// 1. Define the [IgnoreSerialization] attribute
[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
public class IgnoreSerializationAttribute : Attribute { }

// 2. Model class
public class UserSettings
{
    public string UserName { get; set; }

    [IgnoreSerialization] // This will be ignored by our serializer
    public string PasswordHash { get; set; }

    public int ThemeId { get; set; }
}

// 3. Custom Reflection-based Serializer
public static class SimpleSerializer
{
    public static string Serialize<T>(T instance)
    {
        if (instance == null) return "null";

        Type type = instance.GetType();
        var sb = new StringBuilder();
        sb.AppendLine("{");

        // Get all public properties declared in the class
        PropertyInfo[] properties = type.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);

        bool firstProp = true;

        foreach (PropertyInfo prop in properties)
        {
            // Check for the [IgnoreSerialization] attribute
            if (prop.GetCustomAttribute<IgnoreSerializationAttribute>() != null)
            {
                continue; // Skip this property
            }

            if (!firstProp)
            {
                sb.AppendLine(",");
            }

            object value = prop.GetValue(instance);
            sb.Append($"  \"{prop.Name}\": \"{value}\""); // Simplified string serialization

            firstProp = false;
        }

        sb.AppendLine("\n}");
        return sb.ToString();
    }

    public static void Run()
    {
        Console.WriteLine("--- Custom Serializer with Attributes ---");
        UserSettings settings = new UserSettings
        {
            UserName = "admin",
            PasswordHash = "hashedpassword123", // This will be skipped
            ThemeId = 5
        };

        string serializedData = SimpleSerializer.Serialize(settings);
        Console.WriteLine("Serialized UserSettings:");
        Console.WriteLine(serializedData);

        Console.WriteLine("--- End Custom Serializer Example ---");
    }
}
```

The output will clearly show that `PasswordHash` was skipped, demonstrating how a single `if` statement with a reflection check enables a powerful, declarative feature in your serializer.

-----

### ðŸ”¹ You want to read all `[Validation]` attributes on a property and execute them at runtime. How would you implement that pipeline?

(Use reflection to get the attributes, cast them, and call a common `Validate()` method defined in the base attribute.)

**Explanation:**

This is an extension of the `[RequiredField]` and `[MaxLength]` examples. Instead of having a separate validation method for each attribute type, you can design a generic validation pipeline that works with any attribute that implements a common interface or inherits from a common base class. This is the foundation of many validation frameworks.

**The Pipeline Process:**

1.  **Common Interface/Base Class:** Define a base class like `ValidationAttribute` that inherits from `Attribute`. This base class should have a public, abstract `Validate()` method.
2.  **Implementations:** Create concrete validation attributes (e.g., `RequiredAttribute`, `EmailAttribute`, `RangeAttribute`) that inherit from `ValidationAttribute` and implement the `Validate()` method with their specific validation logic.
3.  **Apply Attributes (AllowMultiple):** Decorate a property with multiple validation attributes. This requires `AllowMultiple = true` on your base `ValidationAttribute` (or on each specific attribute if it doesn't inherit).
4.  **Runtime Validation Pipeline:**
      * Create a `Validator` class.
      * In the `Validate()` method, get the `Type` and loop through its properties.
      * For each property, use `property.GetCustomAttributes<ValidationAttribute>()` (or the specific base type) to get all validation attributes.
      * Loop through the retrieved attributes and call the `Validate()` method on each one, passing the property's value. Collect any returned errors.

**Code Example:**

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

// 1. Define the Common Base Attribute with a Validate() method
[AttributeUsage(AttributeTargets.Property, AllowMultiple = true, Inherited = true)]
public abstract class ValidationAttribute : Attribute
{
    public string ErrorMessage { get; set; }
    public abstract bool IsValid(object value);
}

// 2. Implementations of specific validation rules
public class RequiredAttribute : ValidationAttribute
{
    public RequiredAttribute() => ErrorMessage = "The field is required.";
    public override bool IsValid(object value)
    {
        if (value == null) return false;
        if (value is string str && string.IsNullOrWhiteSpace(str)) return false;
        return true;
    }
}

public class EmailAttribute : ValidationAttribute
{
    public EmailAttribute() => ErrorMessage = "Invalid email format.";
    public override bool IsValid(object value)
    {
        if (value is string email)
        {
            // Simplified email validation for example
            return email.Contains("@") && email.Contains(".");
        }
        return true;
    }
}

// 3. Model with multiple attributes
public class ContactForm
{
    [Required]
    [Email]
    public string EmailAddress { get; set; }

    [Required(ErrorMessage = "Name is required.")]
    public string FullName { get; set; }
}

// 4. The Runtime Validation Pipeline
public static class ValidationPipeline
{
    public static List<string> Run(object instance)
    {
        var errors = new List<string>();
        if (instance == null) return errors;

        Type type = instance.GetType();
        foreach (PropertyInfo property in type.GetProperties())
        {
            // Get all ValidationAttribute instances on the property
            var validationAttributes = property.GetCustomAttributes<ValidationAttribute>();

            foreach (var attr in validationAttributes)
            {
                object value = property.GetValue(instance);
                if (!attr.IsValid(value))
                {
                    errors.Add($"{property.Name}: {attr.ErrorMessage}");
                }
            }
        }
        return errors;
    }

    public static void RunExample()
    {
        Console.WriteLine("--- Runtime Validation Pipeline with Attributes ---");

        var validForm = new ContactForm
        {
            EmailAddress = "test@example.com",
            FullName = "Jane Doe"
        };
        var invalidForm = new ContactForm
        {
            EmailAddress = "invalid-email",
            FullName = ""
        };

        Console.WriteLine("\nValidating valid form...");
        var validErrors = Run(validForm);
        Console.WriteLine(validErrors.Any() ? "Validation failed." : "Validation succeeded!");

        Console.WriteLine("\nValidating invalid form...");
        var invalidErrors = Run(invalidForm);
        if (invalidErrors.Any())
        {
            Console.WriteLine("Validation failed with errors:");
            invalidErrors.ForEach(Console.WriteLine);
        }

        Console.WriteLine("--- End Validation Pipeline Example ---");
    }
}
```

This design is highly extensible. To add a `[Range]` attribute, you just create a new class inheriting from `ValidationAttribute` and add it to the property. The `Run()` method of the `ValidationPipeline` remains unchanged.

-----

### ðŸ”¹ You notice that retrieving attributes repeatedly via reflection slows down your app. How would you optimize?

(Cache the results of `GetCustomAttributes()` per type/member â€” avoid repeated expensive reflection calls.)

**Explanation:**

Reflection is a powerful tool, but it comes with a performance cost. The process of searching metadata, creating attribute instances, and building an enumerable of them can be slow, especially in performance-critical loops. The solution is **caching**.

**Optimization Strategy:**

1.  **Identify the Cost:** The cost is the repeated calls to `GetCustomAttributes()`.
2.  **Caching Mechanism:** Use a thread-safe dictionary or a concurrent dictionary to store the results of your reflection queries. The key to the dictionary should be the `Type` or `MemberInfo` object, and the value should be the list of attributes.
3.  **"Get or Add" Pattern:** When your logic needs attributes for a given type/member:
      * First, check the cache.
      * If the entry exists, return the cached value immediately.
      * If the entry does not exist, perform the expensive `GetCustomAttributes()` call.
      * Store the result in the cache.
      * Return the result.
4.  **`Lazy<T>` for Lazy Initialization:** For an even more robust and thread-safe solution, you can use `System.Lazy<T>` with a `ConcurrentDictionary`. This ensures that the expensive reflection call is only made once for each type/member, even if multiple threads try to access it simultaneously.

**Code Example:**

```csharp
using System;
using System.Reflection;
using System.Collections.Concurrent;
using System.Linq;

// A simple custom attribute for demonstration
[AttributeUsage(AttributeTargets.Method)]
public class CachedAttribute : Attribute { }

public class CachedProcessor
{
    // Caching for MethodInfo to a list of its attributes
    private static readonly ConcurrentDictionary<MethodInfo, IEnumerable<CachedAttribute>> _attributeCache =
        new ConcurrentDictionary<MethodInfo, IEnumerable<CachedAttribute>>();

    // A class to process
    public class MyService
    {
        [Cached]
        public void PerformTask1() { }

        [Cached]
        public void PerformTask2() { }
    }

    public static void ProcessMethods(Type type)
    {
        Console.WriteLine($"\n--- Processing Type: {type.Name} ---");
        MethodInfo[] methods = type.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);

        foreach (MethodInfo method in methods)
        {
            // Use a lambda to define the expensive operation (the reflection call)
            // The ConcurrentDictionary's GetOrAdd method handles the caching and thread-safety
            IEnumerable<CachedAttribute> cachedAttributes = _attributeCache.GetOrAdd(
                method,
                m =>
                {
                    Console.WriteLine($"  [Cache Miss] Retrieving attributes for method '{m.Name}' via Reflection.");
                    // This is the expensive part we want to cache
                    return m.GetCustomAttributes<CachedAttribute>().ToList();
                }
            );

            // Now you have the cached attributes
            if (cachedAttributes.Any())
            {
                Console.WriteLine($"  [Cache Hit] Method '{method.Name}' has {cachedAttributes.Count()} attributes. Proceeding.");
            }
            else
            {
                Console.WriteLine($"  [Cache Hit] Method '{method.Name}' has no attributes. Proceeding.");
            }
        }
    }

    public static void Run()
    {
        Console.WriteLine("--- Caching Reflection Results ---");
        Type myServiceType = typeof(MyService);

        // First pass: Cache miss, reflection is called
        ProcessMethods(myServiceType);

        // Second pass: All attributes are now in the cache, reflection is not called
        Console.WriteLine("\n--- Processing again (now from cache) ---");
        ProcessMethods(myServiceType);

        Console.WriteLine("--- End Caching Example ---");
    }
}
```

The output will show `[Cache Miss]` on the first run and `[Cache Hit]` on the second run for the same methods, proving that the expensive reflection calls were avoided.

-----

### ðŸ”¹ Youâ€™re writing a dynamic mapping tool and need to process only properties marked `[MapTo("OtherField")]`. How would you extract mapping info?

(Use `Type.GetProperties()`, filter with `.GetCustomAttribute<MapToAttribute>()`, and retrieve the target field name.)

**Explanation:**

This is a very common task for mappers (like AutoMapper or custom serializers). The `[MapTo]` attribute provides a declarative way to specify a mapping from a source property to a target property with a different name.

**The Extraction Process:**

1.  **Define the Attribute:** Create a custom `[MapTo]` attribute with a constructor parameter for the target field's name.
2.  **Get Source Properties:** Use `Type.GetProperties()` to get all properties of the source object.
3.  **Filter for the Attribute:** Loop through each `PropertyInfo` object and check for the `[MapTo]` attribute using `property.GetCustomAttribute<MapToAttribute>()`.
4.  **Extract Mapping Data:** If the attribute is found, you now have a `MapToAttribute` instance. You can access its `TargetFieldName` property to get the string you need for the mapping.

**Code Example:**

```csharp
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Linq;

// 1. Define the [MapTo] attribute
[AttributeUsage(AttributeTargets.Property, AllowMultiple = false)]
public class MapToAttribute : Attribute
{
    public string TargetFieldName { get; }
    public MapToAttribute(string targetFieldName) => TargetFieldName = targetFieldName;
}

// 2. Source and Target classes
public class SourceDto
{
    [MapTo("Id")]
    public int SourceId { get; set; }

    [MapTo("Name")]
    public string SourceName { get; set; }

    public string UnmappedField { get; set; }
}

public class TargetModel
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string UnmappedField { get; set; }
}

// 3. Dynamic Mapper
public static class DynamicMapper
{
    public static TTarget Map<TSource, TTarget>(TSource source)
        where TSource : class
        where TTarget : class, new()
    {
        if (source == null) return null;
        TTarget target = new TTarget();
        Type sourceType = typeof(TSource);
        Type targetType = typeof(TTarget);

        foreach (PropertyInfo sourceProp in sourceType.GetProperties())
        {
            // Get the MapTo attribute on the source property
            MapToAttribute mapToAttr = sourceProp.GetCustomAttribute<MapToAttribute>();

            if (mapToAttr != null)
            {
                // Found a mapping! Get the target property name from the attribute
                string targetPropName = mapToAttr.TargetFieldName;
                PropertyInfo targetProp = targetType.GetProperty(targetPropName);

                if (targetProp != null && targetProp.CanWrite)
                {
                    // Get the value from the source object
                    object value = sourceProp.GetValue(source);
                    // Set the value on the target object
                    targetProp.SetValue(target, value);
                    Console.WriteLine($"  Mapped '{sourceProp.Name}' to '{targetPropName}'");
                }
                else
                {
                    Console.WriteLine($"  Mapping for '{sourceProp.Name}' ignored: Target property '{targetPropName}' not found or not writable.");
                }
            }
        }
        return target;
    }

    public static void Run()
    {
        Console.WriteLine("--- Dynamic Mapping with Attributes ---");
        SourceDto source = new SourceDto
        {
            SourceId = 123,
            SourceName = "My Product",
            UnmappedField = "Should be ignored"
        };

        TargetModel target = Map<SourceDto, TargetModel>(source);

        Console.WriteLine("\nMapping Result:");
        Console.WriteLine($"  Target Id: {target.Id}");
        Console.WriteLine($"  Target Name: {target.Name}");
        Console.WriteLine($"  Target UnmappedField: {target.UnmappedField}");

        Console.WriteLine("--- End Dynamic Mapping Example ---");
    }
}
```

This dynamic mapper works for any source/target pair as long as the source properties are decorated with `[MapTo]` attributes, demonstrating a powerful, reusable design.

-----

### ðŸ”¹ You apply multiple attributes of the same type to a class. How do you retrieve all instances and their data?

(Use `GetCustomAttributes(typeof(MyAttribute), inherit: false)` and cast to access each one.)

**Explanation:**

As discussed in the previous response, using `AllowMultiple = true` on an attribute's `[AttributeUsage]` allows you to apply it more than once to a single target. The key to retrieving all of them is to use the non-generic `GetCustomAttributes()` overload or the generic overload that returns an `IEnumerable<T>`.

**The Retrieval Process:**

1.  **Define the Attribute:** Ensure your custom attribute is defined with `[AttributeUsage(..., AllowMultiple = true)]`.
2.  **Apply the Attributes:** Decorate your class, method, etc., with multiple instances of the attribute.
3.  **Use `GetCustomAttributes()`:**
      * **Non-generic way:** `type.GetCustomAttributes(typeof(MyAttribute), false)` returns an `object[]`. You must then loop through the array and cast each element to `MyAttribute` to access its properties.
      * **Generic way (preferred):** `type.GetCustomAttributes<MyAttribute>(false)` returns an `IEnumerable<MyAttribute>`. This is much cleaner and type-safe. You can then use LINQ or a simple `foreach` loop to iterate and access each instance directly.

**Code Example:**

```csharp
using System;
using System.Reflection;
using System.Linq;

// 1. Define attribute with AllowMultiple = true
[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
public class CategoryTagAttribute : Attribute
{
    public string CategoryName { get; }
    public CategoryTagAttribute(string categoryName) => CategoryName = categoryName;
}

// 2. Apply multiple attributes to a class
[CategoryTag("Science Fiction")]
[CategoryTag("Adventure")]
[CategoryTag("Thriller")]
public class Book
{
    public string Title { get; set; }
}

public static class MultipleAttributesExample
{
    public static void Run()
    {
        Console.WriteLine("--- Retrieving Multiple Attributes ---");

        Type bookType = typeof(Book);

        // Retrieve all instances using the generic GetCustomAttributes<T>()
        IEnumerable<CategoryTagAttribute> categoryTags = bookType.GetCustomAttributes<CategoryTagAttribute>(false);

        Console.WriteLine($"Book class has {categoryTags.Count()} category tags:");

        foreach (var tag in categoryTags)
        {
            Console.WriteLine($"- {tag.CategoryName}");
        }

        Console.WriteLine("\n--- Retrieving using non-generic method (for demonstration) ---");
        object[] rawTags = bookType.GetCustomAttributes(typeof(CategoryTagAttribute), false);
        Console.WriteLine($"Raw array has {rawTags.Length} elements:");
        foreach (object tag in rawTags)
        {
            // Must cast to the specific attribute type
            CategoryTagAttribute categoryTag = (CategoryTagAttribute)tag;
            Console.WriteLine($"- {categoryTag.CategoryName}");
        }

        Console.WriteLine("--- End Multiple Attributes Example ---");
    }
}
```

The output will show all three category tags for the `Book` class, demonstrating the correct way to retrieve all instances of a multi-use attribute.