Today, July 15, 2025, let's explore the core mechanism for leveraging custom attributes: **Accessing Attributes via Reflection**. Reflection is the ability of a program to examine or modify its own structure and behavior at runtime. When combined with attributes, it allows you to read the metadata you've attached to your code and dynamically alter your application's behavior based on that metadata.

-----

### Accessing Attributes via Reflection

**Focus:** Reading metadata at runtime

The primary method for reading attributes is `GetCustomAttributes()`, which is available on various `System.Reflection` types.

#### 1\. `GetCustomAttributes()` on Types, Members, Parameters

You can retrieve attributes from different levels of your code structure:

  * **`Type.GetCustomAttributes()`**: To get attributes applied to an entire class, struct, enum, interface, or delegate.
      * Example: `typeof(MyClass).GetCustomAttributes<MyClassAttribute>()`
  * **`MemberInfo.GetCustomAttributes()`**: `MemberInfo` is the base class for `PropertyInfo`, `MethodInfo`, `FieldInfo`, `EventInfo`, and `ConstructorInfo`. So, you can use `GetCustomAttributes()` on properties, methods, fields, events, and constructors.
      * Example: `typeof(MyClass).GetMethod("MyMethod").GetCustomAttributes<MyMethodAttribute>()`
  * **`ParameterInfo.GetCustomAttributes()`**: To get attributes applied to individual parameters of a method or constructor.
      * Example: `typeof(MyClass).GetMethod("MyMethod").GetParameters()[0].GetCustomAttributes<MyParameterAttribute>()`
  * **`Assembly.GetCustomAttributes()`**: To get attributes applied to the entire assembly.
      * Example: `Assembly.GetExecutingAssembly().GetCustomAttributes<MyAssemblyAttribute>()`

**Important Overloads:**

  * **`GetCustomAttributes(Type attributeType, bool inherit)`**: This overload allows you to filter the attributes by a specific type (e.g., only retrieve `LogAttribute` instances) and to specify whether to include inherited attributes from base classes/interfaces (`inherit: true`).
  * **`GetCustomAttributes<TAttribute>(bool inherit)` (Generic):** This is the most common and convenient way. It returns an `IEnumerable<TAttribute>`, strongly typed to your attribute type.

#### 2\. Filtering by Attribute Type

When calling `GetCustomAttributes()`, you almost always want to filter by a specific attribute type. If you don't specify a type, it will return *all* custom attributes applied to that element, which is usually not what you need.

  * `Type.GetCustomAttributes(typeof(MyCustomAttribute), true)`
  * `Type.GetCustomAttributes<MyCustomAttribute>(true)` (preferred generic way)

#### 3\. `inherit` Parameter

The `inherit` parameter (a `bool`) in `GetCustomAttributes()` determines whether to search the inheritance chain for the attribute.

  * **`inherit: true` (Default for `AttributeUsage.Inherited`):** If an attribute is applied to a base class or an interface, and `AttributeUsage.Inherited` is `true` for that attribute, then `GetCustomAttributes(..., inherit: true)` will also find it on derived classes or classes implementing the interface.
  * **`inherit: false`:** Only attributes directly applied to the target element (class, method, etc.) are returned. Attributes from base types are ignored.

This parameter is crucial when designing attribute inheritance behavior, especially in frameworks.

**Code Example:**

```csharp
using System;
using System.Linq;
using System.Reflection; // Crucial for Reflection operations
using System.Collections.Generic;

// --- Define Custom Attributes ---

// Attribute for classes, inherited by derived classes
[AttributeUsage(AttributeTargets.Class, Inherited = true)]
public class CategoryAttribute : Attribute
{
    public string Name { get; }
    public CategoryAttribute(string name) => Name = name;
}

// Attribute for methods, can be applied multiple times
[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
public class FeatureAttribute : Attribute
{
    public string Name { get; }
    public FeatureAttribute(string name) => Name = name;
}

// Attribute for properties, not inherited
[AttributeUsage(AttributeTargets.Property, Inherited = false)]
public class DisplayNameAttribute : Attribute
{
    public string Name { get; }
    public DisplayNameAttribute(string name) => Name = name;
}

// Attribute for method parameters
[AttributeUsage(AttributeTargets.Parameter)]
public class RequiredParamAttribute : Attribute
{
    public string ErrorMessage { get; set; } = "Parameter is required.";
}

// Attribute for the assembly itself
[assembly: AssemblyCompany("MyCompany")] // Applied at the assembly level
[assembly: AssemblyVersion("1.0.0.0")]

// --- Apply Attributes to Classes, Members, and Parameters ---

[Category("Financial Core")]
public class Account
{
    [DisplayName("Account Identifier")]
    public int AccountId { get; set; }

    [DisplayName("Balance Amount")]
    public decimal Balance { get; set; }

    [Feature("DepositFunds")]
    [Feature("TransactionLogging")] // Multiple features on one method
    public void Deposit(decimal amount, [RequiredParam] string description)
    {
        Console.WriteLine($"Depositing {amount:C} with description: {description}");
    }

    [Feature("WithdrawFunds")]
    public void Withdraw(decimal amount)
    {
        Console.WriteLine($"Withdrawing {amount:C}");
    }
}

[Category("Retail Banking")] // This class also has a Category
public class SavingsAccount : Account // Inherits from Account
{
    // DisplayName on AccountId is not inherited (Inherited = false for DisplayNameAttribute)
    // Feature attributes on Deposit/Withdraw ARE inherited (default for FeatureAttribute is Inherited = true)

    [DisplayName("Interest Rate %")] // New DisplayName for derived class
    public decimal InterestRate { get; set; }

    [Feature("CalculateInterest")] // New feature specific to SavingsAccount
    public void CalculateInterest()
    {
        Console.WriteLine("Calculating interest...");
    }
}

public class ReportGenerator
{
    [Feature("GenerateMonthlyReport")]
    [Feature("ExportToPDF")]
    public void GenerateReport([RequiredParam(ErrorMessage = "Report type is required.")] string reportType)
    {
        Console.WriteLine($"Generating {reportType} report.");
    }
}

// --- Reflection-Based Attribute Access ---

public static class AttributeReader
{
    public static void ReadAndProcessAttributes()
    {
        Console.WriteLine("--- Accessing Attributes via Reflection ---");

        // 1. Get Assembly-level Attributes
        Assembly currentAssembly = Assembly.GetExecutingAssembly();
        Console.WriteLine($"\n--- Assembly: {currentAssembly.GetName().Name} ---");
        object[] assemblyCompanyAttrs = currentAssembly.GetCustomAttributes(typeof(AssemblyCompanyAttribute), false);
        if (assemblyCompanyAttrs.Any())
        {
            AssemblyCompanyAttribute companyAttr = (AssemblyCompanyAttribute)assemblyCompanyAttrs[0];
            Console.WriteLine($"  Company: {companyAttr.Company}");
        }

        // --- Process Account Class ---
        ProcessTypeAttributes(typeof(Account));
        ProcessTypeAttributes(typeof(SavingsAccount)); // See inheritance effects
        ProcessTypeAttributes(typeof(ReportGenerator));

        Console.WriteLine("--- End Attribute Access Example ---");
    }

    private static void ProcessTypeAttributes(Type type)
    {
        Console.WriteLine($"\n--- Processing Type: {type.Name} ---");

        // Get CategoryAttribute on the Type
        // Using generic GetCustomAttribute<T>() and checking 'inherit: true' for CategoryAttribute
        CategoryAttribute categoryAttr = type.GetCustomAttribute<CategoryAttribute>(true);
        if (categoryAttr != null)
        {
            Console.WriteLine($"  Category: {categoryAttr.Name} (Inherited: {type.BaseType != null && type.BaseType.GetCustomAttribute<CategoryAttribute>() != null})");
        }

        // Get Properties and their DisplayName attributes
        Console.WriteLine("  Properties:");
        foreach (PropertyInfo prop in type.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))
        {
            // DisplayNameAttribute has Inherited = false, so we typically check with inherit: false
            DisplayNameAttribute displayNameAttr = prop.GetCustomAttribute<DisplayNameAttribute>(false);
            Console.Write($"    - {prop.Name}");
            if (displayNameAttr != null)
            {
                Console.WriteLine($" (Display As: {displayNameAttr.Name})");
            }
            else
            {
                Console.WriteLine(" (No custom display name)");
            }
        }

        // Get Methods and their Feature/Parameter attributes
        Console.WriteLine("  Methods:");
        foreach (MethodInfo method in type.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly))
        {
            Console.WriteLine($"    - {method.Name}");

            // Get ALL FeatureAttributes (AllowMultiple = true) on the method
            FeatureAttribute[] featureAttrs = method.GetCustomAttributes<FeatureAttribute>(true).ToArray(); // inherit=true just in case it was on a base method
            if (featureAttrs.Any())
            {
                Console.WriteLine($"      Features: {string.Join(", ", featureAttrs.Select(f => f.Name))}");
            }

            // Get parameters and their RequiredParam attributes
            ParameterInfo[] parameters = method.GetParameters();
            if (parameters.Any())
            {
                Console.WriteLine("      Parameters:");
                foreach (ParameterInfo param in parameters)
                {
                    Console.Write($"        - {param.Name} ({param.ParameterType.Name})");
                    RequiredParamAttribute requiredParamAttr = param.GetCustomAttribute<RequiredParamAttribute>();
                    if (requiredParamAttr != null)
                    {
                        Console.WriteLine($" [Required: {requiredParamAttr.ErrorMessage}]");
                    }
                    else
                    {
                        Console.WriteLine(" [Optional]");
                    }
                }
            }
        }
    }

    public static void Main(string[] args)
    {
        ReadAndProcessAttributes();
    }
}
```

**Output Explanation from the Example:**

```
--- Accessing Attributes via Reflection ---

--- Assembly: YourAssemblyName --- (The actual assembly name will appear here)
  Company: MyCompany

--- Processing Type: Account ---
  Category: Financial Core (Inherited: False)
  Properties:
    - AccountId (Display As: Account Identifier)
    - Balance (Display As: Balance Amount)
  Methods:
    - Deposit
      Features: DepositFunds, TransactionLogging
      Parameters:
        - amount (Decimal) [Optional]
        - description (String) [Required: Parameter is required.]
    - Withdraw
      Features: WithdrawFunds
      Parameters:
        - amount (Decimal) [Optional]

--- Processing Type: SavingsAccount ---
  Category: Retail Banking (Inherited: False) // Own category overrides/adds
  Properties:
    - InterestRate (Display As: Interest Rate %)
    - AccountId (No custom display name) // DisplayName NOT inherited!
    - Balance (No custom display name) // DisplayName NOT inherited!
  Methods:
    - CalculateInterest
      Features: CalculateInterest
      Parameters:
        - amount (Decimal) [Optional]
    - Deposit // Inherited from Account
      Features: DepositFunds, TransactionLogging
      Parameters:
        - amount (Decimal) [Optional]
        - description (String) [Required: Parameter is required.]
    - Withdraw // Inherited from Account
      Features: WithdrawFunds
      Parameters:
        - amount (Decimal) [Optional]

--- Processing Type: ReportGenerator ---
  Properties: (No custom display name)
  Methods:
    - GenerateReport
      Features: GenerateMonthlyReport, ExportToPDF
      Parameters:
        - reportType (String) [Required: Report type is required.]
--- End Attribute Access Example ---
```

**Key Observations from the Output:**

  * **Assembly-level attributes** are read directly from the `Assembly` object.
  * **`Account` class:** Shows its category and the features/parameters on its methods. Notice `AllowMultiple = true` for `FeatureAttribute` allows "DepositFunds" and "TransactionLogging" on the same method.
  * **`SavingsAccount` class (Inheritance in action):**
      * It has its own `Category("Retail Banking")`. The `CategoryAttribute` allows `Inherited = true`, so if `SavingsAccount` *didn't* have its own, it would have inherited "Financial Core". Since it *does* have its own, that applies.
      * The `DisplayNameAttribute` on `AccountId` and `Balance` in the `Account` class is **NOT** inherited by `SavingsAccount`'s overridden (or implicitly available) properties because `DisplayNameAttribute` was defined with `Inherited = false`.
      * The `FeatureAttribute`s (`DepositFunds`, `TransactionLogging`, `WithdrawFunds`) from the `Account` class's methods *are* found on `SavingsAccount`'s methods (when using `inherit: true` for `GetCustomAttributes`) because `FeatureAttribute` was defined with default `Inherited = true`.
      * The `RequiredParamAttribute` on `description` in `Deposit` is also inherited because it's a parameter on an inherited method.

This comprehensive example demonstrates how to use `GetCustomAttributes()` to extract metadata from all levels of your code, providing a powerful basis for dynamic behavior.

-----

### Interview Focus: How to use reflection to enable behavior based on attributes

The ability to read attributes via Reflection is the cornerstone of **metadata-driven programming**. This approach allows you to implement **cross-cutting concerns** and **domain-specific languages (DSLs)** directly within your code's declarations.

**How it enables behavior:**

1.  **Define the Contract/Metadata:** You define custom attributes that act as "markers" or "tags" or "declarations" for specific behaviors. These attributes capture your intent.
2.  **Runtime Interception/Scanning:** At runtime, a central piece of code (often a framework component, a custom builder, or a utility method) uses Reflection to scan assemblies, types, and members for these attributes.
3.  **Dynamic Action:** Based on the presence and parameters of these attributes, the runtime code then:
      * **Executes specific logic:** E.g., if `[Log]` is found, invoke a logger. If `[Cacheable]` is found, wrap the method call in a caching mechanism.
      * **Configures components:** E.g., if `[Route("/api/products")]` is found, register a URL route. If `[RequiredField]` is found, add a validation rule to a validation pipeline.
      * **Generates code/proxies:** E.g., AOP frameworks generate proxy classes based on attributes.
      * **Modifies program flow:** E.g., authorization attributes short-circuit execution if roles aren't met.

**Why this is powerful (Benefits for Behavior-Driven Logic):**

  * **Declarative Programming:** Instead of imperative `if` statements or configuration files, you declare what needs to happen directly where it makes sense (on the class, method, or property). This makes code more readable and self-documenting.
  * **Reduced Boilerplate:** Common patterns (validation, logging, caching, authorization) can be implemented once in a generic way, then applied simply by adding an attribute, reducing repetitive code.
  * **Extensibility:** New behaviors can be introduced by simply defining new attributes and corresponding processing logic, without altering existing core code.
  * **Separation of Concerns:** Cross-cutting concerns (like logging or security) are decoupled from the core business logic. The `[Log]` attribute doesn't contain logging logic; it just *signals* that logging is needed.
  * **Convention over Configuration:** Instead of lengthy XML or JSON configuration files, attributes provide a code-centric way to configure behavior based on conventions.
  * **Early Detection (Compile-Time for Usage, Runtime for Logic):** While the attribute's *logic* runs at runtime, applying attributes incorrectly can often be caught at compile-time (e.g., trying to put a `[MethodAttribute]` on a class).

**Interview Scenario Example (How to use reflection to enable behavior based on attributes):**

**Interviewer:** "Imagine you need to implement a data transformation layer. Some properties on your DTOs need to be automatically trimmed (remove leading/trailing whitespace) before saving to the database. How would you achieve this using attributes and reflection?"

**Your Answer (Key Points):**

1.  **Custom Attribute (`[TrimmedStringAttribute]`):**

      * Define a custom attribute `[TrimmedStringAttribute]` inheriting from `Attribute`.
      * Target `AttributeTargets.Property` to mark string properties.
      * It doesn't need any parameters, as its presence alone indicates the trimming behavior.

2.  **Applying the Attribute:**

      * Apply `[TrimmedString]` to the relevant `string` properties in your DTOs or models (e.g., `UserName`, `AddressLine1`).

3.  **Reflection-Based Processor (Transformation Service):**

      * Create a static utility class (e.g., `DataTransformer`) with a method like `ApplyTransformations(object data)`.
      * Inside `ApplyTransformations`:
          * Get the `Type` of the `data` object.
          * Iterate through all its `PropertyInfo` objects using `type.GetProperties()`.
          * For each `PropertyInfo`, check if it has the `[TrimmedStringAttribute]` using `property.GetCustomAttribute<TrimmedStringAttribute>()`.
          * Crucially, check if the property's `PropertyType` is `string` and if the property is writable (`property.CanWrite`).
          * If all conditions are met:
              * Get the current string value using `property.GetValue(data)`.
              * Perform the trimming: `(stringValue as string)?.Trim()`.
              * Set the trimmed value back to the property using `property.SetValue(data, trimmedValue)`.

4.  **Integration Point:**

      * Call `DataTransformer.ApplyTransformations(yourDto)` just before you pass the DTO to your database layer or persistence logic. This could be in a service method, a middleware, or an ORM interceptor.

This demonstrates a clear, clean, and extensible way to add a cross-cutting concern (data trimming) using attributes and reflection, without cluttering individual DTO properties with direct trimming logic.

This concludes the explanation of accessing attributes via reflection and its practical applications.