Today, July 15, 2025, let's continue our exploration of Reflection in C\#, focusing on advanced type inspection scenarios and common patterns for dynamic behavior.

-----

### ðŸ”¹ Youâ€™re building a plugin loader. How would you scan an assembly for all types implementing an interface?

(Use `Assembly.GetTypes()` + `type.IsClass && interfaceType.IsAssignableFrom(type)`.)

**Explanation:**

A common requirement for plugin architectures is to define a contract using an interface. Your plugin loader then scans external assemblies to find all concrete types that adhere to this contract. Reflection is the perfect tool for this dynamic discovery.

**The Scanning Process:**

1.  **Define the Interface:** First, define the public interface that all your plugins must implement.
2.  **Load the Assembly:** Get an `Assembly` object. This can be done by loading a `.dll` file from disk (`Assembly.LoadFrom()`) or by inspecting an already loaded assembly (e.g., `Assembly.GetExecutingAssembly()` for demonstration).
3.  **Get All Types:** Call `assembly.GetTypes()` to retrieve an array of all `System.Type` objects defined within that assembly.
4.  **Filter Types:** Iterate through the `Type` objects and apply the following filters:
      * **Is a class and not abstract:** `type.IsClass && !type.IsAbstract`. You want to instantiate concrete types, not interfaces or abstract classes.
      * **Implements the target interface:** `targetInterfaceType.IsAssignableFrom(type)`. This is the key method. It checks if an instance of `type` can be assigned to a variable of `targetInterfaceType`. This works for both direct implementations and implementations via inheritance.
5.  **Instantiate (Optional):** Once you've identified suitable types, you can create instances of them using `Activator.CreateInstance(type)`.

**Code Example:**

```csharp
using System;
using System.Linq;
using System.Reflection;
using System.Collections.Generic;

// 1. Define the plugin interface
public interface IOperation
{
    string Name { get; }
    double Execute(double a, double b);
}

// Concrete plugin implementations (would typically be in separate DLLs)
public class AddOperation : IOperation
{
    public string Name => "Add";
    public double Execute(double a, double b) => a + b;
}

public class SubtractOperation : IOperation
{
    public string Name => "Subtract";
    public double Execute(double a, double b) => a - b;
}

// A class that does NOT implement IOperation
public class NonOperationClass { }

// An abstract class (should not be instantiated)
public abstract class BaseOperation : IOperation
{
    public abstract string Name { get; }
    public abstract double Execute(double a, double b);
}

public static class PluginLoader
{
    public static List<IOperation> LoadPluginsFromAssembly(Assembly assembly)
    {
        List<IOperation> plugins = new List<IOperation>();
        Type interfaceType = typeof(IOperation);

        Console.WriteLine($"\n--- Scanning Assembly: {assembly.GetName().Name} for IOperation plugins ---");

        foreach (Type type in assembly.GetTypes())
        {
            // Filter: Must be a concrete class and implement IOperation
            if (type.IsClass && !type.IsAbstract && interfaceType.IsAssignableFrom(type))
            {
                try
                {
                    // Create an instance of the plugin
                    IOperation plugin = (IOperation)Activator.CreateInstance(type);
                    plugins.Add(plugin);
                    Console.WriteLine($"  Discovered and loaded plugin: {plugin.Name} ({type.FullName})");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"  Could not instantiate type {type.FullName}: {ex.Message}");
                }
            }
            else
            {
                // Optional: Log why a type was skipped
                // Console.WriteLine($"  Skipping {type.FullName}: Not a concrete class or doesn't implement IOperation.");
            }
        }
        return plugins;
    }

    public static void Run()
    {
        Console.WriteLine("--- Plugin Loader Example ---");

        // For this example, we'll scan the current assembly.
        // In a real app, this would be Assembly.LoadFrom("path/to/plugin.dll")
        Assembly currentAssembly = Assembly.GetExecutingAssembly();
        List<IOperation> operations = LoadPluginsFromAssembly(currentAssembly);

        Console.WriteLine("\n--- Running Discovered Plugins ---");
        if (operations.Any())
        {
            foreach (var op in operations)
            {
                Console.WriteLine($"  {op.Name}(10, 5) = {op.Execute(10, 5)}");
            }
        }
        else
        {
            Console.WriteLine("  No plugins found.");
        }

        Console.WriteLine("--- End Plugin Loader Example ---");
    }
}
```

This example clearly shows how to use `IsAssignableFrom()` to filter for interface implementations and `Activator.CreateInstance()` for dynamic object creation.

-----

### ðŸ”¹ You want to create a generic `ToString()` method that prints all public properties and values of any object. How would you do this reflectively?

(Use `obj.GetType().GetProperties()` + `property.GetValue(obj)` to format property-value pairs.)

**Explanation:**

Overriding `ToString()` for every class can be tedious. A generic, reflection-based `ToString()` method allows you to get a sensible default representation of any object without writing boilerplate code.

**The Reflective `ToString()` Process:**

1.  **Get Object's Type:** Use `obj.GetType()`.
2.  **Get Public Properties:** Call `type.GetProperties(BindingFlags.Public | BindingFlags.Instance)` to get only the public instance properties.
3.  **Iterate and Get Values:** Loop through each `PropertyInfo` object.
      * Use `property.CanRead` to ensure the property has a public getter.
      * Use `property.GetValue(obj)` to retrieve the value of the property from the given object instance.
      * Format the property name and its value into a string.
4.  **Handle Collections/Complex Types:** For better output, you might want to handle collection properties (e.g., list items) or complex object properties differently (e.g., recursively call the generic `ToString()`).

**Code Example:**

```csharp
using System;
using System.Reflection;
using System.Text;
using System.Collections; // For IEnumerable
using System.Linq;

public class Customer
{
    public int Id { get; set; }
    public string Name { get; set; }
    public DateTime DateJoined { get; set; }
    public Address ShippingAddress { get; set; }
    public List<string> Orders { get; set; }
    private string _internalNote = "Do not print me"; // Private field
    public string SecretData { get; private set; } = "Hidden"; // Private setter

    public Customer(int id, string name)
    {
        Id = id;
        Name = name;
        DateJoined = DateTime.Now;
        ShippingAddress = new Address { Street = "123 Main St", City = "Anytown" };
        Orders = new List<string> { "Order #1", "Order #2" };
    }
}

public class Address
{
    public string Street { get; set; }
    public string City { get; set; }

    // No custom ToString() - will use the reflective one if called
}

public static class ObjectDumper
{
    // Max depth to prevent infinite recursion for circular references
    private const int MaxDepth = 3;

    public static string DumpObject(object obj, int indentLevel = 0, int currentDepth = 0)
    {
        if (obj == null) return "null";
        if (obj is string || obj.GetType().IsPrimitive || obj is decimal || obj is DateTime)
        {
            return obj.ToString();
        }

        if (currentDepth >= MaxDepth)
        {
            return $"{obj.GetType().Name} (Max Depth Reached)";
        }

        Type type = obj.GetType();
        var sb = new StringBuilder();
        string indent = new string(' ', indentLevel * 2);

        sb.AppendLine($"{type.Name}:");
        sb.AppendLine($"{indent}{{");

        PropertyInfo[] properties = type.GetProperties(BindingFlags.Public | BindingFlags.Instance);
        foreach (PropertyInfo prop in properties)
        {
            if (prop.CanRead)
            {
                object value = prop.GetValue(obj);
                string valueString;

                if (value is IEnumerable enumerable && !(value is string))
                {
                    sb.Append($"{indent}  {prop.Name}: [");
                    bool firstItem = true;
                    foreach (var item in enumerable)
                    {
                        if (!firstItem) sb.Append(", ");
                        sb.Append(DumpObject(item, indentLevel + 2, currentDepth + 1));
                        firstItem = false;
                    }
                    sb.AppendLine("]");
                }
                else
                {
                    valueString = DumpObject(value, indentLevel + 1, currentDepth + 1);
                    sb.AppendLine($"{indent}  {prop.Name}: {valueString}");
                }
            }
        }
        sb.AppendLine($"{indent}}}");
        return sb.ToString();
    }

    public static void Run()
    {
        Console.WriteLine("--- Generic ToString() / Object Dumper Example ---");
        Customer customer = new Customer(1, "Alice Wonderland");
        Console.WriteLine(DumpObject(customer));
        Console.WriteLine("--- End Generic ToString() Example ---");
    }
}
```

This `DumpObject` method provides a recursive way to print the structure of any object, handling nested objects and collections gracefully, showing only public properties.

-----

### ðŸ”¹ In a serialization framework, how would you skip private fields and include only public writable properties?

(Use `GetProperties(BindingFlags.Public | BindingFlags.Instance)` and filter on `CanWrite`.)

**Explanation:**

Serialization frameworks often need precise control over what data gets serialized. Typically, you only want to serialize data that can be publicly accessed and potentially modified (written to) when deserializing. Reflection allows you to specify these criteria using `BindingFlags` and property characteristics.

**The Filtering Process:**

1.  **Get Properties:** Start with `Type.GetProperties()`.
2.  **Apply `BindingFlags`:**
      * `BindingFlags.Public`: To include only public members.
      * `BindingFlags.Instance`: To include only instance members (not static).
      * (Optional) `BindingFlags.DeclaredOnly`: If you don't want inherited properties.
3.  **Filter by `CanWrite`:** For each `PropertyInfo` object obtained, check `property.CanWrite`. This ensures that the property has a public `set` accessor, which is often required for deserialization.

**Code Example:**

```csharp
using System;
using System.Reflection;
using System.Text;
using System.Linq;

public class Product
{
    public int Id { get; set; } // Public, writable
    public string Name { get; set; } // Public, writable
    public decimal Price { get; private set; } // Public getter, private setter (not writable by public)
    private string _privateNotes = "Internal only"; // Private field (skipped by GetProperties)
    public static int Counter { get; set; } = 0; // Public static (skipped by BindingFlags.Instance)

    public Product(int id, string name, decimal price)
    {
        Id = id;
        Name = name;
        Price = price;
    }
}

public static class SerializationFilterExample
{
    public static string SerializePublicWritableProperties(object obj)
    {
        if (obj == null) return "null";

        Type type = obj.GetType();
        var sb = new StringBuilder();
        sb.AppendLine("{");

        // Get only PUBLIC, INSTANCE properties that have a PUBLIC SETTER
        PropertyInfo[] propertiesToSerialize = type.GetProperties(BindingFlags.Public | BindingFlags.Instance)
                                                   .Where(p => p.CanWrite) // Filter for writable properties
                                                   .ToArray();

        bool firstProp = true;
        foreach (PropertyInfo prop in propertiesToSerialize)
        {
            if (!firstProp)
            {
                sb.AppendLine(",");
            }
            object value = prop.GetValue(obj);
            sb.Append($"  \"{prop.Name}\": \"{value}\""); // Simple string representation
            firstProp = false;
        }

        sb.AppendLine("\n}");
        return sb.ToString();
    }

    public static void Run()
    {
        Console.WriteLine("--- Serialization Filtering Example ---");
        Product product = new Product(101, "Laptop", 1299.99m);

        string serializedOutput = SerializePublicWritableProperties(product);
        Console.WriteLine(serializedOutput);
        Console.WriteLine("--- End Serialization Filtering Example ---");
    }
}
```

The output will only contain `Id` and `Name`, demonstrating that `Price` (private setter), `_privateNotes` (private field), and `Counter` (static property) were correctly excluded.

-----

### ðŸ”¹ You use reflection to find methods with no parameters. Suddenly, some methods are missed. What might be the cause?

(You may be using default `BindingFlags` â€” not capturing non-public, inherited, or static methods.)

**Explanation:**

The default behavior of `Type.GetMethods()` (without any `BindingFlags`) is to return only **public instance** methods. If you're looking for methods with no parameters and some are being missed, it's highly likely they fall outside this default scope.

**Possible Causes and Solutions:**

1.  **Non-Public Methods:** If the missing methods are `private`, `protected`, or `internal`, you need to explicitly include `BindingFlags.NonPublic`.
2.  **Static Methods:** If the missing methods are `static`, you need to explicitly include `BindingFlags.Static`.
3.  **Inherited Methods:** If the missing methods are defined in a base class and you're calling `GetMethods()` on a derived class *with* `BindingFlags.DeclaredOnly`, they will be missed. Remove `DeclaredOnly` or ensure `BindingFlags.FlattenHierarchy` is used correctly for static members.
4.  **Property Accessors/Event Handlers:** Methods like `get_PropertyName`, `set_PropertyName`, `add_EventName`, `remove_EventName` are compiler-generated "special methods." You might need to filter them out using `method.IsSpecialName`.

**Corrected `BindingFlags` for Broader Search:**

To find all methods (public, non-public, instance, static, declared, inherited), you'd typically use:

```csharp
BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static
```

**Code Example (Demonstrating BindingFlags Impact):**

```csharp
using System;
using System.Reflection;
using System.Linq;

public class MyBaseClass
{
    public void PublicBaseMethod() { }
    private void PrivateBaseMethod() { }
    public static void PublicStaticBaseMethod() { }
}

public class MyDerivedClass : MyBaseClass
{
    public void PublicDerivedMethod() { }
    protected void ProtectedDerivedMethod() { }
    private void PrivateDerivedMethod() { }
    public static void PublicStaticDerivedMethod() { }
}

public static class BindingFlagsExample
{
    public static void FindNoParameterMethods(Type type, BindingFlags flags, string description)
    {
        Console.WriteLine($"\n--- Methods of '{type.Name}' with no parameters ({description}) ---");
        MethodInfo[] methods = type.GetMethods(flags);
        var noParamMethods = methods.Where(m => m.GetParameters().Length == 0 && !m.IsSpecialName);

        if (noParamMethods.Any())
        {
            foreach (MethodInfo method in noParamMethods)
            {
                Console.WriteLine($"  - {method.Name} (IsPublic: {method.IsPublic}, IsPrivate: {method.IsPrivate}, IsStatic: {method.IsStatic})");
            }
        }
        else
        {
            Console.WriteLine("  No methods found matching criteria.");
        }
    }

    public static void Run()
    {
        Console.WriteLine("--- BindingFlags Impact Example ---");

        // Default behavior (Public | Instance) - misses many
        FindNoParameterMethods(typeof(MyDerivedClass), BindingFlags.Public | BindingFlags.Instance, "Default (Public | Instance)");

        // Including NonPublic
        FindNoParameterMethods(typeof(MyDerivedClass), BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance, "Public | NonPublic | Instance");

        // Including Static
        FindNoParameterMethods(typeof(MyDerivedClass), BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance, "Public | Static | Instance");

        // DeclaredOnly vs. Inherited
        Console.WriteLine("\n--- DeclaredOnly vs. Inherited ---");
        FindNoParameterMethods(typeof(MyDerivedClass), BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly, "Public | Instance | DeclaredOnly");
        FindNoParameterMethods(typeof(MyDerivedClass), BindingFlags.Public | BindingFlags.Instance, "Public | Instance (with inherited)");
        FindNoParameterMethods(typeof(MyDerivedClass), BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static, "All relevant (Public | NonPublic | Instance | Static)");

        Console.WriteLine("--- End BindingFlags Impact Example ---");
    }
}
```

This example clearly demonstrates how different `BindingFlags` combinations reveal or hide various methods, explaining why some might be "missed."

-----

### ðŸ”¹ You need to determine whether a property is a collection or scalar type. How do you detect this dynamically?

(Check if `property.PropertyType` implements `IEnumerable` and is not a string.)

**Explanation:**

When processing properties dynamically (e.g., for serialization, UI generation, or data mapping), you often need to differentiate between single-value properties (scalars) and multi-value properties (collections) to apply different logic. Strings are a special case: they implement `IEnumerable<char>` but are generally treated as scalar values.

**Detection Logic:**

1.  **Get `PropertyInfo.PropertyType`:** This gives you the `System.Type` object of the property.
2.  **Check `IEnumerable` Implementation:** Use `typeof(IEnumerable).IsAssignableFrom(property.PropertyType)`. This will be true for `List<T>`, `Array`, `Dictionary<TKey, TValue>`, etc.
3.  **Exclude `string`:** Add a check `!(property.PropertyType == typeof(string))` or `!(property.PropertyType is string)`.

**Code Example:**

```csharp
using System;
using System.Reflection;
using System.Collections.Generic;
using System.Collections; // For non-generic IEnumerable
using System.Linq;

public class DataContainer
{
    public int Id { get; set; } // Scalar
    public string Name { get; set; } // Scalar (special case)
    public List<int> Numbers { get; set; } // Collection
    public Dictionary<string, string> Settings { get; set; } // Collection
    public int[] ValuesArray { get; set; } // Collection
    public DateTime Timestamp { get; set; } // Scalar
}

public static class TypeDetectionExample
{
    public static void Run()
    {
        Console.WriteLine("--- Collection vs. Scalar Type Detection ---");

        Type containerType = typeof(DataContainer);
        PropertyInfo[] properties = containerType.GetProperties(BindingFlags.Public | BindingFlags.Instance);

        foreach (PropertyInfo prop in properties)
        {
            Console.Write($"Property: {prop.Name} (Type: {prop.PropertyType.Name}) -> ");

            if (IsCollection(prop.PropertyType))
            {
                Console.WriteLine("COLLECTION");
            }
            else
            {
                Console.WriteLine("SCALAR");
            }
        }
        Console.WriteLine("--- End Collection vs. Scalar Example ---");
    }

    public static bool IsCollection(Type type)
    {
        // A type is considered a collection if it implements IEnumerable
        // AND is not a string (as string implements IEnumerable<char> but is scalar)
        return typeof(IEnumerable).IsAssignableFrom(type) && type != typeof(string);
    }
}
```

This simple `IsCollection` helper method correctly classifies various property types.

-----

### ðŸ”¹ Youâ€™re generating documentation from types. How do you get the method names, parameter types, and return types?

(Use `MethodInfo.GetParameters()`, `ParameterInfo.ParameterType`, `MethodInfo.ReturnType`.)

**Explanation:**

Automated documentation tools (like Sandcastle, DocFx, or even simple custom generators) rely heavily on Reflection to extract structural information about code. You can easily get method signatures.

**Extraction Process:**

1.  **Get `MethodInfo`:** Obtain `MethodInfo` objects for the methods you want to document (e.g., using `Type.GetMethods()`).
2.  **Method Name:** Access `MethodInfo.Name`.
3.  **Return Type:** Access `MethodInfo.ReturnType`.
4.  **Parameters:** Call `MethodInfo.GetParameters()`, which returns an array of `ParameterInfo` objects.
      * For each `ParameterInfo`:
          * Get its name: `ParameterInfo.Name`.
          * Get its type: `ParameterInfo.ParameterType`.
          * You can also check `IsOptional`, `HasDefaultValue`, `DefaultValue` for more detail.

**Code Example:**

```csharp
using System;
using System.Reflection;
using System.Linq;
using System.Collections.Generic;

public class MathOperations
{
    /// <summary>
    /// Adds two integers and returns the sum.
    /// </summary>
    /// <param name="a">The first integer.</param>
    /// <param name="b">The second integer.</param>
    /// <returns>The sum of a and b.</returns>
    public int Add(int a, int b)
    {
        return a + b;
    }

    /// <summary>
    /// Divides two numbers.
    /// </summary>
    /// <param name="dividend">The number to be divided.</param>
    /// <param name="divisor">The number to divide by. Defaults to 1.</param>
    /// <returns>The result of the division.</returns>
    public double Divide(double dividend, double divisor = 1.0)
    {
        return dividend / divisor;
    }

    /// <summary>
    /// Retrieves a list of prime numbers up to a limit.
    /// </summary>
    /// <param name="limit">The upper limit (inclusive).</param>
    /// <returns>A list of integers representing prime numbers.</returns>
    public List<int> GetPrimes(int limit)
    {
        // Dummy implementation for example
        return Enumerable.Range(2, limit - 1).ToList();
    }

    private void InternalHelper() { /* ... */ } // Private method, usually not documented publicly
}

public static class DocGenerator
{
    public static void GenerateMethodDocs(Type type)
    {
        Console.WriteLine($"--- Documenting Methods for Type: {type.Name} ---");

        // Get public instance methods declared in this type (excluding compiler-generated ones)
        MethodInfo[] methods = type.GetMethods(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly)
                                   .Where(m => !m.IsSpecialName)
                                   .ToArray();

        foreach (MethodInfo method in methods)
        {
            Console.WriteLine($"\nMethod Name: {method.Name}");
            Console.WriteLine($"  Return Type: {method.ReturnType.Name}");

            ParameterInfo[] parameters = method.GetParameters();
            if (parameters.Any())
            {
                Console.WriteLine("  Parameters:");
                foreach (ParameterInfo param in parameters)
                {
                    string paramInfo = $"- {param.Name} (Type: {param.ParameterType.Name}";
                    if (param.IsOptional)
                    {
                        paramInfo += $", Optional: true";
                        if (param.HasDefaultValue)
                        {
                            paramInfo += $", Default: {param.DefaultValue ?? "null"}";
                        }
                    }
                    paramInfo += ")";
                    Console.WriteLine($"    {paramInfo}");
                }
            }
            else
            {
                Console.WriteLine("  Parameters: None");
            }
        }
        Console.WriteLine("--- End Method Documentation Example ---");
    }

    public static void Run()
    {
        GenerateMethodDocs(typeof(MathOperations));
    }
}
```

This provides a structured way to extract method signatures for documentation purposes. For full documentation, you'd also parse XML documentation comments.

-----

### ðŸ”¹ You build a dependency injection container. How do you detect the correct constructor to use for object creation?

(Use `Type.GetConstructors()` + select the one with most resolvable parameters â€” or use `[Inject]` attribute marker.)

**Explanation:**

Dependency Injection (DI) containers are frameworks that manage the creation and lifetime of objects (services) and their dependencies. A core part of a DI container is its ability to figure out *how* to create an instance of a given type, which primarily involves selecting the right constructor.

**Constructor Detection Strategies:**

1.  **"Greedy" Constructor (Most Parameters):**

      * This is a common default strategy in many DI containers (e.g., Unity, older Autofac).
      * **How:** Get all public constructors using `Type.GetConstructors(BindingFlags.Public | BindingFlags.Instance)`.
      * Sort them by the number of parameters in descending order.
      * Pick the first constructor in the sorted list (the one with the most parameters).
      * Then, attempt to resolve each of its parameters. If all parameters can be resolved from the container, use this constructor. If not, try the next one with fewer parameters.
      * **Benefit:** Encourages developers to declare all dependencies in the constructor, making them explicit.
      * **Downside:** Can be ambiguous if multiple constructors have the same maximum number of parameters and all are resolvable.

2.  **Attribute-Based (`[Inject]` or `[Autowired]`):**

      * This is a more explicit and robust strategy, often favored for clarity and to handle ambiguity.
      * **How:** Define a custom attribute, e.g., `[InjectAttribute]`.
      * Developers decorate the *one* constructor they want the DI container to use.
      * The container iterates through constructors, finds the one (and only one) marked with `[Inject]`.
      * If no `[Inject]` is found, it might fall back to the parameterless constructor or throw an error.
      * **Benefit:** Removes ambiguity. Clearly signals intent.
      * **Downside:** Requires an extra attribute on the constructor.

3.  **Parameterless Constructor Fallback:**

      * If no other strategy yields a constructor, many containers will fall back to using the public parameterless constructor if one exists.

**Code Example (Attribute-Based Constructor Detection):**

```csharp
using System;
using System.Linq;
using System.Reflection;
using System.Collections.Generic;

// 1. Define the [Inject] attribute
[AttributeUsage(AttributeTargets.Constructor)]
public class InjectAttribute : Attribute { }

// 2. Define service interfaces and implementations
public interface ILogger
{
    void Log(string message);
}

public class ConsoleLogger : ILogger
{
    public void Log(string message) => Console.WriteLine($"[Logger] {message}");
}

public interface IDataRepository
{
    string GetData();
}

public class SqlDataRepository : IDataRepository
{
    private readonly ILogger _logger;
    public SqlDataRepository(ILogger logger)
    {
        _logger = logger;
        _logger.Log("SqlDataRepository initialized.");
    }
    public string GetData() => "Data from SQL DB";
}

// 3. Classes with multiple constructors for DI container to resolve
public class ServiceA
{
    private readonly ILogger _logger;
    private readonly IDataRepository _repo;

    // This is the constructor the DI container should pick
    [Inject]
    public ServiceA(ILogger logger, IDataRepository repo)
    {
        _logger = logger;
        _repo = repo;
        _logger.Log("ServiceA created with logger and repository.");
    }

    public ServiceA(ILogger logger) // Another constructor, but not marked
    {
        _logger = logger;
        _logger.Log("ServiceA created with logger only.");
    }

    public ServiceA() // Parameterless constructor
    {
        Console.WriteLine("ServiceA created with no dependencies.");
    }

    public void DoWork()
    {
        _logger?.Log($"ServiceA doing work. Data: {_repo?.GetData() ?? "No Repo"}");
    }
}

// Minimalistic DI Container (for demonstration)
public class SimpleDIContainer
{
    private readonly Dictionary<Type, Type> _registrations = new Dictionary<Type, Type>();
    private readonly Dictionary<Type, object> _singletons = new Dictionary<Type, object>();

    public void Register<TInterface, TImplementation>()
        where TImplementation : TInterface
    {
        _registrations[typeof(TInterface)] = typeof(TImplementation);
    }

    public TInterface Resolve<TInterface>()
    {
        return (TInterface)Resolve(typeof(TInterface));
    }

    private object Resolve(Type typeToResolve)
    {
        // 1. Check for singletons first
        if (_singletons.ContainsKey(typeToResolve))
        {
            return _singletons[typeToResolve];
        }

        // 2. Find the implementation type
        Type implementationType;
        if (_registrations.ContainsKey(typeToResolve))
        {
            implementationType = _registrations[typeToResolve];
        }
        else if (typeToResolve.IsClass && !typeToResolve.IsAbstract)
        {
            // If not explicitly registered, assume concrete type is its own implementation
            implementationType = typeToResolve;
        }
        else
        {
            throw new InvalidOperationException($"No registration found for {typeToResolve.Name}");
        }

        // 3. Detect the correct constructor
        ConstructorInfo[] constructors = implementationType.GetConstructors();
        ConstructorInfo targetConstructor = null;

        // Prioritize constructor with [Inject] attribute
        targetConstructor = constructors.FirstOrDefault(c => c.GetCustomAttribute<InjectAttribute>() != null);

        // Fallback: if no [Inject], try the one with most parameters (greedy)
        if (targetConstructor == null)
        {
            targetConstructor = constructors.OrderByDescending(c => c.GetParameters().Length).FirstOrDefault();
        }

        if (targetConstructor == null)
        {
            throw new InvalidOperationException($"No suitable constructor found for {implementationType.Name}");
        }

        // 4. Resolve constructor parameters recursively
        ParameterInfo[] parameters = targetConstructor.GetParameters();
        object[] resolvedParameters = new object[parameters.Length];

        for (int i = 0; i < parameters.Length; i++)
        {
            resolvedParameters[i] = Resolve(parameters[i].ParameterType);
        }

        // 5. Create instance
        object instance = targetConstructor.Invoke(resolvedParameters);

        // Optional: If singleton, store it
        // (This simple container doesn't implement full singleton lifecycle)
        // if (IsSingleton(implementationType)) { _singletons[typeToResolve] = instance; }

        return instance;
    }
}

public static class DIContainerExample
{
    public static void Run()
    {
        Console.WriteLine("--- Dependency Injection Container Example ---");

        SimpleDIContainer container = new SimpleDIContainer();

        // Register services
        container.Register<ILogger, ConsoleLogger>();
        container.Register<IDataRepository, SqlDataRepository>();

        Console.WriteLine("\n--- Resolving ServiceA ---");
        ServiceA serviceA = container.Resolve<ServiceA>(); // Resolves the [Inject] constructor
        serviceA.DoWork();

        Console.WriteLine("\n--- End DI Container Example ---");
    }
}
```

This example demonstrates how a DI container uses `GetConstructors()`, looks for the `[Inject]` attribute, and then recursively resolves the constructor's parameters to build the object graph. This is a core competency that underpins many modern application architectures.