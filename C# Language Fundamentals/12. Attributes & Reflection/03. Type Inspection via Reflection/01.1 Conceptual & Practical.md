## What is type inspection in .NET, and how does it work via reflection?

**Type inspection** in .NET refers to the ability to **examine and retrieve information about types (classes, interfaces, enums, structs, delegates, etc.) at runtime**. This means your code can analyze other code (or even itself) dynamically, rather than relying solely on compile-time knowledge.

This entire process is facilitated by **Reflection**, which is a powerful feature of the .NET Framework and .NET Core. Reflection, primarily exposed through types in the `System.Reflection` namespace, allows programs to:

  * **Discover Metadata:** Read information about assemblies, modules, types (classes, interfaces, structs, enums, etc.), and their members (methods, properties, fields, events, constructors). This includes names, access modifiers (public, private), return types, parameter types, custom attributes, and more.
  * **Inspect Relationships:** Determine inheritance hierarchies, implemented interfaces, and nested types.
  * **Dynamic Invocation:** Create instances of types, invoke methods, and access properties or fields dynamically at runtime, even if their specific types or members were not known at compile time.

**How it works via Reflection:**

The core of type inspection is the `System.Type` class.

1.  **Obtaining a `Type` Object:** To inspect any type, you first need to get a `Type` object that represents it.

      * **Using `typeof()` operator:** `Type myClassType = typeof(MyClass);` (compile-time known type)
      * **Using `GetType()` method:** `Type instanceType = myObject.GetType();` (runtime type of an object instance)
      * **Using `Type.GetType(string typeName)`:** `Type loadedType = Type.GetType("Namespace.MyClass, MyAssembly");` (dynamic lookup by name)
      * **From Assembly:** `Assembly.Load("AssemblyName").GetType("TypeName");`

2.  **Using the `Type` Object for Inspection:** Once you have a `Type` object, you can use its methods and properties to query its characteristics:

      * `Name`, `FullName`, `Namespace`
      * `IsClass`, `IsInterface`, `IsAbstract`, `IsPublic`
      * `BaseType` (to get the parent type)
      * `GetInterfaces()` (to get implemented interfaces)
      * `GetMembers()`, `GetMethods()`, `GetProperties()`, `GetFields()`, `GetConstructors()` (to get information about members)
      * `GetCustomAttributes()` (to get custom attributes applied to the type or its members)

**Example:**

```csharp
using System;
using System.Reflection;

public class MySampleClass
{
    public int PublicField;
    private string _privateField;
    public int PublicProperty { get; set; }
    private string PrivateProperty { get; set; }

    public void PublicMethod() { }
    private void PrivateMethod() { }
}

public class Program
{
    public static void Main(string[] args)
    {
        Type type = typeof(MySampleClass);

        Console.WriteLine($"Inspecting Type: {type.FullName}");
        Console.WriteLine($"Is Class: {type.IsClass}");
        Console.WriteLine($"Base Type: {type.BaseType.Name}");

        // Get all public instance methods
        MethodInfo[] publicMethods = type.GetMethods(BindingFlags.Public | BindingFlags.Instance);
        Console.WriteLine("\nPublic Instance Methods:");
        foreach (MethodInfo method in publicMethods)
        {
            Console.WriteLine($"- {method.Name}");
        }
    }
}
```

## How can you retrieve all methods or properties of a type using reflection?

You can retrieve all methods, properties, fields, and constructors of a type using specific `Get` methods on the `Type` object. The key to getting *all* of them (including non-public or static members) is to use the appropriate **`BindingFlags`** enumeration.

  * **`Type.GetMethods()`**: Retrieves methods.
  * **`Type.GetProperties()`**: Retrieves properties.
  * **`Type.GetFields()`**: Retrieves fields.
  * **`Type.GetConstructors()`**: Retrieves constructors.
  * **`Type.GetMembers()`**: Retrieves all public members (methods, properties, fields, events, nested types, etc.). You can use `BindingFlags` here too.

**Example of retrieving all methods and properties (public, private, instance, static):**

```csharp
using System;
using System.Reflection;

public class AnotherSample
{
    public int PublicInstanceProp { get; set; }
    private string _privateInstanceField;
    public static double StaticPublicField;
    private static void StaticPrivateMethod() { }
    public AnotherSample() { }
    private AnotherSample(string value) { }
}

public class Program2
{
    public static void Main(string[] args)
    {
        Type type = typeof(AnotherSample);

        Console.WriteLine($"\n--- All Methods of {type.Name} ---");
        // Combine BindingFlags to get all methods (public, non-public, instance, static)
        MethodInfo[] allMethods = type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);
        foreach (MethodInfo method in allMethods)
        {
            // Filter out inherited methods from Object (unless specifically needed)
            if (method.DeclaringType == type) // Only methods declared directly on AnotherSample
            {
                Console.WriteLine($"- {method.Name} (IsPublic: {method.IsPublic}, IsStatic: {method.IsStatic})");
            }
        }

        Console.WriteLine($"\n--- All Properties of {type.Name} ---");
        PropertyInfo[] allProperties = type.GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);
        foreach (PropertyInfo prop in allProperties)
        {
            if (prop.DeclaringType == type)
            {
                Console.WriteLine($"- {prop.Name} (IsPublic: {prop.GetMethod?.IsPublic ?? false}, CanRead: {prop.CanRead}, CanWrite: {prop.CanWrite})");
            }
        }

        Console.WriteLine($"\n--- All Fields of {type.Name} ---");
        FieldInfo[] allFields = type.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);
        foreach (FieldInfo field in allFields)
        {
            if (field.DeclaringType == type)
            {
                Console.WriteLine($"- {field.Name} (IsPublic: {field.IsPublic}, IsStatic: {field.IsStatic})");
            }
        }
    }
}
```

## What does `BindingFlags.Public | BindingFlags.Instance` do in reflection?

`BindingFlags` is an enumeration used in reflection methods (like `GetMethods()`, `GetProperties()`, `GetFields()`, `GetMembers()`, `GetConstructors()`) to **filter the set of members** that are returned. You combine different `BindingFlags` using the bitwise OR (`|`) operator to specify exactly which members you want.

When you use `BindingFlags.Public | BindingFlags.Instance`:

  * **`BindingFlags.Public`**: This flag indicates that you want to include **public** members in the search results.
  * **`BindingFlags.Instance`**: This flag indicates that you want to include **instance** members (i.e., members that belong to a specific object instance, not to the class itself). This excludes static members.

Therefore, `BindingFlags.Public | BindingFlags.Instance` will return **only public instance members** of the type.

**Contrast with other `BindingFlags`:**

  * **`BindingFlags.NonPublic`**: Includes `private`, `protected`, `internal`, and `protected internal` members.
  * **`BindingFlags.Static`**: Includes `static` members.
  * **`BindingFlags.FlattenHierarchy`**: Typically used with `BindingFlags.Static` to include static members from the entire inheritance hierarchy (not just the declared type).
  * **`BindingFlags.DeclaredOnly`**: Limits the search to members that are explicitly declared on the type itself, excluding inherited members.
  * **`BindingFlags.IgnoreCase`**: Performs a case-insensitive search for names.

**Example of `BindingFlags.Public | BindingFlags.Instance`:**

```csharp
using System;
using System.Reflection;

public class MyClassWithVariousMembers
{
    public int PublicInstanceField;
    private int _privateInstanceField;
    public static int PublicStaticField;

    public void PublicInstanceMethod() { }
    private void PrivateInstanceMethod() { }
    public static void PublicStaticMethod() { }
}

public class Program3
{
    public static void Main(string[] args)
    {
        Type type = typeof(MyClassWithVariousMembers);

        Console.WriteLine($"--- Members with Public | Instance BindingFlags ---");

        Console.WriteLine("Methods:");
        MethodInfo[] methods = type.GetMethods(BindingFlags.Public | BindingFlags.Instance);
        foreach (MethodInfo method in methods)
        {
            // Note: GetMethods() will also return inherited public instance methods from System.Object (e.g., ToString, Equals)
            // You often filter by DeclaringType if you only want methods defined directly on your class.
            if (method.DeclaringType == type)
            {
                Console.WriteLine($"- {method.Name}");
            }
        }

        Console.WriteLine("\nFields:");
        FieldInfo[] fields = type.GetFields(BindingFlags.Public | BindingFlags.Instance);
        foreach (FieldInfo field in fields)
        {
            Console.WriteLine($"- {field.Name}");
        }

        Console.WriteLine("\nProperties:");
        PropertyInfo[] properties = type.GetProperties(BindingFlags.Public | BindingFlags.Instance);
        foreach (PropertyInfo prop in properties)
        {
            Console.WriteLine($"- {prop.Name}");
        }
    }
}
```

**Output:**

```
--- Members with Public | Instance BindingFlags ---
Methods:
- PublicInstanceMethod

Fields:
- PublicInstanceField

Properties:
```

(No properties are output because `GetProperties` would typically include `PublicInstanceProperty` if one existed, but it was not defined in the example.)

This demonstrates that only `PublicInstanceMethod` and `PublicInstanceField` were returned by these specific `Get` calls, as expected based on the `BindingFlags`.