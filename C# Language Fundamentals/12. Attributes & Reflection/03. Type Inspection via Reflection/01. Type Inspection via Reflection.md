Today, July 15, 2025, let's explore **Type Inspection via Reflection** in C\#. Reflection is a powerful feature that allows your C\# programs to inspect and manipulate their own structure and metadata at runtime. This means you can discover information about types, methods, properties, fields, and even invoke members dynamically, all during program execution.

-----

### Type Inspection via Reflection

**Focus:** Dynamic discovery of types, methods, properties

The primary entry point for type inspection is the `System.Type` class. You can obtain a `Type` object in several ways:

  * **`typeof(MyClass)`**: At compile time, if you know the type name.
  * **`myObject.GetType()`**: At runtime, to get the type of an object instance.
  * **`Type.GetType("Namespace.MyClass, MyAssembly")`**: At runtime, by knowing the type's fully qualified name.
  * **From an `Assembly` object**: `myAssembly.GetTypes()` to get all types defined in an assembly.

Once you have a `Type` object, you can use its methods to discover various members.

#### 1\. `Type.GetProperties()`, `GetMethods()`, `GetFields()`

These methods are used to retrieve information about the properties, methods, and fields declared or inherited by a type. They return collections of `PropertyInfo`, `MethodInfo`, and `FieldInfo` objects, respectively.

  * **`Type.GetProperties()`**: Returns an array of `PropertyInfo` objects. Each `PropertyInfo` describes a property, including its name, type, getter/setter methods, and attributes.
  * **`Type.GetMethods()`**: Returns an array of `MethodInfo` objects. Each `MethodInfo` describes a method, including its name, return type, parameters, and attributes.
  * **`Type.GetFields()`**: Returns an array of `FieldInfo` objects. Each `FieldInfo` describes a field, including its name, type, and attributes.

**Important Note: `BindingFlags`**

These methods have overloads that accept `System.Reflection.BindingFlags`. This enumeration is crucial for filtering the members you want to retrieve. Without `BindingFlags`, these methods usually return only `public` `instance` members.

Common `BindingFlags` combinations:

  * **`BindingFlags.Public`**: Includes public members.
  * **`BindingFlags.NonPublic`**: Includes private, protected, internal members.
  * **`BindingFlags.Instance`**: Includes instance members (non-static).
  * **`BindingFlags.Static`**: Includes static members.
  * **`BindingFlags.DeclaredOnly`**: Includes only members explicitly declared on the type itself, excluding inherited members.
  * **`BindingFlags.FlattenHierarchy`**: For static members, includes static members from the base types up the hierarchy.
  * **`BindingFlags.IgnoreCase`**: Ignores case when searching for a member by name.

To get *all* members (public, non-public, instance, static, declared, inherited), you often combine flags:
`BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static`

#### 2\. Access Modifiers, Static vs. Instance, Method Parameters

Once you have `PropertyInfo`, `MethodInfo`, or `FieldInfo` objects, you can query them for detailed information:

  * **Access Modifiers:**
      * `MethodInfo.IsPublic`, `IsPrivate`, `IsProtected`, `IsFamily`, `IsAssembly`, `IsFamilyOrAssembly`, `IsFamilyAndAssembly`
      * Similar properties exist for `FieldInfo` and `PropertyInfo`'s getter/setter methods.
  * **Static vs. Instance:**
      * `MethodInfo.IsStatic`
      * `FieldInfo.IsStatic`
  * **Method Parameters:**
      * `MethodInfo.GetParameters()`: Returns an array of `ParameterInfo` objects.
      * `ParameterInfo` allows you to inspect `Name`, `ParameterType`, `IsOptional`, `HasDefaultValue`, `DefaultValue`, etc.

**Code Example:**

```csharp
using System;
using System.Reflection; // Essential for Reflection
using System.Linq;      // For LINQ extensions like Any(), Select(), Join()

// A sample class to inspect
public class Person
{
    private int _privateId = 100; // Private field
    public string FirstName { get; set; } // Public instance property
    public string LastName { get; private set; } // Public getter, private setter

    public static string Species { get; } = "Homo Sapiens"; // Public static property

    public Person(string firstName, string lastName)
    {
        FirstName = firstName;
        LastName = lastName;
    }

    public void Greet(string message) // Public instance method
    {
        Console.WriteLine($"{FirstName} says: {message}");
    }

    private void InternalLog(string entry) // Private instance method
    {
        Console.WriteLine($"[Internal Log] {FirstName}: {entry}");
    }

    public static void SayHello() // Public static method
    {
        Console.WriteLine("Hello from Person class!");
    }
}

// A base class to demonstrate inheritance
public class Employee : Person
{
    public int EmployeeId { get; set; }
    protected decimal Salary { get; set; } // Protected property

    public Employee(string firstName, string lastName, int employeeId)
        : base(firstName, lastName)
    {
        EmployeeId = employeeId;
    }

    public void DoWork() // Public instance method
    {
        InternalLog("Working now..."); // Can access inherited private method via reflection (carefully)
        Console.WriteLine($"{FirstName} is doing work.");
    }

    protected void GrantBonus(decimal bonusAmount) // Protected instance method
    {
        Salary += bonusAmount;
        Console.WriteLine($"{FirstName} granted bonus of {bonusAmount:C}. New Salary: {Salary:C}");
    }
}

public static class TypeInspectionExample
{
    public static void InspectType(Type type)
    {
        Console.WriteLine($"\n--- Inspecting Type: {type.FullName} ---");

        // --- Fields ---
        Console.WriteLine("\n--- Fields ---");
        // Get both public and non-public, instance and static fields
        FieldInfo[] fields = type.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static | BindingFlags.DeclaredOnly);
        if (fields.Any())
        {
            foreach (FieldInfo field in fields)
            {
                Console.WriteLine($"  Field: {field.Name}");
                Console.WriteLine($"    Type: {field.FieldType.Name}");
                Console.WriteLine($"    Access: {(field.IsPublic ? "public" : field.IsPrivate ? "private" : field.IsFamily ? "protected" : "internal")}");
                Console.WriteLine($"    Static: {field.IsStatic}");
            }
        }
        else
        {
            Console.WriteLine("  No fields declared directly in this type.");
        }


        // --- Properties ---
        Console.WriteLine("\n--- Properties ---");
        PropertyInfo[] properties = type.GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static | BindingFlags.DeclaredOnly);
        if (properties.Any())
        {
            foreach (PropertyInfo prop in properties)
            {
                Console.WriteLine($"  Property: {prop.Name}");
                Console.WriteLine($"    Type: {prop.PropertyType.Name}");
                Console.WriteLine($"    CanRead: {prop.CanRead}, CanWrite: {prop.CanWrite}");
                // You can also inspect getter/setter method access modifiers
                MethodInfo getter = prop.GetGetMethod(true); // true to get non-public
                MethodInfo setter = prop.GetSetMethod(true);
                Console.WriteLine($"    Getter Access: {(getter?.IsPublic ?? false ? "public" : getter?.IsPrivate ?? false ? "private" : "N/A")}");
                Console.WriteLine($"    Setter Access: {(setter?.IsPublic ?? false ? "public" : setter?.IsPrivate ?? false ? "private" : "N/A")}");
                Console.WriteLine($"    Static: {(getter?.IsStatic ?? false || setter?.IsStatic ?? false)}"); // Check if either accessor is static
            }
        }
        else
        {
            Console.WriteLine("  No properties declared directly in this type.");
        }

        // --- Methods ---
        Console.WriteLine("\n--- Methods ---");
        // Get both public and non-public, instance and static methods, declared only
        MethodInfo[] methods = type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static | BindingFlags.DeclaredOnly);
        if (methods.Any())
        {
            foreach (MethodInfo method in methods)
            {
                // Filter out property getters/setters, event add/remove, etc., if you only want 'true' methods
                if (method.IsSpecialName) continue; // Skip compiler-generated methods for properties/events

                Console.WriteLine($"  Method: {method.Name}");
                Console.WriteLine($"    Return Type: {method.ReturnType.Name}");
                Console.WriteLine($"    Access: {(method.IsPublic ? "public" : method.IsPrivate ? "private" : method.IsFamily ? "protected" : "internal")}");
                Console.WriteLine($"    Static: {method.IsStatic}");

                // Parameters
                ParameterInfo[] parameters = method.GetParameters();
                if (parameters.Any())
                {
                    Console.WriteLine("    Parameters:");
                    foreach (ParameterInfo param in parameters)
                    {
                        Console.WriteLine($"      - {param.Name} (Type: {param.ParameterType.Name}, Optional: {param.IsOptional}, HasDefault: {param.HasDefaultValue})");
                        if (param.HasDefaultValue)
                        {
                            Console.WriteLine($"        Default Value: {param.DefaultValue ?? "null"}");
                        }
                    }
                }
                else
                {
                    Console.WriteLine("    No Parameters.");
                }
            }
        }
        else
        {
            Console.WriteLine("  No methods declared directly in this type.");
        }
    }

    public static void Run()
    {
        Console.WriteLine("--- Type Inspection via Reflection Example ---");

        InspectType(typeof(Person));
        InspectType(typeof(Employee)); // See inherited members and new members

        Console.WriteLine("\n--- End Type Inspection Example ---");
    }
}
```

**Output Observations from the Example:**

  * For `Person`: You'll see `FirstName`, `LastName`, `Species` (property), `_privateId` (field), `Greet`, `InternalLog`, `SayHello` (methods). Note the access modifiers and static/instance distinctions.
  * For `Employee`:
      * You'll see `EmployeeId` and `Salary` (properties) and `DoWork`, `GrantBonus` (methods) because we used `BindingFlags.DeclaredOnly`.
      * The `Person` class's members are *not* shown directly when using `DeclaredOnly` on `Employee`. If you remove `BindingFlags.DeclaredOnly`, you'd see all inherited public members as well.
      * `InternalLog("Working now...")` in `DoWork()` demonstrates that even though `InternalLog` is private in `Person`, `Employee` (as a derived class) can still call it *internally*. Reflection allows you to access it externally.

-----

### Interview Focus: Loading Assemblies, Exploring Object Structure, Plugin Discovery

Reflection is a cornerstone for many advanced scenarios in .NET development. Interview questions often revolve around these practical applications:

#### 1\. Loading Assemblies

**Concept:** Dynamically loading `.dll` files that are not referenced at compile time. This is crucial for extensibility, plugin architectures, and hot-swapping components.

**How:**

  * `Assembly.LoadFrom("path/to/assembly.dll")`: Loads an assembly from a specified path.
  * `Assembly.Load("AssemblyName")`: Loads an assembly by its simple name (it must be in the application's probing path or GAC).
  * `Assembly.Load(byte[] rawAssembly)`: Loads an assembly from a byte array (e.g., loaded from a database or network).

**Interview Focus:**

  * **Security Implications:** Loading untrusted assemblies can pose security risks. Consider using `Assembly.Load(byte[])` with sandboxing or isolating AppDomains (though AppDomains are largely deprecated in .NET Core/5+).
  * **Assembly Probing:** How the runtime locates assemblies.
  * **Versioning Conflicts (DLL Hell):** Strategies to mitigate issues when multiple versions of the same assembly are loaded.

**Code Example (Loading Assembly):**

```csharp
using System;
using System.Reflection;
using System.Linq;
using System.IO; // For file operations

public static class AssemblyLoaderExample
{
    public static void Run()
    {
        Console.WriteLine("\n--- Assembly Loading Example ---");

        // To demonstrate, let's try to load this very assembly
        // In a real scenario, this would be a separate DLL.
        string currentAssemblyPath = Assembly.GetExecutingAssembly().Location;
        Console.WriteLine($"Current assembly path: {currentAssemblyPath}");

        try
        {
            // Load an assembly (e.g., the current one for demonstration)
            // In a real scenario, this would be a path to a plugin DLL
            Assembly loadedAssembly = Assembly.LoadFrom(currentAssemblyPath);
            Console.WriteLine($"Successfully loaded assembly: {loadedAssembly.FullName}");

            // Now, you can inspect types within this loaded assembly
            Console.WriteLine("\n  Top 5 Types in Loaded Assembly:");
            foreach (Type type in loadedAssembly.GetTypes().Take(5))
            {
                Console.WriteLine($"    - {type.FullName}");
            }

            // You could even try to find a specific type and create an instance
            Type personType = loadedAssembly.GetType("ReflectionExamples.Person"); // Replace with actual namespace
            if (personType != null)
            {
                Console.WriteLine($"\n  Found type 'Person': {personType.FullName}");
                // You could now create an instance of Person dynamically
                // object personInstance = Activator.CreateInstance(personType, "John", "Doe");
            }
        }
        catch (FileNotFoundException)
        {
            Console.WriteLine("Error: Assembly not found at specified path.");
        }
        catch (BadImageFormatException)
        {
            Console.WriteLine("Error: The file is not a valid .NET assembly.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An error occurred during assembly loading: {ex.Message}");
        }

        Console.WriteLine("--- End Assembly Loading Example ---");
    }
}
```

#### 2\. Exploring Object Structure

**Concept:** At runtime, inspecting an object's properties, fields, and their values, even if you don't know the object's compile-time type. This is fundamental for debugging tools, serializers, and dynamic data binding.

**How:**

  * Get the object's `Type` using `myObject.GetType()`.
  * Use `Type.GetProperties()` and `Type.GetFields()` to get `PropertyInfo` and `FieldInfo` objects.
  * Use `PropertyInfo.GetValue(myObject)` and `FieldInfo.GetValue(myObject)` to read values.
  * Use `PropertyInfo.SetValue(myObject, value)` and `FieldInfo.SetValue(myObject, value)` to set values.

**Interview Focus:**

  * **Use Cases:** Debuggers, ORMs (Object-Relational Mappers), data binding in UI frameworks, custom serializers/deserializers (like the `[IgnoreSerialization]` example previously).
  * **Performance:** Understand that Reflection is slower than direct access. Caching `MemberInfo` objects and their attribute data is a common optimization.
  * **Security:** Accessing private members via Reflection can bypass encapsulation. This should be done with caution and understanding of the implications.

**Code Example (Exploring Object Structure):**

```csharp
using System;
using System.Reflection;
using System.Linq;

public class UserData
{
    public string Username { get; set; }
    private string _secretToken = "abc123xyz";
    public int Age { get; set; }
    public DateTime LastLogin { get; private set; }

    public UserData(string username, int age)
    {
        Username = username;
        Age = age;
        LastLogin = DateTime.Now; // Set by constructor, private setter
    }
}

public static class ObjectExplorerExample
{
    public static void ExploreObject(object obj)
    {
        if (obj == null)
        {
            Console.WriteLine("Cannot explore null object.");
            return;
        }

        Type type = obj.GetType();
        Console.WriteLine($"\n--- Exploring Object of Type: {type.FullName} ---");

        Console.WriteLine("\n  Properties:");
        // Get all properties, public and non-public, instance
        PropertyInfo[] properties = type.GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
        foreach (PropertyInfo prop in properties)
        {
            try
            {
                object value = prop.GetValue(obj);
                Console.WriteLine($"    - {prop.Name} ({prop.PropertyType.Name}): {value ?? "null"}");
            }
            catch (TargetParameterCountException)
            {
                // This can happen for indexed properties if not handled
                Console.WriteLine($"    - {prop.Name} ({prop.PropertyType.Name}): (Indexed Property)");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"    - {prop.Name} ({prop.PropertyType.Name}): Error reading value ({ex.Message})");
            }
        }

        Console.WriteLine("\n  Fields:");
        // Get all fields, public and non-public, instance
        FieldInfo[] fields = type.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance);
        foreach (FieldInfo field in fields)
        {
            try
            {
                object value = field.GetValue(obj);
                Console.WriteLine($"    - {field.Name} ({field.FieldType.Name}): {value ?? "null"}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"    - {field.Name} ({field.FieldType.Name}): Error reading value ({ex.Message})");
            }
        }
    }

    public static void Run()
    {
        Console.WriteLine("--- Object Structure Exploration Example ---");
        UserData user = new UserData("john_doe", 28);
        ExploreObject(user);

        // Demonstrate setting a private property (use with caution!)
        Console.WriteLine("\n--- Setting private property via Reflection ---");
        PropertyInfo lastLoginProp = typeof(UserData).GetProperty("LastLogin", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
        if (lastLoginProp != null && lastLoginProp.CanWrite)
        {
            DateTime newLoginTime = DateTime.UtcNow;
            lastLoginProp.SetValue(user, newLoginTime);
            Console.WriteLine($"  LastLogin updated to: {newLoginTime}");
        }
        else
        {
                Console.WriteLine("  Could not set LastLogin property (not found or not writable).");
        }

        // Demonstrate setting a private field (use with caution!)
        Console.WriteLine("\n--- Setting private field via Reflection ---");
        FieldInfo secretTokenField = typeof(UserData).GetField("_secretToken", BindingFlags.Instance | BindingFlags.NonPublic);
        if (secretTokenField != null)
        {
            secretTokenField.SetValue(user, "new_secret_token_456");
            Console.WriteLine("  _secretToken field updated.");
        }

        ExploreObject(user); // Re-explore to see changes

        Console.WriteLine("--- End Object Structure Exploration Example ---");
    }
}
```

#### 3\. Plugin Discovery

**Concept:** Identifying and loading components (plugins) from external assemblies based on certain criteria, typically custom attributes or interface implementations. This is a powerful pattern for extensible applications where users or developers can add new functionality without recompiling the main application.

**How:**

1.  **Define a Contract (Interface or Base Class):** Plugins should implement a common interface (e.g., `IPlugin`) or inherit from a base class.
2.  **Define a Discovery Attribute (Optional but common):** A custom attribute (e.g., `[PluginAttribute]`) can mark classes that are intended to be plugins, often including metadata like plugin name, version, or description.
3.  **Scan Assemblies:** Load assemblies (as described above) from a known plugin directory.
4.  **Inspect Types:** For each loaded `Assembly`, iterate through its `GetTypes()`.
5.  **Filter/Instantiate:**
      * Check if a `Type` implements the `IPlugin` interface: `typeof(IPlugin).IsAssignableFrom(type)`.
      * Check if a `Type` has the `[PluginAttribute]`: `type.GetCustomAttribute<PluginAttribute>()`.
      * Filter for concrete classes (not abstract, not interfaces).
      * Instantiate discovered plugins using `Activator.CreateInstance(type)`.

**Interview Focus:**

  * **`AppDomain.CurrentDomain.GetAssemblies()`**: To get already loaded assemblies.
  * **`Type.IsAbstract`, `Type.IsInterface`, `Type.IsClass`**: For filtering.
  * **`Activator.CreateInstance()`**: For creating instances dynamically.
  * **Error Handling:** Robust error handling for cases where plugin assemblies are missing, corrupt, or contain invalid types.
  * **Dependency Management:** How plugins resolve their own dependencies (e.g., using a separate DI container or assembly probing).

**Code Example (Plugin Discovery):**

```csharp
using System;
using System.Reflection;
using System.Linq;
using System.Collections.Generic;
using System.IO;

// 1. Define the Plugin Contract
public interface ICalculatorPlugin
{
    string Name { get; }
    string Description { get; }
    int Calculate(int a, int b);
}

// 2. Define a Discovery Attribute (Optional, but good for metadata)
[AttributeUsage(AttributeTargets.Class)]
public class PluginInfoAttribute : Attribute
{
    public string DisplayName { get; }
    public string Version { get; set; }
    public PluginInfoAttribute(string displayName) => DisplayName = displayName;
}

// 3. Simulate a Plugin (would typically be in a separate DLL)
// For demonstration, we'll define it in the same assembly.
// In a real scenario, you'd compile this into 'MyCalculatorPlugin.dll'
// and load it dynamically.
[PluginInfo("Addition Calculator", Version = "1.0")]
public class AdditionPlugin : ICalculatorPlugin
{
    public string Name => "Addition";
    public string Description => "Adds two numbers.";
    public int Calculate(int a, int b) => a + b;
}

[PluginInfo("Multiplication Calculator", Version = "1.1")]
public class MultiplicationPlugin : ICalculatorPlugin
{
    public string Name => "Multiplication";
    public string Description => "Multiplies two numbers.";
    public int Calculate(int a, int b) => a * b;
}


public static class PluginDiscoveryExample
{
    public static void Run()
    {
        Console.WriteLine("\n--- Plugin Discovery Example ---");

        List<ICalculatorPlugin> discoveredPlugins = new List<ICalculatorPlugin>();

        // In a real application, you would scan a "Plugins" directory:
        // string pluginDirectory = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Plugins");
        // if (Directory.Exists(pluginDirectory))
        // {
        //     foreach (string dllFile in Directory.GetFiles(pluginDirectory, "*.dll"))
        //     {
        //         try { Assembly assembly = Assembly.LoadFrom(dllFile); ProcessAssembly(assembly, discoveredPlugins); }
        //         catch (Exception ex) { Console.WriteLine($"Could not load assembly {dllFile}: {ex.Message}"); }
        //     }
        // }

        // For this example, we'll scan the current executing assembly
        // as if it contains the plugins.
        ProcessAssembly(Assembly.GetExecutingAssembly(), discoveredPlugins);

        Console.WriteLine($"\nDiscovered {discoveredPlugins.Count} calculator plugins:");
        foreach (var plugin in discoveredPlugins)
        {
            PluginInfoAttribute pluginInfo = plugin.GetType().GetCustomAttribute<PluginInfoAttribute>();
            Console.WriteLine($"- Plugin: {plugin.Name} (DisplayName: {pluginInfo?.DisplayName ?? "N/A"}, Version: {pluginInfo?.Version ?? "N/A"})");
            Console.WriteLine($"  Description: {plugin.Description}");
            Console.WriteLine($"  Example: 5 + 3 = {plugin.Calculate(5, 3)}");
        }

        Console.WriteLine("--- End Plugin Discovery Example ---");
    }

    private static void ProcessAssembly(Assembly assembly, List<ICalculatorPlugin> plugins)
    {
        Console.WriteLine($"\nScanning assembly: {assembly.FullName}");
        foreach (Type type in assembly.GetTypes())
        {
            // Check if the type is a concrete class
            if (type.IsClass && !type.IsAbstract && !type.IsGenericTypeDefinition)
            {
                // Check if it implements the ICalculatorPlugin interface
                if (typeof(ICalculatorPlugin).IsAssignableFrom(type))
                {
                    // Optionally check for the PluginInfoAttribute if you need it for discovery criteria
                    if (type.GetCustomAttribute<PluginInfoAttribute>() != null)
                    {
                        try
                        {
                            ICalculatorPlugin plugin = (ICalculatorPlugin)Activator.CreateInstance(type);
                            plugins.Add(plugin);
                            Console.WriteLine($"  Found plugin: {type.Name}");
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"  Error creating instance of plugin {type.Name}: {ex.Message}");
                        }
                    }
                    else
                    {
                        Console.WriteLine($"  Skipping {type.Name}: Missing PluginInfoAttribute.");
                    }
                }
            }
        }
    }
}
```

This example shows how to load an assembly (or iterate the current one), find types that match certain criteria (interface implementation and attribute presence), and then dynamically create instances of those types, enabling a flexible plugin architecture.