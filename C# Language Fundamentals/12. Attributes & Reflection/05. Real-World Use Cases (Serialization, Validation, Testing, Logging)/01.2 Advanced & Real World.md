Today, July 16, 2025, let's continue our deep dive into the practical application of Reflection and Attributes, specifically focusing on how they enable the creation of powerful, metadata-driven frameworks for common software engineering tasks.

-----

### ðŸ”¹ Youâ€™re building a mini-ORM. How would you use attributes and reflection to map C\# classes to table/column names?

(Use `[Table("Users")]`, `[Column("FirstName")]`, and access them via `GetCustomAttributes()` during mapping.)

**Explanation:**

Object-Relational Mappers (ORMs) bridge the gap between object-oriented code and relational databases. They automate the process of mapping C\# classes (entities) to database tables and their properties to table columns. Attributes and Reflection are fundamental to this mapping.

**ORM Mapping Flow with Attributes:**

1.  **Define Mapping Attributes:** Create custom attributes (e.g., `[Table]`, `[Column]`) that allow developers to specify database-specific metadata directly on their C\# classes and properties.
      * `[Table("TableName")]`: Applied to a class, specifying the database table name.
      * `[Column("ColumnName")]`: Applied to a property, specifying the database column name.
      * (Optional) `[Key]`, `[Required]`, `[NotMapped]`, etc., for more complex mapping.
2.  **Reflective Discovery at Runtime:** When the ORM needs to perform an operation (e.g., generate a `SELECT` statement, load data):
      * **Get Class Type:** Obtain the `System.Type` of the C\# entity class.
      * **Read `[Table]` Attribute:** Use `type.GetCustomAttribute<TableAttribute>()` to get the table name. If no `[Table]` attribute is found, the ORM might default to using the class name.
      * **Read Property `[Column]` Attributes:** Iterate through `type.GetProperties(BindingFlags.Public | BindingFlags.Instance)`. For each `PropertyInfo`:
          * Use `property.GetCustomAttribute<ColumnAttribute>()` to get the column name.
          * If no `[Column]` attribute is found, the ORM typically defaults to using the property name.
          * Handle `[NotMapped]` (if present) to exclude properties from mapping.
      * **Identify Primary Keys:** Look for `[Key]` attributes to identify primary key columns.
      * **Determine Data Types:** Use `property.PropertyType` to infer the corresponding database column type, or use a custom `[DbType]` attribute.
3.  **Construct SQL/Perform Mapping:** Use the gathered metadata to dynamically construct SQL queries (e.g., `SELECT Id AS MyId, Name AS MyName FROM Users`) or map incoming data rows to object instances.

**Code Example:**

```csharp
using System;
using System.Reflection;
using System.Linq;
using System.Collections.Generic;

// 1. Define custom mapping attributes
[AttributeUsage(AttributeTargets.Class, Inherited = false)]
public class TableAttribute : Attribute
{
    public string Name { get; }
    public TableAttribute(string name) => Name = name;
}

[AttributeUsage(AttributeTargets.Property, Inherited = false)]
public class ColumnAttribute : Attribute
{
    public string Name { get; }
    public ColumnAttribute(string name) => Name = name;
}

[AttributeUsage(AttributeTargets.Property, Inherited = false)]
public class PrimaryKeyAttribute : Attribute { }

[AttributeUsage(AttributeTargets.Property, Inherited = false)]
public class NotMappedAttribute : Attribute { }

// 2. Define an entity class with mapping attributes
[Table("AppUsers")] // Maps to 'AppUsers' table
public class User
{
    [PrimaryKey] // Marks as primary key
    [Column("UserID")] // Maps to 'UserID' column
    public int Id { get; set; }

    [Column("UserName")] // Maps to 'UserName' column
    public string Name { get; set; }

    public string Email { get; set; } // Defaults to 'Email' column

    [NotMapped] // This property should not be mapped to a database column
    public string PasswordHash { get; set; }

    // Private field - not mapped by default GetProperties
    private string _internalNote = "Not DB data";
}

// 3. Mini-ORM Mapper (simulated)
public static class MiniOrmMapper
{
    public static string GetTableName(Type entityType)
    {
        var tableAttr = entityType.GetCustomAttribute<TableAttribute>();
        return tableAttr?.Name ?? entityType.Name; // Default to class name
    }

    public static Dictionary<string, string> GetColumnMappings(Type entityType)
    {
        var mappings = new Dictionary<string, string>();
        foreach (PropertyInfo prop in entityType.GetProperties(BindingFlags.Public | BindingFlags.Instance))
        {
            if (prop.GetCustomAttribute<NotMappedAttribute>() != null)
            {
                continue; // Skip properties marked as NotMapped
            }

            var columnAttr = prop.GetCustomAttribute<ColumnAttribute>();
            string columnName = columnAttr?.Name ?? prop.Name; // Default to property name
            mappings[prop.Name] = columnName; // C# Property Name -> DB Column Name
        }
        return mappings;
    }

    public static string GetPrimaryKeyColumn(Type entityType)
    {
        foreach (PropertyInfo prop in entityType.GetProperties(BindingFlags.Public | BindingFlags.Instance))
        {
            if (prop.GetCustomAttribute<PrimaryKeyAttribute>() != null)
            {
                var columnAttr = prop.GetCustomAttribute<ColumnAttribute>();
                return columnAttr?.Name ?? prop.Name;
            }
        }
        return null; // No primary key found
    }

    public static void Run()
    {
        Console.WriteLine("--- Mini-ORM Mapping Example ---");

        Type userType = typeof(User);

        string tableName = GetTableName(userType);
        Console.WriteLine($"\nMapped Table Name: {tableName}");

        Dictionary<string, string> columnMappings = GetColumnMappings(userType);
        Console.WriteLine("Column Mappings (C# Property -> DB Column):");
        foreach (var mapping in columnMappings)
        {
            Console.WriteLine($"  {mapping.Key} -> {mapping.Value}");
        }

        string primaryKey = GetPrimaryKeyColumn(userType);
        Console.WriteLine($"Primary Key Column: {primaryKey ?? "Not found"}");

        // Simulate generating a SELECT statement
        string selectColumns = string.Join(", ", columnMappings.Select(kv => $"{kv.Value} AS {kv.Key}"));
        Console.WriteLine($"\nSimulated SQL SELECT: SELECT {selectColumns} FROM {tableName}");

        Console.WriteLine("--- End Mini-ORM Mapping Example ---");
    }
}
```

This example illustrates how a mini-ORM would use custom attributes and Reflection to discover the mapping conventions, allowing flexible configuration of database schema interaction.

-----

### ðŸ”¹ You want to implement custom validation using `[Required]`, `[Range]`, etc. How do you enforce those rules at runtime?

(Use reflection to read property attributes, then invoke their validation logic manually or via a shared interface.)

**Explanation:**

As discussed previously under "Validation Frameworks," Reflection is crucial for implementing custom validation based on attributes. The `System.ComponentModel.DataAnnotations` namespace provides a standard set of validation attributes and a base class, `ValidationAttribute`, which significantly simplifies this.

**Enforcement Flow:**

1.  **Define/Use Validation Attributes:**
      * Use built-in attributes like `[Required]`, `[StringLength]`, `[Range]`, `[EmailAddress]`.
      * Create custom validation attributes by inheriting from `ValidationAttribute` and overriding `IsValid()` (as shown in the previous example).
2.  **Validation Logic (`Validator` Utility):**
      * Create a static `Validator` utility class (or method).
      * It takes an object instance to validate.
      * **Get Properties:** Use `instance.GetType().GetProperties()` to get all public instance properties.
      * **Read Attributes:** For each `PropertyInfo`, call `property.GetCustomAttributes<ValidationAttribute>()` to retrieve all validation attributes applied to it.
      * **Invoke Validation:** For each `ValidationAttribute`, call its `GetValidationResult(value, validationContext)` method (or `IsValid()`).
          * Pass the property's value (`property.GetValue(instance)`).
          * Pass a `ValidationContext` object, which provides context like the property's name.
      * **Collect Results:** Collect any `ValidationResult` objects that are not `ValidationResult.Success`.

**Code Example:**

The code example provided in the previous section under "Validation Frameworks" fully demonstrates this. The `Validator.Validate(object instance)` method perfectly illustrates how Reflection is used to find attributes, extract values, and invoke the validation logic.

```csharp
// (Reusing the code from the previous explanation)
// Refer to the 'Validation Example' section above.
// The 'Validator.Validate(object instance)' method is the core.
```

-----

### ðŸ”¹ In a logger, how would you auto-log all public methods marked with `[LogExecution]`?

(Intercept calls (via AOP or proxy), detect `[LogExecution]` via reflection, and log method name, parameters, duration.)

**Explanation:**

Auto-logging method execution is a common AOP (Aspect-Oriented Programming) scenario. While pure Reflection can inspect attributes, to *intercept* method calls without modifying the target class, you need more advanced techniques like AOP frameworks or dynamic proxies.

**Auto-Logging Flow:**

1.  **Define `[LogExecution]` Attribute:** A simple custom attribute to mark methods for logging.
2.  **Method Interception (The Hard Part without a Framework):**
      * **Dynamic Proxy:** Create a proxy class at runtime that inherits from the target class (or implements its interfaces). Override/implement all methods. Before calling the actual method, check for `[LogExecution]` on the original `MethodInfo`.
      * **AOP Frameworks (e.g., PostSharp, Castle Windsor's DynamicProxy):** These frameworks simplify interception. You define an "aspect" (e.g., a logging aspect) and configure it to apply to methods with `[LogExecution]`. The framework then instruments your code (at compile time or runtime) to insert the logging logic.
3.  **Inside the Interceptor/Proxy:**
      * **Detect Attribute:** Get the `MethodInfo` of the currently executing method (via the interception context). Check if `methodInfo.GetCustomAttribute<LogExecutionAttribute>() != null`.
      * **Log Before:** If detected, log the method name and parameters (`methodInfo.Name`, `methodInfo.GetParameters()`, and their values).
      * **Execute Method:** Call the original method (`invocation.Proceed()` in AOP frameworks, or `base.Method()` in manual proxies).
      * **Log After/Duration:** Capture the execution time. Log completion or exceptions.

**Interview Focus:**

  * **AOP Concepts:** This highlights the need for AOP to implement cross-cutting concerns like logging without scattering code.
  * **Dynamic Proxies:** Understanding how `System.Reflection.Emit` or libraries like Castle DynamicProxy create types at runtime.
  * **Trade-offs:** Performance overhead of interception vs. maintainability benefits.
  * **Alternatives:** Source Generators (.NET 5+) can achieve similar results with compile-time code generation, reducing runtime overhead.

**Code Example (Conceptual with a very simplified manual proxy for illustration):**

```csharp
using System;
using System.Reflection;
using System.Diagnostics; // For Stopwatch
using System.Linq;

// 1. Define the attribute
[AttributeUsage(AttributeTargets.Method)]
public class LogExecutionAttribute : Attribute { }

// 2. Original Service (could be an interface and implementation)
public class DataService
{
    [LogExecution]
    public virtual string GetUserData(int userId) // Must be virtual for simple dynamic proxy
    {
        Console.WriteLine($"    [DataService] Fetching user data for ID: {userId}");
        System.Threading.Thread.Sleep(50); // Simulate work
        return $"User_{userId}_Data";
    }

    [LogExecution]
    public virtual void SaveData(string data) // Must be virtual
    {
        Console.WriteLine($"    [DataService] Saving data: {data}");
        System.Threading.Thread.Sleep(20);
    }

    public void DoSomethingElse() // Not marked, so not logged
    {
        Console.WriteLine("    [DataService] Doing something else (not logged).");
    }
}

// 3. A very simplified, manually-coded dynamic proxy base
// In real AOP, frameworks generate this. This is just for demonstration.
public abstract class LogProxyBase<T> : DispatchProxy
{
    private T _decorated;

    // This method is called by the runtime when creating the proxy
    protected override object Invoke(MethodInfo targetMethod, object[] args)
    {
        // 1. Detect [LogExecution] attribute on the original method
        // (Note: DispatchProxy's targetMethod is the base method, not the derived)
        MethodInfo originalMethod = _decorated.GetType().GetMethod(
            targetMethod.Name,
            BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly,
            null,
            targetMethod.GetParameters().Select(p => p.ParameterType).ToArray(),
            null
        );

        bool logExecution = originalMethod?.GetCustomAttribute<LogExecutionAttribute>() != null;

        if (logExecution)
        {
            Console.WriteLine($"\n[LogInterceptor] Starting method: {originalMethod.Name}");
            Console.WriteLine($"  Parameters: {string.Join(", ", args ?? new object[0])}");
        }

        Stopwatch sw = Stopwatch.StartNew();
        object result = null;
        Exception thrownException = null;

        try
        {
            // Execute the original method on the decorated instance
            result = targetMethod.Invoke(_decorated, args);
        }
        catch (TargetInvocationException tie)
        {
            thrownException = tie.InnerException;
            throw thrownException; // Re-throw the inner exception
        }
        catch (Exception ex)
        {
            thrownException = ex;
            throw;
        }
        finally
        {
            sw.Stop();
            if (logExecution)
            {
                if (thrownException != null)
                {
                    Console.WriteLine($"[LogInterceptor] Method '{originalMethod.Name}' FAILED in {sw.ElapsedMilliseconds}ms with: {thrownException.Message}");
                }
                else
                {
                    Console.WriteLine($"[LogInterceptor] Finished method '{originalMethod.Name}' in {sw.ElapsedMilliseconds}ms. Result: {result}");
                }
            }
        }
        return result;
    }

    // Helper to create the proxy instance
    public static T Create(T decorated)
    {
        object proxy = DispatchProxy.Create<T, LogProxyBase<T>>();
        ((LogProxyBase<T>)proxy)._decorated = decorated;
        return (T)proxy;
    }
}

public static class AutoLoggingExample
{
    public static void Run()
    {
        Console.WriteLine("--- Auto-Logging with [LogExecution] Example ---");

        DataService originalService = new DataService();
        // Create a proxied version of the service
        DataService proxiedService = LogProxyBase<DataService>.Create(originalService);

        proxiedService.GetUserData(123);
        proxiedService.SaveData("some important data");
        proxiedService.DoSomethingElse(); // This method should not be logged by the interceptor

        // Demonstrate exception logging
        try
        {
            proxiedService.SaveData(null); // This might cause an exception in a real scenario
        }
        catch (Exception ex)
        {
            Console.WriteLine($"\nCaught exception during SaveData(null): {ex.Message}");
        }

        Console.WriteLine("--- End Auto-Logging Example ---");
    }
}
```

This example, leveraging `DispatchProxy` (available in .NET Standard 2.0+), provides a glimpse into how method calls can be intercepted at runtime to apply cross-cutting concerns like logging, driven by attributes and Reflection.

-----

### ðŸ”¹ You want to exclude sensitive properties from audit logs. How can `[SensitiveData]` help?

(Use reflection to inspect attributes on properties, and skip or mask them during logging.)

**Explanation:**

When implementing audit logging, you often need to prevent sensitive information (passwords, credit card numbers, PII) from being logged in plain text. A `[SensitiveData]` attribute provides a clear, declarative way to mark such properties.

**Exclusion Flow:**

1.  **Define `[SensitiveData]` Attribute:** A simple marker attribute.
2.  **Audit Logger/Formatter Logic:**
      * When constructing an audit log entry for an object, get its `Type`.
      * Iterate through `Type.GetProperties()`.
      * For each `PropertyInfo`, check if `property.GetCustomAttribute<SensitiveDataAttribute>() != null`.
      * If the attribute is present:
          * **Mask Value:** Replace the actual property value with a placeholder (e.g., "***REDACTED***" or a hash).
          * **Skip Logging:** Completely exclude the property from the log entry.
      * If the attribute is *not* present, log the property's actual value.

**Interview Focus:**

  * **Security & Compliance:** This is a crucial aspect of building secure and compliant applications.
  * **Declarative Configuration:** Attributes simplify configuration for developers, making it explicit which data is sensitive.
  * **Centralized Logic:** The masking/skipping logic is centralized in the logging/auditing component, not scattered throughout the business logic.

**Code Example:**

```csharp
using System;
using System.Reflection;
using System.Collections.Generic;
using System.Linq;
using System.Text;

// 1. Define the [SensitiveData] attribute
[AttributeUsage(AttributeTargets.Property)]
public class SensitiveDataAttribute : Attribute { }

public class UserAccount
{
    public int Id { get; set; }
    public string Username { get; set; }

    [SensitiveData] // Mark this property as sensitive
    public string Password { get; set; }

    [SensitiveData] // Another sensitive property
    public string CreditCardNumber { get; set; }

    public string Email { get; set; }
    public DateTime LastLogin { get; set; }
}

public static class AuditLogger
{
    public static string CreateAuditLog(object obj)
    {
        if (obj == null) return "[NULL Object]";

        Type type = obj.GetType();
        var sb = new StringBuilder();
        sb.AppendLine($"Audit Log for {type.Name}:");
        sb.AppendLine("{");

        foreach (PropertyInfo prop in type.GetProperties(BindingFlags.Public | BindingFlags.Instance))
        {
            // Check if the property has the [SensitiveData] attribute
            bool isSensitive = prop.GetCustomAttribute<SensitiveDataAttribute>() != null;

            object value = prop.GetValue(obj);
            string formattedValue = isSensitive ? "***REDACTED***" : value?.ToString();

            sb.AppendLine($"  {prop.Name}: {formattedValue}");
        }
        sb.AppendLine("}");
        return sb.ToString();
    }

    public static void Run()
    {
        Console.WriteLine("--- Excluding Sensitive Properties from Audit Logs ---");

        UserAccount account = new UserAccount
        {
            Id = 101,
            Username = "johndoe",
            Password = "MySecretPassword123",
            CreditCardNumber = "1234-5678-9012-3456",
            Email = "john.doe@example.com",
            LastLogin = DateTime.Now
        };

        string auditLog = CreateAuditLog(account);
        Console.WriteLine(auditLog);

        Console.WriteLine("--- End Excluding Sensitive Properties Example ---");
    }
}
```

The output will show `Password` and `CreditCardNumber` as `***REDACTED***`, effectively demonstrating the use of `[SensitiveData]` to control logging behavior.

-----

### ðŸ”¹ You wrote a `[MaxLength]` attribute for form input. What design pattern helps centralize validation logic for such metadata?

(Use the Strategy Pattern or Attribute Base Class with `Validate()` method â€” supports pluggable validation logic.)

**Explanation:**

When designing a validation system driven by attributes, you want to avoid scattering validation logic throughout your application. The Strategy Pattern (or a similar approach using a common base class for attributes) is ideal for centralizing and making validation rules pluggable.

**Design Pattern for Validation:**

1.  **`ValidationAttribute` (Base Class/Interface):** This is the core. In .NET, `System.ComponentModel.DataAnnotations.ValidationAttribute` is exactly this. It defines the contract for all validation attributes (`IsValid()` method).
2.  **Concrete Strategy (Individual Attributes):** Each specific validation rule (e.g., `RequiredAttribute`, `RangeAttribute`, `MaxLengthAttribute`, `MustBeEvenAttribute`) becomes a concrete strategy, inheriting from the base `ValidationAttribute` and implementing its `IsValid()` method.
3.  **Context (The Validator):** The `Validator` class (as shown in previous examples) acts as the context. It:
      * Receives an object to validate.
      * Uses Reflection to discover all `ValidationAttribute` instances on the object's properties.
      * Delegates the actual validation logic to the `IsValid()` method of each discovered attribute (strategy).
      * Collects the results.

**Why this pattern?**

  * **Centralization:** All validation logic for a specific rule lives within its own attribute class, not in your business logic.
  * **Decoupling:** The validation framework is decoupled from the specific validation rules. It just knows how to find and execute `ValidationAttribute` instances.
  * **Extensibility:** To add a new validation rule, you simply create a new custom attribute inheriting from `ValidationAttribute` and implement `IsValid()`. No changes are needed to the `Validator` itself.
  * **Reusability:** Validation attributes can be reused across different models and projects.

**Code Example:**

The `ValidationExample` code provided earlier demonstrates this pattern perfectly.

```csharp
// (Reusing the code from the previous explanation)
// Refer to the 'Validation Example' section above.
// The relationship between `ValidationAttribute` (base class strategy),
// `RequiredAttribute`, `StringLengthAttribute`, `MustBeEvenAttribute` (concrete strategies),
// and the `Validator` class (context) exemplifies this.
```

-----

### ðŸ”¹ You use `[Display(Name = "...")]` attributes. How can you dynamically generate UI labels from them in a form generator?

(Read the `DisplayAttribute.Name` from each property and render it as a field label in the generated form.)

**Explanation:**

Attributes like `[Display]` are widely used in UI frameworks (ASP.NET MVC/Blazor, WPF) to provide metadata for rendering UI elements. A form generator can leverage Reflection to read this metadata and create dynamic forms.

**UI Generation Flow:**

1.  **Model Definition:** Define your data model classes with properties decorated with `[Display]` (and potentially other UI-related attributes like `[DataType]`, `[UIHint]`).
2.  **Form Generator:**
      * The form generator receives a `Type` object representing the model class.
      * It iterates through `modelType.GetProperties()`.
      * For each `PropertyInfo`:
          * **Get Label:** Use `property.GetCustomAttribute<DisplayAttribute>()`. If found, use `displayAttribute.Name` as the label. If not found, default to `property.Name` (e.g., by converting "FirstName" to "First Name").
          * **Get Input Type:** Use `property.PropertyType` (e.g., `typeof(string)` for a text input, `typeof(bool)` for a checkbox).
          * **Get Validation Rules:** (Optional) Also read validation attributes (`[Required]`, `[StringLength]`) to generate client-side validation logic or display asterisks for required fields.
      * **Render UI:** Dynamically generate HTML (or XAML, etc.) for a label and an input field based on the gathered information.

**Interview Focus:**

  * **Metadata-Driven UI:** How attributes drive UI rendering without hardcoding layouts.
  * **DRY Principle:** Avoids duplicating UI labels and validation rules in different places.
  * **Extensibility:** Easily add new display options or input types by creating custom attributes and updating the generator.

**Code Example:**

```csharp
using System;
using System.Reflection;
using System.ComponentModel.DataAnnotations; // For [Display]
using System.Linq;

public class UserSettings
{
    [Display(Name = "User ID")] // Custom display name
    public int Id { get; set; }

    [Display(Name = "Full Name")] // Custom display name
    public string UserName { get; set; }

    public bool IsActive { get; set; } // No DisplayAttribute, will use property name

    [Display(Name = "Preferred Language")]
    public string Language { get; set; }
}

public static class FormGenerator
{
    public static void GenerateHtmlForm(Type modelType)
    {
        Console.WriteLine($"--- Dynamically Generating Form for {modelType.Name} ---");
        Console.WriteLine($"<form>");

        foreach (PropertyInfo prop in modelType.GetProperties(BindingFlags.Public | BindingFlags.Instance))
        {
            string labelText = prop.Name; // Default label is property name
            string inputType = "text";   // Default input type

            // Get [Display] attribute
            DisplayAttribute displayAttr = prop.GetCustomAttribute<DisplayAttribute>();
            if (displayAttr != null && !string.IsNullOrEmpty(displayAttr.Name))
            {
                labelText = displayAttr.Name;
            }

            // Determine input type based on PropertyType
            if (prop.PropertyType == typeof(bool))
            {
                inputType = "checkbox";
            }
            else if (prop.PropertyType == typeof(int) || prop.PropertyType == typeof(decimal))
            {
                inputType = "number";
            }
            // Add more type mappings as needed (e.g., DateTime -> date, password -> password)

            Console.WriteLine($"  <div>");
            Console.WriteLine($"    <label for=\"{prop.Name}\">{labelText}:</label>");
            Console.WriteLine($"    <input type=\"{inputType}\" id=\"{prop.Name}\" name=\"{prop.Name}\" />");
            Console.WriteLine($"  </div>");
        }

        Console.WriteLine($"  <div>");
        Console.WriteLine($"    <button type=\"submit\">Submit</button>");
        Console.WriteLine($"  </div>");
        Console.WriteLine($"</form>");
        Console.WriteLine("--- End Form Generation ---");
    }

    public static void Run()
    {
        GenerateHtmlForm(typeof(UserSettings));
    }
}
```

This example shows how Reflection, combined with `[Display]` attributes, can be used to generate UI elements dynamically.

-----

### ðŸ”¹ How can attribute-based reflection help in building a lightweight dependency injection container?

(Use attributes like `[Inject]` or `[Singleton]` to mark injectable members or lifetimes, then wire dependencies at runtime via reflection.)

**Explanation:**

As previously discussed, DI containers heavily rely on Reflection for runtime dependency resolution. Attributes can further enhance their flexibility by providing declarative configuration for injection points and object lifetimes.

**Attribute-Driven DI Flow:**

1.  **Define DI Attributes:**
      * `[InjectAttribute]`: Marks the preferred constructor for injection, or properties/methods that should receive dependencies after construction (constructor injection is generally preferred).
      * `[SingletonAttribute]`, `[ScopedAttribute]`, `[TransientAttribute]`: Marks the desired lifetime for a registered service (e.g., only one instance for the application, one instance per request, or a new instance every time).
2.  **Container Registration:** Developers register their services with the container.
3.  **Resolution Process (using Reflection & Attributes):**
      * When a type is requested, the container gets its `System.Type`.
      * **Constructor Selection:**
          * It scans all constructors using `Type.GetConstructors()`.
          * It prioritizes the constructor marked with `[Inject]`.
          * If no `[Inject]` is found, it might fall back to the "greedy" strategy (most resolvable parameters).
      * **Lifetime Management:** It checks the class's `Type` for `[Singleton]`, `[Scoped]`, or `[Transient]` attributes to determine how to manage instances.
          * If `[Singleton]`, it creates the instance once and stores it.
          * If `[Transient]`, it creates a new instance every time.
      * **Property/Method Injection (Optional):** After creating the instance via constructor, it might iterate through properties and methods, looking for `[Inject]` attributes, and then use `PropertyInfo.SetValue()` or `MethodInfo.Invoke()` to inject additional dependencies.
      * **Instance Creation:** Finally, it uses `ConstructorInfo.Invoke()` to create the object instance with its resolved dependencies.

**Interview Focus:**

  * **Declarative Configuration:** Attributes move configuration from external files or fluent APIs directly into the code, making the intent clear.
  * **Flexibility:** Easily swap implementations or change lifetimes by just changing an attribute.
  * **Concerns:** Runtime overhead (can be mitigated by caching or source generators), potential for misuse if not well-defined.

**Code Example (Reusing and extending previous DI example):**

The `SimpleDIContainer` from the previous section already demonstrates attribute-based constructor selection. The key elements are:

  * **`[InjectAttribute]`**: Used to explicitly mark a constructor.
  * **`container.Resolve(Type typeToResolve)`**: The core method that finds constructors and checks for `[InjectAttribute]` first.
  * `ConstructorInfo chosenConstructor = constructors.FirstOrDefault(c => c.GetCustomAttribute<InjectAttribute>() != null);`

To add `[Singleton]` or `[Transient]` attributes, you would extend the `SimpleContainer` to:

1.  Define `[SingletonAttribute]` and `[TransientAttribute]`.
2.  In the `Resolve` method, after selecting `implementationType` but *before* creating the instance, check `implementationType.GetCustomAttribute<SingletonAttribute>()`. If present, store the instance in a dictionary and return the stored instance on subsequent calls. Otherwise, always create a new one.

This covers the critical concepts of attribute-driven frameworks, illustrating how attributes provide declarative metadata that Reflection uses to drive powerful, flexible, and extensible runtime behavior.