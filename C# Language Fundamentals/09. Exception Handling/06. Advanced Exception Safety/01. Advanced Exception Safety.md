The user wants an explanation of "Advanced Exception Safety" with code examples. This involves discussing:

  * **`IDisposable` and `using` statements:** How they ensure resource cleanup even when exceptions occur.
  * **Finalizers:** Their role in resource management, particularly for unmanaged resources, and their interaction with exceptions (though they are generally discouraged for managed resources).
  * **Asynchronous Exceptions:** How exceptions behave in `async`/`await` contexts, including handling, propagation, and `Task.Exception`.
  * **`AggregateException`:** When and why it's used (especially with `Task.Wait`, `Task.Result`, and Parallel LINQ).
  * **Fault Resilience (using Polly as an example):** Briefly touch upon patterns like retry, circuit breaker, and bulkhead for handling transient faults gracefully, which are an advanced form of exception handling.

I'll provide detailed explanations and C\# code examples for each of these points.

-----

### Advanced Exception Safety

Advanced exception safety focuses on designing and implementing code that behaves correctly and predictably even in the presence of exceptions. This goes beyond simple `try-catch` blocks and delves into robust resource management, asynchronous error handling, and building resilient systems.

-----

### 1\. `IDisposable` and `using` Statements

**Focus:** Ensuring resource cleanup (especially unmanaged resources) when exceptions occur.

**Explanation:**

In .NET, many resources (like file handles, network connections, database connections, graphics objects) consume limited system resources. If these resources aren't explicitly released, they can lead to resource leaks, performance degradation, or even system crashes.

The `IDisposable` interface provides a standard mechanism for releasing unmanaged resources (or managed resources that wrap unmanaged ones). Classes that implement `IDisposable` typically have a `Dispose()` method.

The `using` statement (a C\# language construct) is the cornerstone of exception-safe resource management for `IDisposable` objects. It ensures that the `Dispose()` method is called automatically, even if an exception occurs within the `using` block. The compiler translates the `using` statement into a `try-finally` block, where the `Dispose()` call is placed in the `finally` block.

**Why it's Exception-Safe:**

Because `Dispose()` is called within a `finally` block, it guarantees that the resource will be released whether the code in the `using` block completes successfully or throws an exception.

**Code Example:**

```csharp
using System;
using System.IO;

public static class DisposableExample
{
    public static void Run()
    {
        Console.WriteLine("--- IDisposable and using Statement ---");

        // Scenario 1: Using statement with no exception
        Console.WriteLine("\nScenario 1: No exception");
        try
        {
            ProcessFile("data.txt", false);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Caught unexpected exception: {ex.Message}");
        }

        // Scenario 2: Using statement with an exception
        Console.WriteLine("\nScenario 2: Exception occurs inside using block");
        try
        {
            ProcessFile("data.txt", true); // This will cause an exception
        }
        catch (InvalidOperationException ex)
        {
            Console.WriteLine($"Caught expected exception: {ex.Message}");
            Console.WriteLine("File stream was still closed by 'using' statement.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Caught unexpected exception: {ex.Message}");
        }

        Console.WriteLine();
    }

    public static void ProcessFile(string fileName, bool throwException)
    {
        // The using statement ensures stream.Dispose() is called even if an exception occurs.
        using (FileStream stream = new FileStream(fileName, FileMode.Create, FileAccess.Write))
        {
            Console.WriteLine($"  FileStream opened for '{fileName}'.");
            byte[] data = System.Text.Encoding.UTF8.GetBytes("Hello, world!");
            stream.Write(data, 0, data.Length);
            Console.WriteLine("  Data written to file.");

            if (throwException)
            {
                Console.WriteLine("  Throwing InvalidOperationException...");
                throw new InvalidOperationException("Simulated error during file processing.");
            }

            Console.WriteLine("  File processing complete.");
        } // stream.Dispose() is implicitly called here
        Console.WriteLine($"  FileStream for '{fileName}' is now guaranteed to be closed.");
    }
}
```

-----

### 2\. Finalizers

**Focus:** Last-resort cleanup for unmanaged resources.

**Explanation:**

A finalizer (also known as a destructor in C++) is a special method in C\# (`~ClassName()`) that the garbage collector (GC) calls *before* an object's memory is reclaimed. Finalizers are primarily used to release **unmanaged resources** (like native memory, file handles, database connections that aren't wrapped by managed `IDisposable` types) that a managed object directly holds.

**Interaction with Exceptions:**

  * Finalizers are designed to be run reliably, even if exceptions occurred elsewhere in the application.
  * **Crucially, you should *never* throw an unhandled exception from a finalizer.** If an exception escapes a finalizer, the runtime typically terminates the process immediately to prevent corruption. This is a severe problem.
  * For this reason, finalizer code should be extremely robust and contain minimal logic, primarily focusing on `try-catch` blocks within themselves to prevent any exceptions from escaping.

**Why they are generally discouraged for managed resources:**

  * **Non-deterministic:** You have no control over *when* the GC will run the finalizer. This could lead to resources being held much longer than necessary.
  * **Performance Overhead:** Finalizers add overhead to the garbage collection process, as objects with finalizers require two GC passes instead of one.
  * **`IDisposable` is preferred:** For managed resources (or managed wrappers around unmanaged resources), `IDisposable` with `using` is the preferred pattern because it provides deterministic, immediate release of resources. The `IDisposable` pattern often includes a finalizer as a fallback for cases where `Dispose()` was not explicitly called.

**Code Example (Illustrative - finalizers are rarely written explicitly):**

```csharp
using System;
using System.IO;

public class MyNativeResourceWrapper : IDisposable
{
    private IntPtr _nativeHandle; // Represents an unmanaged resource handle

    public MyNativeResourceWrapper()
    {
        // Simulate acquiring an unmanaged resource
        _nativeHandle = new IntPtr(12345);
        Console.WriteLine($"  [MyNativeResourceWrapper]: Acquired native resource: {_nativeHandle}");
    }

    // Standard IDisposable pattern
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this); // Tell GC not to call finalizer if Dispose was called explicitly
    }

    protected virtual void Dispose(bool disposing)
    {
        if (_nativeHandle != IntPtr.Zero)
        {
            Console.WriteLine($"  [MyNativeResourceWrapper]: Disposing native resource: {_nativeHandle}");
            // Simulate releasing the unmanaged resource
            // NativeMethods.ReleaseHandle(_nativeHandle);
            _nativeHandle = IntPtr.Zero;

            if (disposing)
            {
                // Dispose of managed resources here (if any)
                Console.WriteLine("    Disposing managed resources (if any).");
            }
        }
    }

    // Finalizer - acts as a fallback if Dispose() is not called explicitly
    ~MyNativeResourceWrapper()
    {
        Console.WriteLine("  [MyNativeResourceWrapper]: Finalizer running (Dispose() was likely not called).");
        try
        {
            // Crucial: No exceptions must escape from here!
            Dispose(false); // Call Dispose logic for unmanaged resources
        }
        catch (Exception ex)
        {
            // Log the exception, but do NOT re-throw
            Console.WriteLine($"  [MyNativeResourceWrapper - FINALIZER ERROR]: An error occurred in finalizer: {ex.Message}");
            // In a real app, this would use a robust logger like Serilog/NLog to record for debugging.
        }
    }
}

public static class FinalizerExample
{
    public static void Run()
    {
        Console.WriteLine("--- Finalizers ---");

        // Scenario 1: Object used with 'using' (Dispose is called, finalizer suppressed)
        Console.WriteLine("\nScenario 1: Using statement (correct usage)");
        using (var wrapper = new MyNativeResourceWrapper())
        {
            Console.WriteLine("  Using wrapper in a 'using' block.");
        } // Dispose() called here, Finalizer suppressed
        Console.WriteLine("  Wrapper disposed explicitly. Finalizer should NOT run immediately.");

        // Scenario 2: Object not disposed explicitly (Finalizer will eventually run)
        Console.WriteLine("\nScenario 2: No explicit Dispose() (relying on Finalizer)");
        CreateAndForgetWrapper();
        Console.WriteLine("  Wrapper created and forgotten. Waiting for GC (may not be immediate)...");
        // Force GC for demonstration (DO NOT do this in production code normally)
        GC.Collect();
        GC.WaitForPendingFinalizers();
        GC.Collect();
        Console.WriteLine("  GC run. Finalizer for forgotten wrapper should have executed.");

        // Scenario 3: Demonstrating an exception WITHIN the finalizer (dangerous)
        Console.WriteLine("\nScenario 3: Exception in Finalizer (Dangerous - commented out to prevent crash)");
        // TryCreateAndForgetDangerousWrapper();
        // Console.WriteLine("  (If uncommented, this might crash the process if finalizer throws)");

        Console.WriteLine();
    }

    public static void CreateAndForgetWrapper()
    {
        var wrapper = new MyNativeResourceWrapper();
        // No explicit Dispose(), so finalizer is the fallback
    }

    // DANGEROUS: Do NOT do this in real code!
    public static void TryCreateAndForgetDangerousWrapper()
    {
        var wrapper = new DangerousNativeResourceWrapper();
        GC.Collect();
        GC.WaitForPendingFinalizers();
    }
}

// DANGEROUS CLASS FOR DEMONSTRATION ONLY
public class DangerousNativeResourceWrapper
{
    ~DangerousNativeResourceWrapper()
    {
        Console.WriteLine("  [DangerousFinalizer]: Running...");
        // DO NOT DO THIS: Throwing an exception from a finalizer is catastrophic
        throw new InvalidOperationException("CRITICAL: Exception thrown from finalizer!");
    }
}
```

-----

### 3\. Asynchronous Exceptions

**Focus:** How exceptions behave in `async`/`await` contexts, including handling, propagation, and `Task.Exception`.

**Explanation:**

Asynchronous programming with `async` and `await` has specific rules for exception handling that differ from synchronous code:

1.  **Propagation via `await`:** When an exception occurs in an `async` method, it's captured and stored within the `Task` object that the `async` method returns. When that `Task` is `await`ed, the exception is *re-thrown* on the original calling context. This makes `async`/`await` exception handling look very similar to synchronous `try-catch`.

2.  **Unawaited `Task`s:** If an `async` method throws an exception and its `Task` is never `await`ed (often called a "fire and forget" task), the exception might go unobserved, leading to issues. In .NET Core/.NET 5+, unobserved exceptions on unawaited tasks no longer crash the process by default (they did in older .NET Framework versions), but they still represent potential bugs and can lead to silent failures. You can subscribe to `TaskScheduler.UnobservedTaskException` for auditing.

3.  **`Task.Exception` (and `AggregateException`):**

      * When you access the `Exception` property of a `Task` (e.g., `myTask.Exception`), or if you block on a `Task` using `Task.Wait()` or `Task.Result`, any exception stored in the `Task` will be wrapped in an `AggregateException`.
      * If multiple exceptions occurred within a parallel or concurrent operation (e.g., `Task.WhenAll`), `AggregateException` will contain all of them in its `InnerExceptions` collection.

**Code Example:**

```csharp
using System;
using System.Threading.Tasks;
using System.Net.Http; // For HttpRequestException

public static class AsyncExceptions
{
    public static async Task Run()
    {
        Console.WriteLine("--- Asynchronous Exceptions ---");

        // Scenario 1: Exception caught with await (standard)
        Console.WriteLine("\nScenario 1: Exception caught with await");
        try
        {
            await SimulateAsyncOperation(false);
            Console.WriteLine("  Operation 1 completed successfully.");
        }
        catch (InvalidOperationException ex)
        {
            Console.WriteLine($"  [Caught]: Expected exception: {ex.Message}");
        }

        // Scenario 2: Unawaited Task with Exception (potential silent failure)
        Console.WriteLine("\nScenario 2: Unawaited Task with Exception (might be silent)");
        Task unawaitedTask = SimulateAsyncOperation(true, true);
        Console.WriteLine("  Started an unawaited task. Exception might not be immediately visible.");
        // In .NET Core+, this won't crash the process unless explicitly configured.
        // It's a "fire and forget" unless you have global unobserved exception handlers.
        await Task.Delay(100); // Give it time to potentially throw

        // Scenario 3: AggregateException from Task.Wait() or Task.Result
        Console.WriteLine("\nScenario 3: AggregateException from Task.Wait()");
        Task<string> taskWithAggregatedException = SimulateAsyncOperation(true); // Will throw IOE
        try
        {
            taskWithAggregatedException.Wait(); // Blocking call
            Console.WriteLine("  Operation 3 completed successfully.");
        }
        catch (AggregateException agEx)
        {
            Console.WriteLine($"  [Caught]: AggregateException with {agEx.InnerExceptions.Count} inner exception(s).");
            foreach (var inner in agEx.InnerExceptions)
            {
                Console.WriteLine($"    Inner Exception: {inner.GetType().Name} - {inner.Message}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"  [Caught]: Unexpected exception: {ex.Message}");
        }

        // Scenario 4: Multiple exceptions with Task.WhenAll
        Console.WriteLine("\nScenario 4: Multiple Exceptions with Task.WhenAll()");
        Task<string> task1 = SimulateAsyncOperation(true); // Throws InvalidOperationException
        Task<string> task2 = SimulateAsyncOperation(false); // Succeeds
        Task<string> task3 = SimulateAsyncOperation(true, false, "SecondError"); // Throws InvalidOperationException

        try
        {
            await Task.WhenAll(task1, task2, task3);
            Console.WriteLine("  All tasks completed.");
        }
        catch (AggregateException agEx)
        {
            Console.WriteLine($"  [Caught]: AggregateException from WhenAll with {agEx.InnerExceptions.Count} inner exception(s).");
            foreach (var inner in agEx.InnerExceptions)
            {
                Console.WriteLine($"    Inner Exception: {inner.GetType().Name} - {inner.Message}");
            }
            // You can use Flatten() to get a single AggregateException, and Handle() to process
            agEx.Handle(e =>
            {
                if (e is InvalidOperationException)
                {
                    Console.WriteLine($"    Handled an InvalidOperationException: {e.Message}");
                    return true; // Mark as handled
                }
                return false; // Let others (or the outer catch) handle
            });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"  [Caught]: Unexpected exception outside AggregateException: {ex.Message}");
        }

        Console.WriteLine();
    }

    public static async Task<string> SimulateAsyncOperation(bool shouldThrow, bool isFireAndForget = false, string errorMessage = "Simulated async error")
    {
        Console.WriteLine($"  [Async Op]: Starting simulation (throw: {shouldThrow}, fire and forget: {isFireAndForget}).");
        await Task.Delay(50); // Simulate some async work

        if (shouldThrow)
        {
            Console.WriteLine($"  [Async Op]: Throwing {errorMessage}.");
            throw new InvalidOperationException(errorMessage);
        }

        Console.WriteLine("  [Async Op]: Completing successfully.");
        return "Operation Done";
    }
}
```

-----

### 4\. `AggregateException`

**Focus:** When and why it's used (especially with `Task.Wait`, `Task.Result`, and Parallel LINQ).

**Explanation:**

`AggregateException` is a special exception type that can wrap one or more other exceptions. Its primary purpose is to consolidate multiple exceptions that occur during parallel or asynchronous operations into a single exception object. This prevents information loss when multiple faults happen concurrently.

**When it's used:**

  * **Blocking on `Task`s:**
      * When you call `Task.Wait()` or access `Task.Result` on a `Task` that has completed in a faulted state (i.e., it threw an exception).
      * `await` doesn't wrap exceptions in `AggregateException` by default (it re-throws the *first* inner exception directly), but if a task has *multiple* exceptions (e.g., from `Task.WhenAll` or PLINQ), `await` will still re-throw the `AggregateException`.
  * **`Task.WhenAll` (and `Task.WhenAny` if awaited and all faulted):** If any of the tasks awaited by `Task.WhenAll` fail, and you then `await` the result of `WhenAll`, you will get an `AggregateException` containing all the exceptions from the faulted tasks.
  * **Parallel LINQ (PLINQ):** If a PLINQ query encounters exceptions on multiple parallel threads, it will often aggregate them into an `AggregateException`.
  * **`Parallel.For` / `Parallel.ForEach`:** Similar to PLINQ, exceptions from parallel iterations are collected into an `AggregateException`.

**Key Methods:**

  * **`InnerExceptions` property:** A read-only collection (`ReadOnlyCollection<Exception>`) containing all the exceptions that were aggregated.
  * **`Flatten()` method:** Returns a new `AggregateException` where all nested `AggregateException`s are "unwrapped" into a single, flat list of inner exceptions. This is useful when you have deeply nested parallel operations.
  * **`Handle(Func<Exception, bool> predicate)` method:** Allows you to process the inner exceptions. The predicate function takes an inner exception and returns `true` if that exception has been "handled" by your logic, or `false` if it should be re-thrown (as part of a new `AggregateException` containing only the unhandled ones).

**Code Example (See Scenario 3 & 4 in Async Exceptions above for practical use).**

```csharp
using System;
using System.Linq;
using System.Threading.Tasks;

public static class AggregateExceptionExample
{
    public static void Run()
    {
        Console.WriteLine("--- AggregateException ---");

        // Scenario 1: Basic AggregateException from Task.Wait()
        Console.WriteLine("\nScenario 1: AggregateException from Task.Wait()");
        Task task = Task.Run(() => throw new InvalidOperationException("Operation failed!"));
        try
        {
            task.Wait();
        }
        catch (AggregateException agEx)
        {
            Console.WriteLine($"  Caught AggregateException. InnerExceptions count: {agEx.InnerExceptions.Count}");
            foreach (var inner in agEx.InnerExceptions)
            {
                Console.WriteLine($"    Inner Type: {inner.GetType().Name}, Message: {inner.Message}");
            }
        }

        // Scenario 2: Multiple exceptions from Task.WhenAll() and using Flatten() and Handle()
        Console.WriteLine("\nScenario 2: Multiple exceptions from Task.WhenAll() with Flatten() and Handle()");

        Task taskA = Task.Run(() => { throw new FormatException("Bad format!"); });
        Task taskB = Task.Run(() => { throw new ArgumentOutOfRangeException("Out of range!"); });
        Task taskC = Task.Run(() => { /* Succeeds */ });

        try
        {
            Task.WhenAll(taskA, taskB, taskC).Wait();
        }
        catch (AggregateException agEx)
        {
            Console.WriteLine($"  Caught AggregateException with {agEx.InnerExceptions.Count} inner exceptions.");

            // Flatten the exception (useful for deeply nested AggregateExceptions)
            AggregateException flattenedEx = agEx.Flatten();
            Console.WriteLine($"  Flattened AggregateException has {flattenedEx.InnerExceptions.Count} exceptions.");

            // Handle specific inner exceptions
            flattenedEx.Handle(inner =>
            {
                if (inner is FormatException)
                {
                    Console.WriteLine($"    Handled FormatException: {inner.Message}");
                    return true; // Indicate that this exception is handled
                }
                else if (inner is ArgumentOutOfRangeException)
                {
                    Console.WriteLine($"    Handled ArgumentOutOfRangeException: {inner.Message}");
                    return true; // Indicate that this exception is handled
                }
                return false; // Leave other exceptions unhandled
            });

            // If Handle() leaves any exceptions unhandled, a new AggregateException is thrown.
            // If all were handled, no new exception.
            Console.WriteLine("  After Handle() method.");
        }
        finally
        {
            // Always good practice to check if tasks are faulted in finally or after await/Wait()
            if (taskA.IsFaulted) Console.WriteLine($"  Task A faulted: {taskA.Exception.InnerException.Message}");
            if (taskB.IsFaulted) Console.WriteLine($"  Task B faulted: {taskB.Exception.InnerException.Message}");
            if (taskC.IsFaulted) Console.WriteLine($"  Task C faulted: {taskC.Exception.InnerException.Message}");
        }

        Console.WriteLine();
    }
}
```

-----

### 5\. Fault Resilience (using Polly as an example)

**Focus:** Building systems that can gracefully recover from transient faults, which is an advanced form of exception handling.

**Explanation:**

Fault resilience is about designing systems to remain operational and respond effectively even when components or services fail. It's an extension of exception handling that deals with anticipated, often temporary, failures in distributed systems. Instead of simply letting exceptions propagate and crash an application, fault resilience patterns provide mechanisms to:

  * **Retry:** Automatically re-attempt an operation that failed due to a transient error (e.g., network glitch, temporary service unavailability).
  * **Circuit Breaker:** Prevent an application from continuously trying to access a failing service, giving the service time to recover and protecting the application from cascading failures.
  * **Timeout:** Abort operations that take too long to complete.
  * **Bulkhead:** Isolate parts of the system to prevent a failure in one area from consuming all resources and affecting other parts.

**Polly** is a popular .NET library that provides fluent APIs for applying these resilience and transient-fault-handling policies. It's not a direct exception type, but a framework that *uses* exception types to decide policy execution.

**Why it's Advanced Exception Safety:**

It moves beyond simply "catching" an exception to intelligently "reacting" to exceptions in a way that increases the overall stability and availability of the system. It's about proactive exception management.

**Code Example (Simplified Polly usage for Retry and Circuit Breaker):**

```csharp
using System;
using System.Net.Http;
using System.Threading.Tasks;
using Polly;
using Polly.CircuitBreaker;

public static class FaultResilienceExample
{
    private static int _attemptCount = 0;
    private static bool _serviceOnline = true;

    public static async Task Run()
    {
        Console.WriteLine("--- Fault Resilience (Polly) ---");

        // --- 1. Retry Policy ---
        Console.WriteLine("\n--- Retry Policy ---");
        // Policy to retry HttpRequestException up to 3 times with exponential backoff
        var retryPolicy = Policy
            .Handle<HttpRequestException>() // Define which exception type to handle
            .WaitAndRetryAsync(3,
                retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), // Wait 2, 4, 8 seconds
                (ex, timeSpan, retryCount, context) =>
                {
                    Console.WriteLine($"  [Retry]: Attempt {retryCount}. Delaying for {timeSpan.TotalSeconds:N1}s due to: {ex.Message}");
                });

        try
        {
            _attemptCount = 0; // Reset for demo
            Console.WriteLine("Executing operation with retry policy (should succeed on 3rd attempt):");
            await retryPolicy.ExecuteAsync(() => SimulateNetworkCall(true));
            Console.WriteLine("  Operation with retry succeeded.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"  Operation with retry failed after all attempts: {ex.Message}");
        }

        // --- 2. Circuit Breaker Policy ---
        Console.WriteLine("\n--- Circuit Breaker Policy ---");
        // Policy to break after 2 failures, staying open for 5 seconds
        var circuitBreakerPolicy = Policy
            .Handle<HttpRequestException>()
            .CircuitBreakerAsync(2, TimeSpan.FromSeconds(5),
                onBreak: (ex, breakDelay) =>
                {
                    Console.WriteLine($"  [Circuit Breaker]: Circuit opened! Delay: {breakDelay.TotalSeconds:N1}s due to: {ex.Message}");
                    _serviceOnline = false; // Simulate external service state
                },
                onReset: () =>
                {
                    Console.WriteLine("  [Circuit Breaker]: Circuit closed (reset)!");
                    _serviceOnline = true; // Simulate external service state
                },
                onHalfOpen: () =>
                {
                    Console.WriteLine("  [Circuit Breaker]: Circuit half-opened. Testing service.");
                });

        Console.WriteLine("Executing operations with circuit breaker policy:");
        _serviceOnline = true;
        _attemptCount = 0;

        for (int i = 0; i < 5; i++)
        {
            try
            {
                Console.WriteLine($"\n  Attempt {i + 1} with circuit breaker:");
                await circuitBreakerPolicy.ExecuteAsync(() => SimulateServiceAvailability());
                Console.WriteLine($"  Attempt {i + 1} succeeded.");
            }
            catch (BrokenCircuitException)
            {
                Console.WriteLine($"  [Caught]: Circuit is open! Skipping call.");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"  [Caught]: Unexpected error for attempt {i + 1}: {ex.Message}");
            }
            if (i == 1) await Task.Delay(100); // Give time for circuit to open after 2 failures
            if (i == 2) await Task.Delay(TimeSpan.FromSeconds(5.5)); // Wait for circuit to half-open
        }

        Console.WriteLine();
    }

    // Simulates an unreliable network call for Retry policy
    public static Task SimulateNetworkCall(bool willFailTransiently)
    {
        _attemptCount++;
        if (willFailTransiently && _attemptCount <= 2)
        {
            Console.WriteLine($"    Simulating network transient failure (Attempt {_attemptCount}).");
            throw new HttpRequestException("Simulated network transient error.");
        }
        Console.WriteLine($"    Network call succeeded (Attempt {_attemptCount}).");
        return Task.CompletedTask;
    }

    // Simulates a service that goes offline for Circuit Breaker policy
    public static async Task SimulateServiceAvailability()
    {
        await Task.Delay(10); // Simulate some work
        if (!_serviceOnline)
        {
            Console.WriteLine("    Service is currently offline.");
            // When in half-open state, it's a test. If it throws, circuit breaks again.
            // If it succeeds, circuit resets.
            throw new HttpRequestException("Service currently unavailable.");
        }
        Console.WriteLine("    Service is online and responsive.");
    }
}
```

By combining these advanced techniques, you can build systems that are not only robust to individual exceptions but also resilient to widespread, transient failures common in modern distributed architectures.