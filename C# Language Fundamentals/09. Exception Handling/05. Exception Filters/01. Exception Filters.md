Let's delve into C\# 6+'s Exception Filters, a powerful feature for conditional exception handling.

-----

### Exception Filters (C\# 6+)

**Focus: Conditional Catch Blocks**

Exception filters, introduced in C\# 6.0, allow you to specify a condition that must be true for a `catch` block to execute. This provides a cleaner and more powerful way to handle exceptions conditionally, compared to traditional `if` checks inside the `catch` block.

**Syntax:**

The syntax for an exception filter is the `when` keyword followed by a boolean expression, placed after the exception type in a `catch` block:

```csharp
try
{
    // Code that might throw an exception
}
catch (ExceptionType ex) when (condition)
{
    // This block only executes if ExceptionType is caught AND 'condition' is true
}
```

**Key Characteristics and Benefits:**

1.  **Cleaner Alternatives to `if`-checks inside `catch`:**

      * **Old Way (Less Clean):**
        ```csharp
        try { /* ... */ }
        catch (CustomException ex)
        {
            if (ex.ErrorCode == 101) // Check inside the block
            {
                // Handle error 101
            }
            else if (ex.ErrorCode == 102)
            {
                // Handle error 102
            }
            else
            {
                throw; // Re-throw if not specifically handled
            }
        }
        ```
      * **New Way (Cleaner with Filters):**
        ```csharp
        try { /* ... */ }
        catch (CustomException ex) when (ex.ErrorCode == 101)
        {
            // Handle error 101 specifically
        }
        catch (CustomException ex) when (ex.ErrorCode == 102)
        {
            // Handle error 102 specifically
        }
        catch (CustomException ex) // General catch for other CustomException codes
        {
            // Handle other CustomException codes or re-throw
        }
        ```

    This eliminates nested `if/else` statements, making the exception handling logic much more readable and organized.

2.  **Order of Evaluation:**

      * When an exception occurs, the CLR evaluates `catch` blocks in order, from specific to general.
      * If a `catch` block has a filter, the filter expression is evaluated *before* the `catch` block's body is entered.
      * If the filter expression evaluates to `true`, the `catch` block executes.
      * If the filter expression evaluates to `false`, the `catch` block is skipped, and the CLR continues searching for the next matching `catch` block (either a different type or one with a filter that returns `true`).

3.  **Exception State During Filter Evaluation:**

      * Crucially, when the filter expression is evaluated, the exception object (`ex`) is already available and fully populated, but the stack hasn't been unwound for that `catch` block *yet*. This means you can inspect the exception's properties (like `Message`, `ErrorCode`, `InnerException`, `Data`) within the `when` clause.

4.  **No Stack Trace Impact (Compared to `if`):**

      * If you use an `if` check *inside* a `catch` block and then `throw;` because the `if` condition wasn't met, the stack trace remains preserved.
      * Exception filters achieve the same effect without the need for `throw;` within the `catch` block if the filter evaluates to `false`. The exception continues to propagate *as if it was never caught by that specific block*. This is a subtle but powerful benefit for clarity.

### Code Example:

Let's use the `OrderValidationException` from a previous discussion to demonstrate exception filters.

```csharp
using System;
using System.Collections.Generic;

// Reusing Custom Exception with Contextual Data
public class OrderValidationException : Exception
{
    public string OrderId { get; }
    public string ValidationRuleBroken { get; }
    public object InvalidValue { get; }

    public OrderValidationException(string message, string orderId, string ruleBroken, object invalidValue = null, Exception innerException = null)
        : base(message, innerException)
    {
        OrderId = orderId;
        ValidationRuleBroken = ruleBroken;
        InvalidValue = invalidValue;
    }

    public override string ToString()
    {
        return $"{base.ToString()}\n" +
               $"Order ID: {OrderId}\n" +
               $"Rule Broken: {ValidationRuleBroken}\n" +
               (InvalidValue != null ? $"Invalid Value: '{InvalidValue}'" : "");
    }
}

public static class ExceptionFilters
{
    public static void Run()
    {
        Console.WriteLine("--- Exception Filters (C# 6+) ---");

        // Scenario 1: Invalid Quantity (handled by specific filter)
        Console.WriteLine("\nScenario 1: Invalid Quantity (handled by specific filter)");
        try { ProcessOrder("ORD-001", 0); } // Quantity <= 0
        catch (OrderValidationException ex) when (ex.ValidationRuleBroken == "QUANTITY_POSITIVE")
        {
            Console.WriteLine($"  [Caught with Filter]: Specific handling for QUANTITY_POSITIVE: {ex.Message}");
            Console.WriteLine($"    Please provide a valid quantity greater than zero.");
        }
        catch (OrderValidationException ex) // General catch for other OrderValidationException types
        {
            Console.WriteLine($"  [Caught General OrderValidation]: {ex.Message}");
            Console.WriteLine($"    A general order validation error occurred. Rule: {ex.ValidationRuleBroken}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"  [Caught General Exception]: An unexpected error occurred: {ex.Message}");
        }

        // Scenario 2: Invalid Customer ID (handled by specific filter)
        Console.WriteLine("\nScenario 2: Invalid Customer ID (handled by specific filter)");
        try { ProcessOrder("ORD-002", 5, null); } // Customer ID is null
        catch (OrderValidationException ex) when (ex.ValidationRuleBroken == "CUSTOMER_ID_REQUIRED")
        {
            Console.WriteLine($"  [Caught with Filter]: Specific handling for CUSTOMER_ID_REQUIRED: {ex.Message}");
            Console.WriteLine($"    Customer ID is missing. Please provide one.");
        }
        catch (OrderValidationException ex)
        {
            Console.WriteLine($"  [Caught General OrderValidation]: {ex.Message}");
            Console.WriteLine($"    A general order validation error occurred. Rule: {ex.ValidationRuleBroken}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"  [Caught General Exception]: An unexpected error occurred: {ex.Message}");
        }

        // Scenario 3: Unknown Order Validation Error (falls to general OrderValidationException catch)
        Console.WriteLine("\nScenario 3: Unknown Order Validation Error (falls to general catch)");
        try { ProcessOrder("ORD-003", 5, "CUST-003", true); } // Simulates an unhandled validation rule
        catch (OrderValidationException ex) when (ex.ValidationRuleBroken == "CUSTOMER_ID_REQUIRED")
        {
            Console.WriteLine($"  [Caught with Filter]: This filter is not matched.");
        }
        catch (OrderValidationException ex) when (ex.ValidationRuleBroken == "QUANTITY_POSITIVE")
        {
            Console.WriteLine($"  [Caught with Filter]: This filter is not matched.");
        }
        catch (OrderValidationException ex) // This general OrderValidationException catch will handle it
        {
            Console.WriteLine($"  [Caught General OrderValidation]: {ex.Message}");
            Console.WriteLine($"    A general order validation error occurred. Rule: {ex.ValidationRuleBroken}");
            Console.WriteLine($"    Full details: {ex.ToString()}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"  [Caught General Exception]: An unexpected error occurred: {ex.Message}");
        }

        Console.WriteLine();
    }

    public static void ProcessOrder(string orderId, int quantity, string customerId = "CUST-001", bool simulateUnknownRule = false)
    {
        Console.WriteLine($"[Method]: Processing order '{orderId}' with quantity {quantity} for customer '{customerId}'.");

        if (quantity <= 0)
        {
            throw new OrderValidationException(
                "Order quantity must be greater than zero.",
                orderId,
                "QUANTITY_POSITIVE",
                quantity
            );
        }

        if (string.IsNullOrWhiteSpace(customerId))
        {
            throw new OrderValidationException(
                "Customer ID is required for order.",
                orderId,
                "CUSTOMER_ID_REQUIRED"
            );
        }

        if (simulateUnknownRule)
        {
            throw new OrderValidationException(
                "An unexpected validation rule was violated.",
                orderId,
                "UNKNOWN_VALIDATION_RULE", // This rule isn't specifically filtered
                "some value"
            );
        }

        Console.WriteLine($"[Method]: Order '{orderId}' processed successfully.");
    }
}
```

**Output Explanation:**

You'll observe that:

  * In Scenario 1, only the `catch (OrderValidationException ex) when (ex.ValidationRuleBroken == "QUANTITY_POSITIVE")` block executes.
  * In Scenario 2, only the `catch (OrderValidationException ex) when (ex.ValidationRuleBroken == "CUSTOMER_ID_REQUIRED")` block executes.
  * In Scenario 3, neither of the specific filters match, so the `catch (OrderValidationException ex)` (without a filter) handles the exception, demonstrating the fallback behavior.

This illustrates how exception filters allow you to create a clear, conditional flow for different error scenarios *within the exception handling mechanism itself*.

-----

### ðŸ§  Interview Angle: How can you filter exceptions without cluttering the catch block?

**Answer:**

You can filter exceptions without cluttering the `catch` block by using **exception filters (the `when` keyword)** introduced in C\# 6.0.

**Explanation:**

Historically, before C\# 6, if you wanted to handle an exception differently based on some property of the exception (like an error code, message content, or a specific value), you had to do an `if/else if/else` ladder *inside* the `catch` block:

```csharp
try
{
    // ... code ...
}
catch (MyCustomException ex)
{
    if (ex.ErrorCode == SpecificErrorCodes.Fatal)
    {
        // Handle fatal error
    }
    else if (ex.ErrorCode == SpecificErrorCodes.Retryable)
    {
        // Handle retryable error
    }
    else
    {
        // Log and re-throw, because this catch block wasn't truly meant for this exception
        // This makes the code less readable and implies it was caught unnecessarily
        Log.Error(ex, "Unhandled MyCustomException");
        throw;
    }
}
```

This approach has several drawbacks:

1.  **Clutter:** The `catch` block becomes cluttered with conditional logic.
2.  **Misleading:** It implies that *all* `MyCustomException`s are "caught" by this block, even if most are re-thrown.
3.  **Potential for Errors:** It's easy to forget the `throw;` for unhandled cases, leading to silently swallowed exceptions.

**The Solution with Exception Filters:**

Exception filters provide a clean, declarative way to specify the conditions under which a `catch` block should execute:

```csharp
try
{
    // ... code ...
}
catch (MyCustomException ex) when (ex.ErrorCode == SpecificErrorCodes.Fatal)
{
    // This block ONLY executes if it's MyCustomException AND it's a fatal error code.
    // Clean, focused logic for this specific scenario.
    HandleFatalError(ex);
}
catch (MyCustomException ex) when (ex.ErrorCode == SpecificErrorCodes.Retryable)
{
    // This block ONLY executes if it's MyCustomException AND it's a retryable error code.
    // Clean, focused logic for this specific scenario.
    HandleRetryableError(ex);
}
catch (MyCustomException ex) // No 'when' clause: This acts as a general catch-all for other MyCustomException types
{
    // This block executes if it's MyCustomException AND it didn't match any preceding filters.
    Log.Error(ex, "Unexpected MyCustomException caught.");
    // Decide whether to re-throw or handle generically.
    throw; // Often re-throw if this specific type isn't fully handled here.
}
// You could also have a catch (Exception ex) for truly generic errors.
```

**Benefits of using `when` clauses:**

  * **Readability:** The intent of each `catch` block is immediately clear from its signature.
  * **Decoupling Logic:** Each `catch` block becomes highly focused on a specific error condition, rather than containing a large `if/else` branching structure.
  * **No Unnecessary Catching/Rethrowing:** If a `when` clause evaluates to `false`, the `catch` block is simply skipped, and the exception continues searching for a matching handler as if that block didn't exist. This eliminates the need for explicit `throw;` statements within the conditional logic for non-matching cases.
  * **Access to Exception State:** The exception object (`ex`) is fully available within the `when` clause for inspection and evaluation.

In essence, exception filters allow you to specify the "selector" for a `catch` block directly in its declaration, leading to much cleaner, more precise, and more maintainable exception handling code.