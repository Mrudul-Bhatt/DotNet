Let's explore how to design effective exception hierarchies for domain-specific errors, enforce business rules, and improve error reporting in complex systems.

-----

### 🔹 You’re designing a payment system. Instead of throwing a general exception, how would you design an exception hierarchy for failures like "InsufficientBalance" and "InvalidCard"?

(Create a base `PaymentException` → derive specific types like `InsufficientBalanceException`, `InvalidCardException`.)

**Design Approach:**

A well-designed exception hierarchy for a payment system enhances clarity, allows for precise error handling, and provides valuable context.

1.  **Define a Base Custom Exception:**

      * Create a common base class for all payment-related exceptions, typically inheriting from `System.Exception` or `System.ApplicationException`. This allows consumers to catch *any* payment error generically if needed, while still enabling more specific handling.
      * This base exception can include common properties relevant to all payment failures (e.g., `TransactionId`, `PaymentGatewayStatusCode`).

2.  **Derive Specific Exceptions:**

      * For each distinct, anticipated payment failure scenario, create a specific custom exception class that inherits from your base `PaymentException`.
      * These specific exceptions can include properties unique to their error type.

**Exception Hierarchy Example:**

```csharp
using System;

// 1. Base Exception for all payment-related errors
public abstract class PaymentException : Exception
{
    public string TransactionId { get; }
    public string ErrorCode { get; } // Custom error code for specific failures

    protected PaymentException(string message, string transactionId, string errorCode, Exception innerException = null)
        : base(message, innerException)
    {
        TransactionId = transactionId;
        ErrorCode = errorCode;
    }

    public override string ToString()
    {
        return $"{base.ToString()}\nTransaction ID: {TransactionId}\nError Code: {ErrorCode}";
    }
}

// 2. Derived Specific Exceptions
public class InsufficientBalanceException : PaymentException
{
    public decimal RequestedAmount { get; }
    public decimal AvailableBalance { get; }

    public InsufficientBalanceException(string transactionId, decimal requestedAmount, decimal availableBalance, Exception innerException = null)
        : base($"Insufficient balance for transaction {transactionId}. Requested: {requestedAmount:C}, Available: {availableBalance:C}.",
               transactionId, "PAY-001", innerException) // "PAY-001" is a custom internal error code
    {
        RequestedAmount = requestedAmount;
        AvailableBalance = availableBalance;
    }

    public override string ToString()
    {
        return $"{base.ToString()}\nRequested Amount: {RequestedAmount:C}\nAvailable Balance: {AvailableBalance:C}";
    }
}

public class InvalidCardException : PaymentException
{
    public string CardType { get; }
    public string FailureReason { get; } // e.g., "Expired", "InvalidNumber", "CVVMismatch"

    public InvalidCardException(string transactionId, string cardType, string failureReason, Exception innerException = null)
        : base($"Invalid card for transaction {transactionId}. Reason: {failureReason}.",
               transactionId, "PAY-002", innerException) // "PAY-002" custom error code
    {
        CardType = cardType;
        FailureReason = failureReason;
    }

    public override string ToString()
    {
        return $"{base.ToString()}\nCard Type: {CardType}\nFailure Reason: {FailureReason}";
    }
}

public class PaymentGatewayOfflineException : PaymentException
{
    public string GatewayName { get; }
    public TimeSpan DowntimeEstimate { get; }

    public PaymentGatewayOfflineException(string transactionId, string gatewayName, TimeSpan downtimeEstimate, Exception innerException = null)
        : base($"Payment gateway '{gatewayName}' is currently offline. Estimated downtime: {downtimeEstimate.TotalMinutes} minutes.",
               transactionId, "PAY-003", innerException) // "PAY-003" custom error code
    {
        GatewayName = gatewayName;
        DowntimeEstimate = downtimeEstimate;
    }
}

// Example Usage
public class PaymentProcessor
{
    public void ProcessPayment(string transactionId, decimal amount, string cardNumber, decimal accountBalance)
    {
        Console.WriteLine($"[Processor]: Attempting to process transaction {transactionId} for {amount:C}.");

        if (accountBalance < amount)
        {
            throw new InsufficientBalanceException(transactionId, amount, accountBalance);
        }

        if (cardNumber.StartsWith("444")) // Simulate invalid card
        {
            throw new InvalidCardException(transactionId, "Visa", "InvalidNumber");
        }

        if (cardNumber.EndsWith("000")) // Simulate gateway offline
        {
            throw new PaymentGatewayOfflineException(transactionId, "Stripe", TimeSpan.FromMinutes(30));
        }

        Console.WriteLine($"[Processor]: Transaction {transactionId} processed successfully.");
    }
}

public static class PaymentExceptionHierarchy
{
    public static void Run()
    {
        Console.WriteLine("--- Payment Exception Hierarchy ---");
        var processor = new PaymentProcessor();

        // Scenario 1: Insufficient Balance
        Console.WriteLine("\nScenario 1: Insufficient Balance");
        try { processor.ProcessPayment("TXN001", 150.00m, "1234...", 100.00m); }
        catch (InsufficientBalanceException ex)
        {
            Console.WriteLine($"[Caught]: {ex.Message}");
            Console.WriteLine($"  Specific handling: Notify user, suggest adding funds.");
            Console.WriteLine($"  Details: Requested {ex.RequestedAmount:C}, Available {ex.AvailableBalance:C}");
        }
        // Catch general PaymentException to handle any specific payment error
        catch (PaymentException ex)
        {
            Console.WriteLine($"[Caught General PaymentException]: {ex.Message}");
            Console.WriteLine($"  Transaction ID: {ex.TransactionId}, Error Code: {ex.ErrorCode}");
            Console.WriteLine($"  Generic payment error handling: log, alert support.");
        }
        catch (Exception ex) // Catch all others
        {
            Console.WriteLine($"[Caught General Exception]: {ex.Message}");
            Console.WriteLine($"  Unexpected error: log thoroughly, alert ops.");
        }

        // Scenario 2: Invalid Card
        Console.WriteLine("\nScenario 2: Invalid Card");
        try { processor.ProcessPayment("TXN002", 50.00m, "4444...", 200.00m); }
        catch (InvalidCardException ex)
        {
            Console.WriteLine($"[Caught]: {ex.Message}");
            Console.WriteLine($"  Specific handling: Request new card details.");
            Console.WriteLine($"  Details: Card Type {ex.CardType}, Reason {ex.FailureReason}");
        }
        catch (PaymentException ex) { /* ... same as above ... */ }
        catch (Exception ex) { /* ... same as above ... */ }


        // Scenario 3: Payment Gateway Offline
        Console.WriteLine("\nScenario 3: Payment Gateway Offline");
        try { processor.ProcessPayment("TXN003", 75.00m, "5555...000", 200.00m); }
        catch (PaymentGatewayOfflineException ex)
        {
            Console.WriteLine($"[Caught]: {ex.Message}");
            Console.WriteLine($"  Specific handling: Suggest trying later, show estimated downtime.");
            Console.WriteLine($"  Details: Gateway {ex.GatewayName}, Downtime {ex.DowntimeEstimate.TotalMinutes} mins.");
        }
        catch (PaymentException ex) { /* ... same as above ... */ }
        catch (Exception ex) { /* ... same as above ... */ }

        Console.WriteLine();
    }
}
```

**Benefits of this Hierarchy:**

  * **Clarity:** `InsufficientBalanceException` clearly states the business problem.
  * **Precision:** Consumers can catch specific payment errors (`catch (InvalidCardException)`) and provide tailored user feedback or retry logic.
  * **Context:** Specific properties (`RequestedAmount`, `CardType`, `FailureReason`) provide invaluable data for debugging and user interaction.
  * **Flexibility:** The base `PaymentException` allows for a generic catch-all for any payment-related issues, while still distinguishing them from other application errors.

-----

### 🔹 Have you ever used custom exceptions for business rule enforcement? What was the benefit?

(E.g., throwing `OrderAlreadyShippedException` lets consumers distinguish business vs. technical failure and respond accordingly.)

**Yes, absolutely.** Using custom exceptions for business rule enforcement is a fundamental practice in designing robust and maintainable enterprise applications.

**Example Scenario (Order Processing System):**

In an order management system, a core business rule might be: "An order that has already been shipped cannot be cancelled or modified."

  * **Custom Exception:** `OrderAlreadyShippedException` (inheriting from `InvalidOperationException` or a custom `OrderProcessingException` base). This exception would be thrown if an attempt is made to cancel an order whose status is already "Shipped."

  * **Benefit 1: Distinguishing Business vs. Technical Failure:**

      * **Without Custom Exception:** If we just threw an `InvalidOperationException` with a message like "Cannot cancel shipped order," the calling code would only know that *some* operation was invalid. It wouldn't immediately know if this was a technical bug (e.g., trying to save to a closed database connection) or a deliberate business rule enforcement.
      * **With Custom Exception:** `catch (OrderAlreadyShippedException)` allows the consumer to specifically identify that a business rule was violated.

  * **Benefit 2: Driving Specific Consumer Responses:**

      * **Without Custom Exception:** The UI or API consumer might display a generic "An error occurred" message.
      * **With Custom Exception:**
          * **UI Layer:** Could catch `OrderAlreadyShippedException` and display a very precise, user-friendly message: "This order cannot be cancelled because it has already been shipped. Please contact customer support for further assistance."
          * **API Consumer:** Could identify the `OrderAlreadyShippedException` and return an HTTP 409 Conflict status code, along with a specific error code in the response body, clearly indicating the business conflict.
          * **Internal Service:** An automated process trying to cancel orders could log the specific exception and move the order to a "Cancellation Failed - Shipped" state for manual review, rather than just failing generically.

  * **Benefit 3: Enhanced Readability and Maintainability:**

      * The `throw new OrderAlreadyShippedException(...)` statement clearly communicates the exact business rule being enforced at that point in the code.
      * Future developers maintaining the system immediately understand the intent of the exception handling.

  * **Benefit 4: Contextual Data for Debugging/Analysis:**

      * The `OrderAlreadyShippedException` could carry properties like `OrderId`, `CurrentStatus`, and `ShippedDate`. This provides invaluable data in logs and telemetry, making it easy to understand the exact state of the order when the rule was violated, without needing to query the database separately.

In essence, custom exceptions for business rule enforcement transform generic error conditions into structured, semantically rich information that directly informs handling, user feedback, and system analysis.

-----

### 🔹 You need to catch multiple related domain exceptions (e.g., all user input errors) in a single catch block. How would you design this?

(Create a common base class like `UserInputException` → catch that in one block.)

**Design:**

The key is to leverage inheritance to create an exception hierarchy.

1.  **Define a Base Exception for the Category:** Create a common base class that groups all related domain exceptions. For user input errors, this might be `UserInputException` or `ValidationException`. This base class should typically inherit from `System.Exception` or `System.ApplicationException`.

2.  **Derive Specific Exceptions:** All individual, specific user input errors (e.g., `InvalidEmailFormatException`, `RequiredFieldMissingException`, `PasswordMismatchException`) would then inherit from this common base class.

**How to Catch:**

In your `catch` block, you would simply catch the common base exception type. This block will then handle *any* exception that derives from that base type.

**Code Example:**

```csharp
using System;

// 1. Base Exception for User Input Errors
public abstract class UserInputException : Exception
{
    public string FieldName { get; }
    public string UserMessage { get; } // A message directly suitable for UI

    protected UserInputException(string message, string fieldName, string userMessage, Exception innerException = null)
        : base(message, innerException)
    {
        FieldName = fieldName;
        UserMessage = userMessage;
    }

    public override string ToString()
    {
        return $"{base.ToString()}\nField: {FieldName}\nUser-Friendly: {UserMessage}";
    }
}

// 2. Derived Specific User Input Exceptions
public class InvalidEmailFormatException : UserInputException
{
    public InvalidEmailFormatException(string email, Exception innerException = null)
        : base($"Invalid email format: '{email}'.", "Email", "Please enter a valid email address.", innerException) { }
}

public class RequiredFieldMissingException : UserInputException
{
    public RequiredFieldMissingException(string fieldName, Exception innerException = null)
        : base($"Required field '{fieldName}' is missing.", fieldName, $"The '{fieldName}' field is required.", innerException) { }
}

public class PasswordMismatchException : UserInputException
{
    public PasswordMismatchException(Exception innerException = null)
        : base("Password and confirmation do not match.", "ConfirmPassword", "Password and confirmation do not match.", innerException) { }
}

public static class CatchRelatedExceptions
{
    public static void Run()
    {
        Console.WriteLine("--- Catching Multiple Related Exceptions ---");

        // Scenario 1: Invalid Email
        Console.WriteLine("\nScenario 1: Invalid Email Format.");
        try { RegisterUser("test@bad", "password123", "password123"); }
        catch (UserInputException ex)
        {
            HandleUserInputError(ex);
        }

        // Scenario 2: Required Field Missing
        Console.WriteLine("\nScenario 2: Required Field Missing.");
        try { RegisterUser(null, "password123", "password123"); }
        catch (UserInputException ex)
        {
            HandleUserInputError(ex);
        }

        // Scenario 3: Password Mismatch
        Console.WriteLine("\nScenario 3: Password Mismatch.");
        try { RegisterUser("valid@email.com", "password123", "different"); }
        catch (UserInputException ex)
        {
            HandleUserInputError(ex);
        }

        Console.WriteLine();
    }

    public static void RegisterUser(string email, string password, string confirmPassword)
    {
        Console.WriteLine($"[Method]: Attempting to register user '{email}'.");
        if (string.IsNullOrWhiteSpace(email))
        {
            throw new RequiredFieldMissingException("Email");
        }
        if (!email.Contains("@")) // Simple email validation
        {
            throw new InvalidEmailFormatException(email);
        }
        if (string.IsNullOrWhiteSpace(password))
        {
            throw new RequiredFieldMissingException("Password");
        }
        if (password != confirmPassword)
        {
            throw new PasswordMismatchException();
        }

        Console.WriteLine($"[Method]: User '{email}' registered successfully.");
    }

    public static void HandleUserInputError(UserInputException ex)
    {
        Console.WriteLine($"  [Common Handler]: User Input Error: {ex.FieldName} - {ex.UserMessage}");
        // Log the full exception for internal debugging
        Console.Error.WriteLine($"  [Internal Log]: Full exception: {ex.ToString()}");
        // This single handler can process all UserInputException types
    }
}
```

**Benefit:** This design allows you to have a single `catch` block for a whole category of errors, simplifying your code. Inside that block, you can still access common properties (like `FieldName`, `UserMessage`) from the base class, and if needed, perform additional `if (ex is SpecificException)` checks or use pattern matching for even more granular handling within the common block.

-----

### 🔹 You receive logs with hundreds of “Exception occurred” messages but no type-specific info. How would custom exceptions help here?

(Use strongly typed exception classes to improve log filtering, categorization, and automated responses.)

**The Problem with Generic "Exception occurred" Logs:**

When you see hundreds of generic "Exception occurred" messages (often from `catch (Exception ex) { Log("Exception occurred: " + ex.Message); }`), it means:

1.  **Lack of Specificity:** You don't know *what kind* of exception it was (e.g., a network error, a database constraint violation, a business rule failure, an invalid input).
2.  **Difficult Categorization:** You can't easily filter, group, or count errors by their nature. All `Exception` types look the same in your logs.
3.  **No Automated Response:** Without knowing the type, you can't set up automated alerts or trigger specific recovery actions based on the error type.
4.  **Debugging Nightmare:** You're missing critical context, making it very hard to diagnose the root cause without digging through massive stack traces for each entry.

**How Custom Exceptions Help:**

Custom exceptions provide strongly typed, domain-specific error information that significantly improves logging and monitoring:

1.  **Strongly Typed Filtering & Categorization:**

      * Instead of `catch (Exception ex)`, you throw and `catch (InsufficientFundsException)` or `ProductOutOfStockException`.
      * Your logging framework (e.g., Serilog, NLog, Log4net, or cloud logging services) can then log the *type name* of the exception (`ex.GetType().Name`) as a structured property.
      * This allows you to easily filter logs: "Show me all `InsufficientFundsException`s," "Show me all `OrderValidationException`s." You can then categorize them by business domain.

2.  **Improved Readability and Actionability in Logs:**

      * Log messages can become `["OrderValidationFailure"] - Order 'ORD123' failed validation for rule 'QUANTITY_POSITIVE'. Invalid value: 0.`
      * Compared to a generic "Exception occurred," this immediately tells you what happened and the specific business context, even without digging into the full stack trace.

3.  **Automated Responses and Alerts:**

      * Monitoring tools can be configured to trigger specific alerts based on exception types.
          * "If `PaymentGatewayOfflineException` occurs more than 5 times in 1 minute, page the SRE team."
          * "If `AccountLockedException` occurs, send a notification to the customer support team."
      * This enables proactive responses to specific system health or business issues.

4.  **Rich Contextual Data in Logs:**

      * As shown previously, custom exceptions can carry additional properties (`OrderId`, `ProductId`, `ErrorCode`).
      * When logging `ex.ToString()` or using structured logging with these custom properties, your logs become far richer and more informative, reducing the need for manual context gathering during debugging. You can immediately see the specific data that led to the error.

**Example Improvement:**

```csharp
// BAD LOGGING (leads to "Exception occurred" hundreds of times)
try
{
    // ... some operation ...
}
catch (Exception ex)
{
    Console.WriteLine($"Exception occurred: {ex.Message}"); // Only message, no type, no context, no full stack
}

// GOOD LOGGING with Custom Exceptions
try
{
    // ... an operation that might throw ProductOutOfStockException
    // Or PaymentGatewayOfflineException
    InventoryService.CheckAndReserve("PROD-ABC", 5);
}
catch (ProductOutOfStockException ex) // Specific custom exception
{
    // Logging framework would capture type, message, stack, and custom properties
    // Logger.Warning(ex, "Product out of stock for {ProductSku}, Requested {RequestedQty}, Available {AvailableQty}",
    //               ex.ProductSku, ex.RequestedQuantity, ex.AvailableQuantity);
    Console.WriteLine($"[Log - WARN]: Product Out of Stock! Product: {ex.ProductSku}, Available: {ex.AvailableQuantity}.");
    Console.Error.WriteLine(ex.ToString()); // Full details
}
catch (PaymentGatewayOfflineException ex) // Another specific custom exception
{
    // Logger.Critical(ex, "Payment gateway {Gateway} is offline. Estimated downtime: {Downtime}",
    //                 ex.GatewayName, ex.DowntimeEstimate);
    Console.WriteLine($"[Log - CRITICAL]: Payment Gateway Offline! Gateway: {ex.GatewayName}.");
    Console.Error.WriteLine(ex.ToString()); // Full details
}
catch (Exception ex) // General fallback for truly unexpected errors
{
    // Logger.Error(ex, "An unexpected error occurred.");
    Console.WriteLine($"[Log - ERROR]: An unexpected general error occurred.");
    Console.Error.WriteLine(ex.ToString()); // Full details
}
```

This approach transforms your log analysis from a frustrating search for vague messages into an efficient process of filtering, categorizing, and responding to specific, well-defined error conditions.

-----

### 🔹 Your API needs to return different HTTP responses for validation errors vs. internal failures. How would exception types help with that?

(Map custom exceptions (e.g., `ValidationException`) to HTTP 400, `DatabaseException` to 500, etc.)

**Approach:**

Exception types provide a clean and robust way to map internal application errors to appropriate HTTP status codes and response structures in an API. This is typically implemented using a global exception handler or middleware in web frameworks (like ASP.NET Core).

**Design Steps:**

1.  **Define Custom Exception Categories:** Create a hierarchy of custom exceptions that categorize errors by their nature (e.g., client-side input errors, business rule violations, server-side operational errors).

      * `ClientErrorException` (Base for 4xx status codes)
          * `ValidationException` (for HTTP 400 Bad Request)
          * `UnauthorizedAccessException` (reuse or derive for 401/403)
          * `NotFoundException` (for HTTP 404 Not Found)
          * `ConflictException` (for HTTP 409 Conflict)
      * `ServerErrorException` (Base for 5xx status codes, perhaps abstract)
          * `DatabaseAccessException` (for HTTP 500 Internal Server Error, possibly with specific codes)
          * `ExternalServiceUnavailableException` (for HTTP 503 Service Unavailable)
          * `UnexpectedApplicationException` (general fallback for any unhandled application logic errors, mapped to 500)

2.  **Throw Specific Exceptions from Business Logic:** In your service layer or domain logic, throw these custom exceptions when the corresponding error condition occurs.

3.  **Implement Global Exception Handling Middleware/Filter:** In your API's startup configuration, set up a global exception handler (e.g., an `ExceptionHandlerMiddleware` in ASP.NET Core, or an `ErrorController` in older MVC) that:

      * Catches `System.Exception`.
      * Uses `is` checks or pattern matching to identify the specific custom exception type.
      * Maps the exception type to the appropriate HTTP status code and constructs a standardized error response body (e.g., JSON with `errorCode`, `message`, `details` fields).
      * Logs the original exception's full details internally (especially for 5xx errors).

**Code Example (Conceptual for ASP.NET Core):**

```csharp
// --- 1. Custom Exception Definitions ---
// Base for client-side errors (4xx)
public abstract class ClientErrorException : Exception
{
    public int StatusCode { get; protected set; } = 400; // Default to Bad Request
    public string ErrorCode { get; protected set; } // Custom business error code
    protected ClientErrorException(string message, string errorCode = null, Exception innerException = null)
        : base(message, innerException) { ErrorCode = errorCode; }
}

public class ValidationException : ClientErrorException
{
    public Dictionary<string, string[]> Errors { get; } // For specific field validation errors
    public ValidationException(string message, Dictionary<string, string[]> errors = null, string errorCode = "VALIDATION_FAILED")
        : base(message, errorCode)
    {
        StatusCode = 400; // Bad Request
        Errors = errors ?? new Dictionary<string, string[]>();
    }
}

public class NotFoundException : ClientErrorException
{
    public NotFoundException(string message, string errorCode = "NOT_FOUND")
        : base(message, errorCode) { StatusCode = 404; } // Not Found
}

public class ConflictException : ClientErrorException
{
    public ConflictException(string message, string errorCode = "CONFLICT")
        : base(message, errorCode) { StatusCode = 409; } // Conflict
}

// Base for server-side errors (5xx)
public abstract class ServerErrorException : Exception
{
    public int StatusCode { get; protected set; } = 500; // Default to Internal Server Error
    public string ErrorCode { get; protected set; }
    protected ServerErrorException(string message, string errorCode = null, Exception innerException = null)
        : base(message, innerException) { ErrorCode = errorCode; }
}

public class DatabaseAccessException : ServerErrorException
{
    public DatabaseAccessException(string message, Exception innerException = null, string errorCode = "DB_ERROR")
        : base(message, errorCode, innerException) { StatusCode = 500; }
}

public class ExternalServiceUnavailableException : ServerErrorException
{
    public ExternalServiceUnavailableException(string message, Exception innerException = null, string errorCode = "EXTERNAL_SERVICE_UNAVAILABLE")
        : base(message, errorCode, innerException) { StatusCode = 503; } // Service Unavailable
}


// --- 2. Throwing Exceptions in API Logic ---
public class ProductsController : ControllerBase // Assuming ASP.NET Core Controller
{
    // POST /products
    [HttpPost]
    public IActionResult CreateProduct([FromBody] ProductDto product)
    {
        if (string.IsNullOrWhiteSpace(product.Name))
        {
            // Throws validation exception
            throw new ValidationException(
                "Product name is required.",
                new Dictionary<string, string[]> { { "name", new[] { "Product name cannot be empty." } } }
            );
        }

        // Simulate database error
        if (product.Name == "throw_db_error")
        {
            try { throw new SqlException("DB connection failed", new System.ComponentModel.Win32Exception(11001)); }
            catch (SqlException ex) { throw new DatabaseAccessException("Failed to save product to database.", ex); }
        }

        // Simulate successful creation
        return Ok(new { Message = "Product created." });
    }

    // GET /products/{id}
    [HttpGet("{id}")]
    public IActionResult GetProduct(int id)
    {
        if (id == 999) // Simulate not found
        {
            throw new NotFoundException($"Product with ID {id} not found.");
        }
        return Ok(new { Id = id, Name = "Found Product" });
    }
}

// --- 3. Global Exception Handling Middleware (Conceptual for ASP.NET Core) ---
// This would be configured in Startup.cs or Program.cs

public class GlobalExceptionHandlerMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<GlobalExceptionHandlerMiddleware> _logger;

    public GlobalExceptionHandlerMiddleware(RequestDelegate next, ILogger<GlobalExceptionHandlerMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "An unhandled exception occurred during request processing.");

            context.Response.ContentType = "application/json";
            var problemDetails = new ProblemDetails
            {
                Instance = context.Request.Path
            };

            switch (ex)
            {
                case ValidationException vex:
                    context.Response.StatusCode = vex.StatusCode;
                    problemDetails.Status = vex.StatusCode;
                    problemDetails.Title = "Validation Error";
                    problemDetails.Detail = vex.Message;
                    problemDetails.Extensions["errors"] = vex.Errors;
                    problemDetails.Type = $"https://example.com/probs/validation-error/{vex.ErrorCode}";
                    break;
                case ClientErrorException cex: // Catches NotFoundException, ConflictException, etc.
                    context.Response.StatusCode = cex.StatusCode;
                    problemDetails.Status = cex.StatusCode;
                    problemDetails.Title = "Client Error";
                    problemDetails.Detail = cex.Message;
                    problemDetails.Type = $"https://example.com/probs/client-error/{cex.ErrorCode}";
                    break;
                case ServerErrorException sex: // Catches DatabaseAccessException, ExternalServiceUnavailableException, etc.
                    context.Response.StatusCode = sex.StatusCode;
                    problemDetails.Status = sex.StatusCode;
                    problemDetails.Title = "Server Error";
                    problemDetails.Detail = "An unexpected server error occurred. Please try again later."; // Hide internal details
                    problemDetails.Type = $"https://example.com/probs/server-error/{sex.ErrorCode}";
                    // Optionally expose specific error codes if safe and useful for clients
                    break;
                default: // Catch all other unexpected exceptions
                    context.Response.StatusCode = 500;
                    problemDetails.Status = 500;
                    problemDetails.Title = "Internal Server Error";
                    problemDetails.Detail = "An unexpected error occurred.";
                    problemDetails.Type = "https://example.com/probs/internal-server-error";
                    break;
            }

            await context.Response.WriteAsJsonAsync(problemDetails);
        }
    }
}
```

**Benefits:**

  * **Clean API Design:** The API controller's logic focuses on throwing meaningful exceptions, not on handling HTTP status codes.
  * **Centralized Error Mapping:** All exception-to-HTTP mapping happens in one place, making it consistent and easy to manage.
  * **Standardized Responses:** Clients receive predictable error response formats.
  * **User-Friendly/Actionable Errors:** Validation errors (400) can clearly tell the user what's wrong, while internal errors (500) provide a generic message suitable for end-users, while developers get full logs.

-----

### 🔹 What precautions would you take when designing custom exceptions in a library used by other teams or projects?

(Avoid leaking internals, make them serializable, provide clear messages, consider sealed vs abstract for extensibility, document them.)

Designing custom exceptions for a shared library requires extra care because other teams will depend on them.

1.  **Avoid Leaking Internal Implementation Details:**

      * **Principle:** Exceptions should expose only what's necessary for the consumer to understand and handle the error, not the internal workings of your library.
      * **Precaution:** Avoid adding properties to custom exceptions that expose internal classes, database schemas, or infrastructure-specific details that the consuming application shouldn't (or doesn't need to) know about. If you need to include internal context for *your own* logging/debugging, ensure it's not exposed as a public property that could break future compatibility or provide too much information.
      * **Example:** Instead of `public SqlException DbError { get; }`, use `public string DatabaseErrorCode { get; }` or just rely on the `InnerException`.

2.  **Ensure Standard Constructors are Present:**

      * Provide the three standard constructors (`()`, `(string message)`, `(string message, Exception innerException)`). This allows consumers to create instances of your exceptions correctly if they need to, and ensures compatibility with various exception handling patterns (especially passing `InnerException`).

3.  **Provide Clear, Actionable Messages:**

      * The `message` string in the constructor should be clear and descriptive about what went wrong. For internal library use, it should be precise; for public-facing errors, it might need to be more generalized if passed directly to users.
      * **Precaution:** Avoid generic messages like "An error occurred." Make them specific (e.g., "The requested product ID was not found.").

4.  **Consider Serialization (for .NET Framework/specific scenarios):**

      * **Precaution:** If your library is used in scenarios that involve cross-AppDomain communication, remoting, or persisting exceptions (e.g., storing them in a database or message queue), your custom exceptions *must* be marked with the `[Serializable]` attribute and implement the `SerializationInfo` and `StreamingContext` constructors.
      * **Note:** For modern .NET (.NET Core/.NET 5+), this is less common as binary serialization is often avoided in favor of JSON/XML, but it's a critical consideration for legacy or specific uses.

5.  **Design for Extensibility (Sealed vs. Abstract):**

      * **`sealed`:** If your custom exception is a leaf node in the hierarchy and you never intend for other teams to derive from it, mark it `sealed`. This prevents unintended inheritance.
      * **`abstract`:** If you intend for other teams (or other parts of your own library) to create more specific exceptions from your base custom exception, make the base class `abstract` and protect its constructors.
      * **Precaution:** Be intentional about whether your custom exceptions should be extended.

6.  **Comprehensive Documentation:**

      * **Precaution:** Document your custom exceptions thoroughly using XML comments (`///`). Explain:
          * What causes the exception.
          * What its properties (`OrderId`, `ErrorCode`, etc.) represent.
          * What actions a consumer might take when catching it (e.g., "Retry this operation," "Notify user," "Log and alert ops").
          * Which `InnerException` types it typically wraps.

7.  **Versioning Considerations:**

      * **Precaution:** If you add new properties to an existing custom exception in a future version of your library, consider the impact on consumers. Adding properties is generally additive and non-breaking, but removing or changing existing properties would be a breaking change.

By following these precautions, you ensure that your custom exceptions are not just functional but also well-behaved, easy to use, and maintainable across different teams and projects.

-----

### 🔹 You want to wrap a third-party exception inside your domain exception for clarity. How would you do that without losing original context?

(Use: `throw new MyCustomException("message", ex);` — retain stack via `InnerException`.)

**Approach:**

This is a very common and recommended pattern called **Exception Wrapping** or **Exception Chaining**. It allows you to translate a low-level, potentially cryptic exception from a dependency (like a third-party library, database driver, or network client) into a more meaningful, domain-specific exception for your application's consumers, while still retaining all the diagnostic information from the original error.

**How to Do It:**

When you create your domain-specific custom exception, you use its constructor that accepts an `innerException` argument. You pass the original third-party exception as this `innerException`.

The `Exception.InnerException` property is designed precisely for this purpose. When you call `ToString()` on your custom exception, it will automatically include the details of its `InnerException` (and any `InnerException`s within that, forming a full chain), preserving the complete stack trace and messages from the original problem.

**Code Example:**

```csharp
using System;
using System.IO;
using System.Data.SqlClient; // Simulating a third-party/low-level exception

// 1. Define your domain-specific custom exception
public class OrderPersistenceException : Exception
{
    public string OrderId { get; }
    public string OperationAttempted { get; }

    public OrderPersistenceException(string message, string orderId, string operation, Exception innerException = null)
        : base(message, innerException)
    {
        OrderId = orderId;
        OperationAttempted = operation;
    }

    public override string ToString()
    {
        return $"{base.ToString()}\nOrder ID: {OrderId}\nOperation: {OperationAttempted}";
    }
}

public static class ExceptionWrapping
{
    public static void Run()
    {
        Console.WriteLine("--- Wrapping Third-Party Exceptions ---");

        // Scenario: Simulating an order save operation that fails at the database layer
        try
        {
            SaveOrderToDatabase("ORD-12345", "customer@example.com");
        }
        catch (OrderPersistenceException ex)
        {
            Console.WriteLine("[Main App Catch]: Caught OrderPersistenceException:");
            Console.WriteLine(ex.ToString()); // This will display the full chain: OrderPersistenceException -> SqlException
            Console.WriteLine("\n--- End of Exception Details ---");
            Console.WriteLine($"Order ID: {ex.OrderId}, Operation: {ex.OperationAttempted}");
            Console.WriteLine($"Original low-level error type: {ex.InnerException?.GetType().Name}");
        }
        Console.WriteLine();
    }

    // This method simulates interacting with a low-level data access component
    // or a third-party library that throws specific exceptions.
    private static void ExecuteDatabaseCommand(string sql)
    {
        Console.WriteLine($"  [Database Layer]: Executing SQL: {sql}");
        // Simulate a database connection error (e.g., server offline, invalid credentials)
        throw new SqlException("A network-related or instance-specific error occurred while establishing a connection to SQL Server. Server was not found or was not accessible.", new System.ComponentModel.Win32Exception(10060));
    }

    // This method is part of your application's domain logic, wrapping the low-level call.
    public static void SaveOrderToDatabase(string orderId, string customerEmail)
    {
        Console.WriteLine($"  [Order Service]: Attempting to save order '{orderId}'.");
        try
        {
            // Call into your data access layer, which might use a third-party ORM or direct ADO.NET
            ExecuteDatabaseCommand($"INSERT INTO Orders (OrderId, CustomerEmail) VALUES ('{orderId}', '{customerEmail}')");
            Console.WriteLine($"  [Order Service]: Order '{orderId}' saved successfully.");
        }
        catch (SqlException sqlEx) // Catch the specific low-level exception
        {
            Console.WriteLine($"  [Order Service Catch]: Caught SqlException. Wrapping it in OrderPersistenceException.");
            // Create your domain-specific exception, passing the original SqlException as the InnerException
            throw new OrderPersistenceException(
                $"Failed to persist order '{orderId}' due to a database error.",
                orderId,
                "SaveOrder",
                sqlEx // This is the crucial part: chaining the original exception
            );
        }
        catch (Exception ex) // Catch any other unexpected exceptions and wrap them
        {
            Console.WriteLine($"  [Order Service Catch]: Caught an unexpected exception. Wrapping it.");
            throw new OrderPersistenceException(
                $"An unexpected error occurred while persisting order '{orderId}'.",
                orderId,
                "SaveOrder",
                ex // Always pass the original exception
            );
        }
    }
}
```

**Benefits of Exception Wrapping:**

  * **Clarity at Different Layers:** Higher-level code can catch `OrderPersistenceException`, which is meaningful in the business domain, rather than needing to know about `SqlException` or `HttpRequestException`.
  * **Full Context Preservation:** Despite the new exception type, the `InnerException` chain ensures that the original error's type, message, and full stack trace are always available for debugging and detailed logging.
  * **Abstraction:** You decouple your application's public API errors from the specific technologies used internally. If you switch from SQL Server to NoSQL, you might change the `InnerException` but the `OrderPersistenceException` remains the same.
  * **Granular Logging/Telemetry:** You can log the `OrderPersistenceException` with its domain-specific context, and your logging system can still extract and categorize the underlying `SqlException` details for infrastructure monitoring.