Let's dive deep into C\# access modifiers, exploring each one, their usage, design implications, and how they interact in complex scenarios like inheritance, interfaces, and across assembly boundaries.

-----

### Understanding Access Modifiers

Access modifiers in C\# control the visibility and accessibility of types (classes, structs, records, enums, interfaces, delegates) and their members (fields, properties, methods, events, constructors). They are a cornerstone of encapsulation, a fundamental principle of object-oriented programming (OOP), which aims to hide the internal implementation details of an object and expose only what is necessary for its proper use.

Here's a breakdown of the primary access modifiers:

1.  `public`
2.  `private`
3.  `protected`
4.  `internal`
5.  `protected internal`
6.  `private protected` (C\# 7.2 and later)

-----

### 1\. `public`

**Definition:** The `public` keyword is the most permissive access level. It means that the type or member is accessible by any other code in the same assembly or another assembly that references it.

**When to Use:**

  * **API Exposure:** For types and members that form the public interface of your library or module. This is what consumers of your code will directly interact with.
  * **Frameworks/Libraries:** Core functionalities that are meant to be used broadly.
  * **DTOs/Models:** Properties of Data Transfer Objects or simple models that need to be read/written by external layers (e.g., UI, other services).
  * **Public Contracts:** Methods in interfaces (which are implicitly `public`).

**Design Implications:**

  * **High Visibility:** Be cautious with `public` members. Once exposed, they become part of your public contract and are difficult to change without breaking consuming code.
  * **Encapsulation Risk:** Overuse of `public` can break encapsulation by exposing internal implementation details.
  * **Testability:** Generally good for testability as members are directly accessible.

**Code Example:**

```csharp
// Assembly A: MyPublicLibrary.dll
namespace MyPublicLibrary
{
    public class PublicApi
    {
        public string PublicProperty { get; set; } // Accessible anywhere

        public void PublicMethod() // Accessible anywhere
        {
            Console.WriteLine("Public method called.");
        }
    }

    public class PublicData
    {
        // Public properties, suitable for DTOs
        public int Id { get; set; }
        public string Name { get; set; }
    }

    public interface IPublicService
    {
        void DoSomethingPublic(); // Interfaces members are implicitly public
    }
}
```

```csharp
// Assembly B: MyApplication.exe (references MyPublicLibrary.dll)
using MyPublicLibrary;
using System;

public class Program
{
    public static void Main(string[] args)
    {
        PublicApi api = new PublicApi();
        api.PublicProperty = "Hello";
        api.PublicMethod(); // OK

        PublicData data = new PublicData { Id = 1, Name = "Test" }; // OK
        Console.WriteLine($"Data: {data.Name}");
    }
}
```

-----

### 2\. `private`

**Definition:** The `private` keyword is the most restrictive access level. It means that the type or member is accessible only within the containing type.

**When to Use:**

  * **Implementation Details:** For fields, methods, or properties that are purely internal to the class's workings and are not meant to be exposed or directly accessed from outside.
  * **Helper Methods:** Utility methods used internally by the class.
  * **Encapsulation:** The primary modifier to enforce strong encapsulation. It hides complexity and prevents external code from messing with the object's internal state directly.
  * **Private Setters/Getters:** Often used with `public` properties to control write access from outside while allowing internal modification (e.g., `public int MyProperty { get; private set; }`).

**Design Implications:**

  * **Strong Encapsulation:** Prevents misuse and simplifies the public API of a class.
  * **Refactoring Ease:** Private members can be changed or removed without affecting any code outside the class.
  * **Testability:** Can make direct unit testing harder, often requiring indirect testing through public methods or using reflection (which is generally discouraged for testing internal logic).

**Code Example:**

```csharp
// Assembly A: MyPrivateComponent.dll
namespace MyPrivateComponent
{
    public class OrderProcessor
    {
        private decimal _totalAmount; // Private field, only accessible within OrderProcessor

        public OrderProcessor()
        {
            _totalAmount = 0;
            Console.WriteLine("OrderProcessor created.");
        }

        public void AddItem(decimal price, int quantity)
        {
            if (price <= 0 || quantity <= 0)
            {
                // Internal validation method
                LogValidationError("Invalid item price or quantity.");
                return;
            }
            _totalAmount += price * quantity;
            CalculateDiscount(); // Internal helper method
            Console.WriteLine($"Item added. Current total: {_totalAmount:C}");
        }

        public decimal GetCurrentTotal()
        {
            return _totalAmount;
        }

        private void CalculateDiscount() // Private method
        {
            if (_totalAmount > 1000)
            {
                _totalAmount *= 0.95m; // Apply 5% discount
                Console.WriteLine("  5% discount applied!");
            }
        }

        private void LogValidationError(string message) // Private method
        {
            Console.WriteLine($"Error: {message}");
        }
    }
}
```

```csharp
// Assembly B: MyApplication.exe (references MyPrivateComponent.dll)
using MyPrivateComponent;
using System;

public class Program
{
    public static void Main(string[] args)
    {
        OrderProcessor processor = new OrderProcessor();
        processor.AddItem(100.00m, 5); // OK
        processor.AddItem(500.00m, 2); // OK (triggers discount)
        // processor._totalAmount = 0; // Error: _totalAmount is private
        // processor.CalculateDiscount(); // Error: CalculateDiscount is private
        // processor.LogValidationError("Test"); // Error: LogValidationError is private
        Console.WriteLine($"Final total: {processor.GetCurrentTotal():C}"); // OK
    }
}
```

-----

### 3\. `protected`

**Definition:** The `protected` keyword means that the member is accessible within its containing class and by derived class instances. It establishes a contract with subclasses.

**When to Use:**

  * **Base Class Functionality:** When you design a base class and want to provide members that are essential for the proper functioning or extension of derived classes, but should not be exposed to general public consumers.
  * **Template Method Pattern:** Often used for methods that are part of an algorithm defined in the base class, where subclasses are expected to provide specific implementations for certain steps.
  * **Internal State for Subclasses:** Fields or properties that subclasses need to access or modify directly for their implementation.

**Design Implications:**

  * **Controlled Extension:** Allows extensibility while still maintaining a degree of encapsulation from external consumers.
  * **Strong Coupling to Subclasses:** Changes to `protected` members directly impact derived classes, potentially breaking their implementations. Consider this coupling when refactoring.
  * **Breaks Encapsulation (for subclasses):** While it hides from the public, it exposes internals to subclasses, which means subclasses have knowledge of and dependencies on the base class's internal structure.

**Code Example:**

```csharp
// Assembly A: MyShapesLibrary.dll
namespace MyShapesLibrary
{
    public abstract class Shape
    {
        protected double Area { get; set; } // Accessible by Shape and derived classes

        protected void CalculateArea() // Accessible by Shape and derived classes
        {
            // Complex area calculation logic, specific to each shape
            // Derived classes must implement how to get dimensions.
            Console.WriteLine("Calculating area...");
        }

        public abstract void Display(); // Public API for displaying shape
    }

    public class Circle : Shape
    {
        protected double Radius { get; set; } // Protected member in derived class

        public Circle(double radius)
        {
            Radius = radius;
            // Accessing protected member of base class
            CalculateArea();
            Area = Math.PI * Radius * Radius; // Accessing protected Area property
        }

        // Overriding public abstract method
        public override void Display()
        {
            Console.WriteLine($"Circle with Radius: {Radius}, Area: {Area:F2}");
        }
    }

    public class Rectangle : Shape
    {
        protected double Width { get; set; }
        protected double Height { get; set; }

        public Rectangle(double width, double height)
        {
            Width = width;
            Height = height;
            CalculateArea();
            Area = Width * Height;
        }

        public override void Display()
        {
            Console.WriteLine($"Rectangle with Width: {Width}, Height: {Height}, Area: {Area:F2}");
        }
    }
}
```

```csharp
// Assembly B: MyApplication.exe (references MyShapesLibrary.dll)
using MyShapesLibrary;
using System;

public class Program
{
    public static void Main(string[] args)
    {
        Circle circle = new Circle(5);
        circle.Display(); // OK

        Rectangle rectangle = new Rectangle(10, 4);
        rectangle.Display(); // OK

        // Shape s = new Circle(3); // Can't access protected members directly here
        // s.Area = 10; // Error: Area is protected
    }
}
```

-----

### 4\. `internal`

**Definition:** The `internal` keyword means that the type or member is accessible only within its defining assembly. It's the default access level for types if no modifier is specified.

**When to Use:**

  * **Component Encapsulation:** For types and members that are part of a specific component or module within a larger application, but are not intended to be exposed outside of that component's assembly.
  * **Helper Classes/Utilities:** Utility classes, data structures, or helper methods that are used across various public classes within the *same* assembly, but don't need to be public API.
  * **Testing Friendliness:** Can make testing easier for internal components without making them globally `public`.

**Design Implications:**

  * **Assembly-Level Encapsulation:** Provides a good balance between strong private encapsulation and broad public exposure. It means your internal implementation details are hidden from other assemblies, allowing independent evolution of components.
  * **Modular Design:** Supports building well-defined modules (assemblies) with clear internal and external contracts.

**Code Example:**

```csharp
// Assembly A: MyInternalComponent.dll
namespace MyInternalComponent
{
    // Internal class, only accessible within MyInternalComponent.dll
    internal class InternalLogger
    {
        internal void LogMessage(string message) // Internal method
        {
            Console.WriteLine($"[Internal Log]: {message}");
        }

        internal string GetLogFilePath() // Internal method
        {
            return "C:\\Logs\\internal_log.txt";
        }
    }

    public class PublicService
    {
        private InternalLogger _logger; // Can use internal class within public class

        public PublicService()
        {
            _logger = new InternalLogger();
        }

        public void ProcessData(string data)
        {
            _logger.LogMessage($"Processing data: {data}"); // OK
            Console.WriteLine($"Data processed using internal logger at {_logger.GetLogFilePath()}");
        }
    }
}
```

```csharp
// Assembly B: MyApplication.exe (references MyInternalComponent.dll)
using MyInternalComponent;
using System;

public class Program
{
    public static void Main(string[] args)
    {
        PublicService service = new PublicService();
        service.ProcessData("Important information"); // OK

        // InternalLogger logger = new InternalLogger(); // Error: InternalLogger is internal
        // logger.LogMessage("Direct log"); // Error
    }
}
```

-----

### 5\. `protected internal`

**Definition:** The `protected internal` keyword combines `protected` and `internal`. It means the member is accessible within its defining assembly (like `internal`) AND by derived classes, even if those derived classes are in a different assembly (like `protected`). It is a "logical OR" combination.

**When to Use:**

  * **Extensible Frameworks:** When building frameworks or libraries where certain members need to be accessible for internal use within the framework's own assembly, but also need to be overrideable or accessible by derived types in consuming applications (other assemblies).
  * **Base Class Utilities:** Utility methods in a base class that are useful for all subclasses (even external ones) but not for general public consumption.

**Design Implications:**

  * **Broader Exposure for Extension:** Provides more flexibility for extension across assembly boundaries than just `internal` or `protected` alone.
  * **Reduced Encapsulation:** It's less restrictive than `protected` alone, as any code within the defining assembly can access it, potentially exposing more than intended to internal collaborators.

**Code Example:**

```csharp
// Assembly A: MyFramework.dll
namespace MyFramework
{
    public abstract class BaseComponent
    {
        protected internal string ConfigPath { get; set; } // Accessible within MyFramework.dll AND by derived classes anywhere

        protected internal BaseComponent()
        {
            ConfigPath = "DefaultConfig.xml";
            Console.WriteLine("BaseComponent initialized.");
        }

        protected internal void LoadConfiguration() // Accessible within MyFramework.dll AND by derived classes anywhere
        {
            Console.WriteLine($"Loading configuration from {ConfigPath} (protected internal)");
        }

        public abstract void Run();
    }

    // A class within the same assembly can access protected internal members
    internal class FrameworkHelper
    {
        public void HelperMethod(BaseComponent component)
        {
            // Can access ConfigPath because HelperClass is internal to MyFramework.dll
            Console.WriteLine($"Helper accessing config path: {component.ConfigPath}");
            component.LoadConfiguration(); // Can access protected internal method
        }
    }
}
```

```csharp
// Assembly B: MyApplication.exe (references MyFramework.dll)
using MyFramework;
using System;

public class MyCustomComponent : BaseComponent // Derived class in a different assembly
{
    public MyCustomComponent(string customConfig)
    {
        // Can access protected internal ConfigPath from base class
        ConfigPath = customConfig;
        LoadConfiguration(); // Can access protected internal method from base class
        Console.WriteLine("MyCustomComponent initialized.");
    }

    public override void Run()
    {
        Console.WriteLine($"Running custom component with config: {ConfigPath}");
    }
}

public class Program
{
    public static void Main(string[] args)
    {
        MyCustomComponent component = new MyCustomComponent("CustomAppConfig.xml");
        component.Run(); // OK

        // BaseComponent baseComp = new BaseComponent(); // Cannot instantiate abstract class
        // baseComp.LoadConfiguration(); // Error: LoadConfiguration is protected internal (not accessible from non-derived, external code)
    }
}
```

-----

### 6\. `private protected` (C\# 7.2+)

**Definition:** The `private protected` keyword combines `private` and `protected`. It means the member is accessible only within its containing class AND by derived classes *that are in the same assembly*. It is a "logical AND" combination.

**When to Use:**

  * **Refined Base Class Access:** When you want to provide internal members in a base class that should be accessible to its immediate subclasses but only if those subclasses are part of the same assembly (i.e., part of the same logical component).
  * **Preventing External Overrides:** Useful for methods that are designed to be part of the base class's internal implementation flow and can be overridden by *internal* subclasses, but should not be visible or overridable by subclasses in *other* assemblies.

**Design Implications:**

  * **Stricter Control than `protected internal`:** Offers a tighter encapsulation boundary for base class extensibility, limiting it to the same assembly.
  * **Complex Scenarios:** Less common than other modifiers but valuable in specific architectural patterns.

**Code Example:**

```csharp
// Assembly A: MyAdvancedComponent.dll
namespace MyAdvancedComponent
{
    public abstract class WorkflowStep
    {
        private protected string _stepId; // Accessible by WorkflowStep and derived classes in same assembly

        public WorkflowStep(string stepId)
        {
            _stepId = stepId;
            Console.WriteLine($"WorkflowStep {_stepId} created.");
        }

        // This method can only be overridden/accessed by derived classes within MyAdvancedComponent.dll
        private protected virtual void LogExecutionStart()
        {
            Console.WriteLine($"[{_stepId}] Starting execution...");
        }

        // This method can only be overridden/accessed by derived classes within MyAdvancedComponent.dll
        private protected virtual void LogExecutionEnd()
        {
            Console.WriteLine($"[{_stepId}] Execution finished.");
        }

        public abstract void Execute(); // Public contract for execution
    }

    public class ValidationStep : WorkflowStep
    {
        public ValidationStep(string stepId) : base(stepId) { }

        // Can override private protected method because ValidationStep is in the same assembly
        private protected override void LogExecutionStart()
        {
            Console.WriteLine($"[{_stepId}] Performing validation check...");
        }

        public override void Execute()
        {
            LogExecutionStart(); // Can access private protected method
            Console.WriteLine($"[{_stepId}] Validation logic executed.");
            LogExecutionEnd();
        }
    }

    public class ProcessingStep : WorkflowStep
    {
        public ProcessingStep(string stepId) : base(stepId) { }

        public override void Execute()
        {
            LogExecutionStart();
            Console.WriteLine($"[{_stepId}] Processing data...");
            LogExecutionEnd();
        }
    }
}
```

```csharp
// Assembly B: MyApplication.exe (references MyAdvancedComponent.dll)
using MyAdvancedComponent;
using System;

public class ExternalLoggingStep : WorkflowStep // Derived class in a different assembly
{
    public ExternalLoggingStep(string stepId) : base(stepId) { }

    public override void Execute()
    {
        // LogExecutionStart(); // Error: LogExecutionStart is private protected
                               // Accessible only by derived types declared in MyAdvancedComponent.dll
        Console.WriteLine($"[{_stepId}] Executing external logging step.");
    }
}

public class Program
{
    public static void Main(string[] args)
    {
        ValidationStep validation = new ValidationStep("Step_A");
        validation.Execute(); // Output will show custom log for ValidationStep

        ProcessingStep processing = new ProcessingStep("Step_B");
        processing.Execute(); // Output will show default log for ProcessingStep

        ExternalLoggingStep external = new ExternalLoggingStep("Step_C");
        external.Execute(); // Output will not show base class LogExecutionStart/End calls
                            // because they are not accessible.
    }
}
```

-----

### Access Modifiers in Inheritance and Interfaces

**Inheritance:**

  * **`public`:** Inherited members remain `public` and are accessible everywhere.
  * **`private`:** Not inherited. Private members of a base class are completely hidden from derived classes. A derived class cannot directly access or override a `private` member of its base class.
  * **`protected`:** Inherited members remain `protected` within the derived class, meaning the derived class can access them, and its further derived classes can also access them.
  * **`internal`:** Inherited members remain `internal`. They are accessible by the derived class *only if the derived class is in the same assembly*. If the derived class is in a different assembly, the `internal` member is not accessible.
  * **`protected internal`:** Inherited members remain `protected internal`. They are accessible by the derived class regardless of the assembly.
  * **`private protected`:** Inherited members remain `private protected`. They are accessible by the derived class *only if the derived class is in the same assembly*.

**Interfaces:**

  * All members declared in an interface are implicitly **`public`**. You cannot apply any other access modifier to interface members. This is because an interface defines a contract that must be fully implemented and exposed by any class or struct that implements it.

    ```csharp
    public interface IWorker
    {
        void Work(); // Implicitly public
        // private void DoSomethingInternal(); // Error: Interface members cannot be private
    }

    public class Developer : IWorker
    {
        public void Work() // Must be public to implement IWorker.Work()
        {
            Console.WriteLine("Developer is coding.");
        }
    }
    ```

-----

### Access Level Conflicts Across Assemblies (`internal` vs `public`)

The primary distinction between `internal` and `public` becomes apparent when dealing with multiple assemblies (DLLs or EXEs).

  * **`public`:** Makes a type or member accessible to *any* other assembly that adds a reference to the assembly where it's defined. This is your cross-assembly API.
  * **`internal`:** Restricts access to types or members *only* to code within the *same* assembly. It acts as an encapsulation boundary at the assembly level.

**Conflicts and Considerations:**

  * **Public Type, Internal Member:** A `public` class can have `internal` members. This means code outside the assembly can create instances of the `public` class, but it cannot access its `internal` members. This is a common and good design pattern for hiding implementation details.

    ```csharp
    // Assembly A
    public class MyApiClass
    {
        internal string InternalDetail { get; set; } // Only visible within Assembly A
        public string PublicData { get; set; } // Visible everywhere
    }

    // Assembly B (references Assembly A)
    // MyApiClass obj = new MyApiClass(); // OK
    // obj.InternalDetail = "value"; // Error: InternalDetail is inaccessible
    ```

  * **Internal Type, Public Member:** An `internal` class can have `public` members, but those `public` members are still effectively `internal` because the class itself is `internal`. You cannot access a `public` member of an `internal` type from outside its assembly. The visibility of the *type* dictates the maximum visibility of its members.

    ```csharp
    // Assembly A
    internal class InternalHelper
    {
        public void PublicMethodInInternalClass() // Effectively internal
        {
            Console.WriteLine("This method is public, but its class is internal.");
        }
    }

    // Assembly B (references Assembly A)
    // InternalHelper helper = new InternalHelper(); // Error: InternalHelper is inaccessible
    // helper.PublicMethodInInternalClass(); // Also inaccessible
    ```

  * **`InternalsVisibleTo` Attribute:** This is a special case. You can make `internal` types and members visible to specific "friend" assemblies by using the `[assembly: InternalsVisibleTo("FriendAssembly")]` attribute in your `AssemblyInfo.cs` (or project file). This is commonly used for unit testing `internal` components without making them `public`.

    ```csharp
    // Assembly A: MyLibrary.dll
    // In MyLibrary.csproj or AssemblyInfo.cs:
    // [assembly: System.Runtime.CompilerServices.InternalsVisibleTo("MyLibrary.Tests")]

    namespace MyLibrary
    {
        internal class HiddenImplementation
        {
            public string SecretValue { get; set; } = "Shh!";
        }

        public class PublicApi
        {
            public string GetSecret()
            {
                var hidden = new HiddenImplementation();
                return hidden.SecretValue;
            }
        }
    }
    ```

    ```csharp
    // Assembly B: MyLibrary.Tests.dll (Friend assembly specified in MyLibrary.dll)
    using MyLibrary;
    using Xunit; // Or NUnit, MSTest

    public class HiddenImplementationTests
    {
        [Fact]
        public void CanAccessInternalClassForTesting()
        {
            var hidden = new HiddenImplementation(); // OK because of InternalsVisibleTo
            Assert.Equal("Shh!", hidden.SecretValue);
        }
    }
    ```

-----

### Real-World Design Choices Using Encapsulation

Encapsulation, heavily reliant on access modifiers, is crucial for building robust, maintainable, and scalable software.

**1. Data Hiding (Fields):**

  * **Principle:** Fields (the raw data of an object) should almost always be `private`.
  * **Reason:** Direct access to fields bypasses any validation or business logic that might be associated with setting or getting a value.
  * **Design Choice:** Use `private` fields and expose them via `public` properties. This allows you to add logic in property `get`/`set` accessors.
    ```csharp
    public class Account
    {
        private decimal _balance; // Private field

        public decimal Balance // Public property for controlled access
        {
            get { return _balance; }
            private set // Private setter: can only be set internally
            {
                if (value < 0) throw new ArgumentOutOfRangeException("Balance cannot be negative.");
                _balance = value;
            }
        }

        public void Deposit(decimal amount)
        {
            if (amount <= 0) throw new ArgumentOutOfRangeException("Deposit amount must be positive.");
            Balance += amount; // Uses the private setter
        }

        public void Withdraw(decimal amount)
        {
            if (amount <= 0) throw new ArgumentOutOfRangeException("Withdrawal amount must be positive.");
            if (Balance < amount) throw new InvalidOperationException("Insufficient funds.");
            Balance -= amount; // Uses the private setter
        }
    }
    ```

**2. Component/Module Boundary (Internal):**

  * **Principle:** When building a larger application composed of several logical modules, each module (often an assembly) should expose only its public API, keeping its internal workings hidden.

  * **Reason:** This reduces coupling between modules. Changes within one module's `internal` implementation don't affect other modules, enabling independent development and deployment.

  * **Design Choice:**

      * `public` types for the module's core contracts and entry points.
      * `internal` types for all helper classes, utility functions, data structures, and private implementations used *only* by other types within that same module's assembly.

    <!-- end list -->

    ```csharp
    // PaymentGateway.dll
    namespace PaymentGateway
    {
        // Public API for other assemblies
        public class PaymentService
        {
            private InternalPaymentProcessor _processor;
            public PaymentService() { _processor = new InternalPaymentProcessor(); }
            public bool ProcessPayment(decimal amount, string cardNumber) { /* ... */ return _processor.ExecutePayment(amount, cardNumber); }
        }

        // Internal helper class, hidden from outside assemblies
        internal class InternalPaymentProcessor
        {
            internal bool ExecutePayment(decimal amount, string cardNumber)
            {
                Console.WriteLine("Executing internal payment logic...");
                // Complex logic for payment processing, error handling, etc.
                return true;
            }
        }
    }
    ```

**3. Base Class Extensibility (Protected):**

  * **Principle:** Design base classes to be extended by subclasses while protecting core logic.

  * **Reason:** Provides a framework for consistent behavior across related types without exposing the entire implementation to the world.

  * **Design Choice:**

      * `public` methods for the overall workflow (e.g., Template Method Pattern).
      * `protected` methods that subclasses *must* implement or *can* override to customize specific steps of the workflow.
      * `private` methods for steps that are completely internal to the base class and should never be seen or touched by subclasses.

    <!-- end list -->

    ```csharp
    public abstract class ReportGenerator
    {
        protected List<string> _dataRows = new List<string>(); // Protected field for subclass access

        public void GenerateReport() // Public Template Method
        {
            FetchData();       // Hook method (defined as protected abstract/virtual)
            ProcessData();     // Protected internal helper
            FormatReport();    // Private internal implementation
            OutputReport();    // Hook method
        }

        protected abstract void FetchData(); // Must be implemented by subclasses

        protected internal virtual void ProcessData() // Can be overridden by subclasses or accessed internally
        {
            Console.WriteLine("Generic data processing...");
            // ... common processing logic ...
        }

        private void FormatReport() // Internal detail of base class
        {
            Console.WriteLine("Formatting report (private to base class)...");
        }

        protected abstract void OutputReport(); // Must be implemented by subclasses
    }

    public class PdfReportGenerator : ReportGenerator
    {
        protected override void FetchData()
        {
            Console.WriteLine("Fetching data for PDF report...");
            _dataRows.Add("PDF Row 1");
        }
        protected override void OutputReport() { Console.WriteLine("Outputting PDF report..."); }
    }
    ```

By consciously choosing the right access modifier for each type and member, you effectively control the "surface area" of your code, making it:

  * **Safer:** Prevents incorrect usage.
  * **Easier to Understand:** Reduces cognitive load by hiding irrelevant details.
  * **More Maintainable:** Allows internal refactoring without breaking external dependencies.
  * **More Scalable:** Facilitates independent development and deployment of components.