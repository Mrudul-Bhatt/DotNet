Let's break down these questions, drawing on practical experiences with generics in C\#.

### Have you implemented a custom generic repository in your projects? What did it contain?

Yes, a custom generic repository is a very common pattern implemented in many data-driven applications, especially when not using a full-fledged ORM like Entity Framework (or even when using EF but wanting to add another layer of abstraction/consistency).

**What it typically contained:**

A generic repository usually abstracts common CRUD (Create, Read, Update, Delete) operations for various entity types within an application.

**Typical Structure:**

```csharp
// 1. The Generic Interface
public interface IGenericRepository<TEntity> where TEntity : class
{
    // C - Create
    void Add(TEntity entity);

    // R - Read
    TEntity GetById(object id); // 'object' for ID type flexibility, though better to use TId (see below)
    IEnumerable<TEntity> GetAll();
    IEnumerable<TEntity> Find(Expression<Func<TEntity, bool>> predicate); // For filtered reads

    // U - Update
    void Update(TEntity entity);

    // D - Delete
    void Delete(TEntity entity);
    void Delete(object id); // Delete by ID

    // Unit of Work pattern integration (optional but common)
    // SaveChanges() is usually part of a Unit of Work, not the repository directly.
    // However, for simpler scenarios, it might be in the repo.
    // void SaveChanges(); // If not using a separate Unit of Work
}

// 2. The Generic Implementation (often abstract or base class)
public abstract class GenericRepository<TEntity> : IGenericRepository<TEntity> where TEntity : class
{
    // This is where the actual data access technology would be integrated.
    // For example, if using ADO.NET directly, this would hold connection/command logic.
    // If using EF, it would hold the DbContext.
    protected readonly DbContext _dbContext; // Example for EF Core

    public GenericRepository(DbContext dbContext)
    {
        _dbContext = dbContext;
    }

    public virtual void Add(TEntity entity)
    {
        _dbContext.Set<TEntity>().Add(entity);
    }

    public virtual TEntity GetById(object id)
    {
        // This method depends heavily on how IDs are handled for TEntity.
        // For EF Core, Find() works well for primary keys.
        return _dbContext.Set<TEntity>().Find(id);
    }

    public virtual IEnumerable<TEntity> GetAll()
    {
        return _dbContext.Set<TEntity>().ToList();
    }

    public virtual IEnumerable<TEntity> Find(Expression<Func<TEntity, bool>> predicate)
    {
        return _dbContext.Set<TEntity>().Where(predicate).ToList();
    }

    public virtual void Update(TEntity entity)
    {
        _dbContext.Set<TEntity>().Update(entity);
        // Or for EF, often just attaching and setting state: _dbContext.Entry(entity).State = EntityState.Modified;
    }

    public virtual void Delete(TEntity entity)
    {
        _dbContext.Set<TEntity>().Remove(entity);
    }

    public virtual void Delete(object id)
    {
        // Fetch the entity first, then delete
        var entityToDelete = GetById(id);
        if (entityToDelete != null)
        _dbContext.Set<TEntity>().Remove(entityToDelete);
    }
}

// 3. Specific Repositories (if needed for entity-specific operations)
public interface IProductRepository : IGenericRepository<Product>
{
    // Specific operations for Product beyond generic CRUD
    IEnumerable<Product> GetProductsByCategory(string category);
}

public class ProductRepository : GenericRepository<Product>, IProductRepository
{
    public ProductRepository(DbContext dbContext) : base(dbContext) { }

    public IEnumerable<Product> GetProductsByCategory(string category)
    {
        return _dbContext.Set<Product>().Where(p => p.Category == category).ToList();
    }
}

// And a better IGenericRepository with a generic ID type (if all entities have same ID type)
public interface IGenericRepository<TEntity, TId> where TEntity : class
{
    TEntity GetById(TId id);
    // ... rest of the methods
}

// Or even better, just let the ORM handle simple GetById for primary keys,
// and rely on LINQ's Where for most read operations.
```

**Benefits of this structure:**

  * **Code Reusability:** The `GenericRepository` base class contains common CRUD logic that doesn't need to be rewritten for every entity.
  * **Abstraction:** Consumers of the repository interact with `IRepository<TEntity>`, not the specific data access implementation details.
  * **Testability:** Easier to mock or stub the `IRepository<TEntity>` interface for unit testing services that depend on data access.
  * **Compile-time Safety:** Generics ensure that you're working with the correct entity type at compile time.

**Common Contents & Considerations:**

  * **`DbContext` (or similar data context):** For ORMs like Entity Framework, the `DbContext` instance is usually injected into the generic repository.
  * **`DbSet<TEntity>` (or similar collection):** The repository operates on a specific `DbSet` corresponding to `TEntity`.
  * **`Expression<Func<TEntity, bool>> predicate`:** For `Find` operations, this allows passing LINQ expressions (which can be translated to SQL by ORMs) for filtering.
  * **`Func<IQueryable<TEntity>, IOrderedQueryable<TEntity>> orderBy` (optional):** For common sorting needs, allowing ordering to be specified.
  * **`string includeProperties` (optional):** For eager loading related entities (e.g., in EF, for `Include()`).
  * **`TId` for `GetById` (as discussed above):** Making the ID type generic allows for entities with `Guid`, `string`, or `int` IDs.
  * **Unit of Work:** Often, the `SaveChanges()` method (or equivalent) is placed in a separate `IUnitOfWork` interface/class that orchestrates multiple repository operations within a single transaction.

### Describe a scenario where generics helped reduce code duplication in your work.

A common scenario where generics drastically reduce code duplication is in **data transformation and mapping utilities**.

**Scenario: Standardizing API Response Transformation**

Imagine you're building a web API that exposes data from various internal services or databases. For consistency, you want all API responses to adhere to a common structure (e.g., `ApiResponse<TData>`). Additionally, you might need to perform common transformations or enrichments on the data before returning it, such as:

  * Adding metadata (timestamp, status code).
  * Masking sensitive information.
  * Applying common formatting.
  * Handling pagination.

**Without Generics (Code Duplication):**

You would have a separate method for each type of data:

```csharp
public class UserDto { /* ... */ }
public class ProductDto { /* ... */ }

public class ApiResponse
{
    public int StatusCode { get; set; }
    public string Message { get; set; }
    // ... and then type-specific data properties
    public UserDto UserData { get; set; }
    public ProductDto ProductData { get; set; }
    // ... this quickly becomes unmanageable
}

public ApiResponse GetUserResponse(UserDto user)
{
    return new ApiResponse
    {
        StatusCode = 200,
        Message = "User fetched.",
        UserData = user
    };
}

public ApiResponse GetProductResponse(ProductDto product)
{
    return new ApiResponse
    {
        StatusCode = 200,
        Message = "Product fetched.",
        ProductData = product
    };
}
// ... and so on for every DTO type
```

**With Generics (Reduced Duplication):**

You can define a single generic `ApiResponse<TData>` class and a generic utility method to create standardized responses.

```csharp
public class ApiResponse<TData>
{
    public int StatusCode { get; set; }
    public string Message { get; set; }
    public TData Data { get; set; } // Generic data payload
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;
    // Potentially other common properties like PagingInfo
}

public static class ApiResponseFactory
{
    public static ApiResponse<TData> CreateSuccessResponse<TData>(TData data, string message = "Operation successful.")
    {
        return new ApiResponse<TData>
        {
            StatusCode = 200,
            Message = message,
            Data = data
        };
    }

    public static ApiResponse<TData> CreateNotFoundResponse<TData>(string message = "Resource not found.")
    {
        return new ApiResponse<TData>
        {
            StatusCode = 404,
            Message = message,
            Data = default(TData) // Data will be null or default value
        };
    }

    // You could even have a generic method for applying common transformations
    public static IEnumerable<TOutput> ApplyCommonTransformations<TInput, TOutput>(
        IEnumerable<TInput> input,
        Func<TInput, TOutput> transformer)
    {
        foreach (var item in input)
        {
            // Simulate some common logic (e.g., logging, validation)
            yield return transformer(item);
        }
    }
}

// Usage in an API controller:
public class UsersController // (Simplified example)
{
    // ...
    public ApiResponse<UserDto> GetUser(int id)
    {
        UserDto user = new UserDto { Name = "John Doe", Email = "john@example.com" }; // Fetch from service
        if (user == null)
        {
            return ApiResponseFactory.CreateNotFoundResponse<UserDto>();
        }
        return ApiResponseFactory.CreateSuccessResponse(user, "User retrieved successfully.");
    }

    public ApiResponse<List<ProductDto>> GetProducts()
    {
        List<Product> products = new List<Product> { /* ... raw products ... */ };
        // Use generic transformation
        var productDtos = ApiResponseFactory.ApplyCommonTransformations(
            products,
            p => new ProductDto { Name = p.Name, Price = p.Price * 1.05m } // Example: add 5% margin
        ).ToList();

        return ApiResponseFactory.CreateSuccessResponse(productDtos);
    }
}
```

By using generics, the `ApiResponse<TData>` class and the `ApiResponseFactory` methods are written once and can handle any data type (`UserDto`, `ProductDto`, `List<ProductDto>`, etc.). This eliminates repetitive code for each response type, making the API more consistent, maintainable, and less prone to errors.

### Have you ever worked with built-in generic interfaces like IEnumerable\<T\>, IComparer\<T\>, etc.? How?

Absolutely, these built-in generic interfaces are fundamental to C\# development and are used constantly.

1.  **`IEnumerable<T>` (and `IEnumerator<T>`):**

      * **How:** This is the bedrock of LINQ and collections. Almost every collection class in .NET implements `IEnumerable<T>` (e.g., `List<T>`, `Array`, `Dictionary<TKey, TValue>`). When you use a `foreach` loop, or any LINQ extension method (like `Where`, `Select`, `OrderBy`), you're working with `IEnumerable<T>`.
      * **Scenario:** Processing any sequence of data.
      * **Example:**
        ```csharp
        public void ProcessDataCollection<T>(IEnumerable<T> data)
        {
            Console.WriteLine($"\n--- Processing {typeof(T).Name} Collection ---");
            foreach (var item in data) // foreach works with IEnumerable<T>
            {
                Console.WriteLine($"  Item: {item}");
            }

            // Using LINQ (all LINQ methods operate on IEnumerable<T>)
            var filteredItems = data.Where(item => item != null).ToList();
            Console.WriteLine($"  Filtered count: {filteredItems.Count}");
        }

        // Usage:
        List<int> numbers = new List<int> { 1, 2, 3 };
        ProcessDataCollection(numbers); // T is int

        string[] names = { "Alice", "Bob", "Charlie" };
        ProcessDataCollection(names); // T is string
        ```

2.  **`IComparer<T>` (and `IComparable<T>`):**

      * **How:** These interfaces define how instances of a type can be compared to each other. `IComparable<T>` is for types that *can compare themselves* (e.g., `int`, `string`). `IComparer<T>` is for types that *can compare two other objects* (used by sorting algorithms).

      * **Scenario:** Customizing sorting logic for collections (e.g., sorting a list of objects by a specific property, or by multiple properties).

      * **Example:** Sorting a list of `Product` objects by price, then by name for ties.

        ```csharp
        public class ProductComparerByPriceThenName : IComparer<Product>
        {
            public int Compare(Product x, Product y)
            {
                int priceComparison = x.Price.CompareTo(y.Price);
                if (priceComparison != 0)
                {
                    return priceComparison; // If prices differ, sort by price
                }
                // If prices are the same, sort by name
                return string.Compare(x.Name, y.Name, StringComparison.OrdinalIgnoreCase);
            }
        }

        // Usage:
        List<Product> products = new List<Product>
        {
            new Product { Name = "Mouse", Price = 25m },
            new Product { Name = "Keyboard", Price = 75m },
            new Product { Name = "Monitor", Price = 250m },
            new Product { Name = "Webcam", Price = 25m } // Same price as Mouse
        };

        Console.WriteLine("\n--- Products before sorting ---");
        products.ForEach(p => Console.WriteLine($"{p.Name} ({p.Price:C})"));

        products.Sort(new ProductComparerByPriceThenName()); // List<T>.Sort accepts IComparer<T>

        Console.WriteLine("\n--- Products after custom sorting ---");
        products.ForEach(p => Console.WriteLine($"{p.Name} ({p.Price:C})"));
        // Output will show Mouse before Webcam because 'M' comes before 'W'
        ```

3.  **`IDictionary<TKey, TValue>`:**

      * **How:** Represents a generic collection of key/value pairs. Provides type-safe access to elements by key.
      * **Scenario:** Creating maps, caches, or lookup tables where both keys and values are strongly typed.
      * **Example:**
        ```csharp
        IDictionary<string, int> cityPopulations = new Dictionary<string, int>();
        cityPopulations["Mumbai"] = 20000000;
        cityPopulations["Delhi"] = 18000000;
        // ...
        ```

### Have you ever written a generic method that accepts two different types? How did you handle type safety?

Yes, writing generic methods with multiple type parameters is common, especially for operations that involve comparing or combining data from different sources or types.

**Scenario: A Generic Comparison Utility**

A method that checks if two objects (potentially of different types) are "equivalent" based on a specified common key or property.

```csharp
public static class ComparisonUtility
{
    // T1 and T2 are the two different types.
    // TKey is the common type for the property we're comparing.
    public static bool AreEquivalent<T1, T2, TKey>(
        T1 obj1,
        T2 obj2,
        Func<T1, TKey> keySelector1, // Function to extract the key from T1
        Func<T2, TKey> keySelector2) // Function to extract the key from T2
        where TKey : IComparable<TKey> // Constraint: TKey must be comparable
    {
        if (obj1 == null || obj2 == null)
        {
            return false; // Or throw ArgumentNullException, depending on desired behavior
        }

        TKey key1 = keySelector1(obj1);
        TKey key2 = keySelector2(obj2);

        // Type safety is handled by:
        // 1. The generic type parameters T1, T2, TKey themselves.
        // 2. The Func delegates which ensure that keySelector1 returns TKey from T1, etc.
        // 3. The where TKey : IComparable<TKey> constraint, allowing CompareTo.
        return key1.CompareTo(key2) == 0;
    }
}

public class Order
{
    public int OrderId { get; set; }
    public decimal Amount { get; set; }
}

public class Invoice
{
    public int ReferenceId { get; set; } // This maps to OrderId
    public decimal InvoiceAmount { get; set; }
}

public static void TwoDifferentTypesGenericMethodExample()
{
    Console.WriteLine("\n--- Generic Method with Two Types Example ---");

    Order order = new Order { OrderId = 123, Amount = 150.00m };
    Invoice invoice = new Invoice { ReferenceId = 123, InvoiceAmount = 150.00m };
    Invoice otherInvoice = new Invoice { ReferenceId = 456, InvoiceAmount = 200.00m };

    // Check if order and invoice are equivalent by their ID
    bool areSameOrder = ComparisonUtility.AreEquivalent(
        order,
        invoice,
        o => o.OrderId,      // Extracts int from Order
        i => i.ReferenceId); // Extracts int from Invoice

    Console.WriteLine($"Order and Invoice (123) are equivalent: {areSameOrder}"); // True

    bool areSameOrderWithOtherInvoice = ComparisonUtility.AreEquivalent(
        order,
        otherInvoice,
        o => o.OrderId,
        i => i.ReferenceId);

    Console.WriteLine($"Order and Invoice (456) are equivalent: {areSameOrderWithOtherInvoice}"); // False

    // Compile-time error if type safety is violated:
    // ComparisonUtility.AreEquivalent(order, invoice, o => o.OrderId, i => i.InvoiceAmount);
    // ^^^ This would be a compile-time error because TKey would be inferred as 'int' from OrderId,
    // but InvoiceAmount is 'decimal', violating the Func<Invoice, int> expectation.
}
```

**How Type Safety is Handled:**

1.  **Generic Type Parameters (`T1`, `T2`, `TKey`):** The method signature itself defines the types involved. The compiler ensures that when you call `AreEquivalent`, the arguments you provide (`obj1`, `obj2`) match `T1` and `T2`, and the return types of your `keySelector` functions match `TKey`.
2.  **`Func` Delegates:** `Func<T1, TKey>` and `Func<T2, TKey>` explicitly state that the provided lambda or method must take an argument of type `T1` (or `T2`) and return a value of type `TKey`. This enforces the correct type mapping at compile time.
3.  **Constraints (`where TKey : IComparable<TKey>`):** This constraint ensures that `TKey` is a type that *knows how to compare itself* to another instance of `TKey`. Without this, you couldn't call `key1.CompareTo(key2)`. The compiler checks this constraint when the method is called.

### How did you design a service class that reused logic using generics?

A common pattern for reusing logic with generics in a service class is to create a **Generic Base Service** that handles common operations for various domain entities, often working in conjunction with a generic repository.

**Scenario: Standardizing CRUD Operations and Business Rule Application for Entities**

Imagine an application with multiple domain entities (Users, Products, Orders). Each entity needs basic CRUD operations, and some common business rules (e.g., validation, auditing) apply to most of them before saving.

**Design:**

1.  **Generic Base Service (`BaseService<TEntity>`):**

      * Takes an `IRepository<TEntity>` as a dependency (using Dependency Injection).
      * Implements common `Add`, `Get`, `Update`, `Delete` methods.
      * Provides "hooks" (virtual methods or delegates) for pre/post-operation logic that can be overridden by specific services.
      * Applies common business logic (e.g., auditing).

2.  **Specific Services (e.g., `UserService`, `ProductService`):**

      * Inherit from `BaseService<TEntity>`.
      * Override the "hooks" to implement entity-specific business rules or validations.
      * Add entity-specific methods that don't fit the generic CRUD pattern.

**Code Example:**

```csharp
// (Reusing IGenericRepository and Product from previous examples)

// 1. Generic Base Service
public abstract class BaseService<TEntity> where TEntity : class
{
    protected readonly IGenericRepository<TEntity> _repository;

    public BaseService(IGenericRepository<TEntity> repository)
    {
        _repository = repository;
    }

    // Common CRUD methods
    public virtual TEntity GetById(object id)
    {
        return _repository.GetById(id);
    }

    public virtual IEnumerable<TEntity> GetAll()
    {
        return _repository.GetAll();
    }

    public virtual void Add(TEntity entity)
    {
        // Apply common pre-add logic (e.g., auditing if IAuditable)
        if (entity is IAuditable auditableEntity)
        {
            auditableEntity.AuditDate = DateTime.UtcNow;
            auditableEntity.AuditUser = "System"; // Or from current user context
            Console.WriteLine($"[BaseService] Auditing new {typeof(TEntity).Name}.");
        }

        // Call the specific pre-add hook
        OnBeforeAdd(entity);

        _repository.Add(entity);
        Console.WriteLine($"[BaseService] Added {typeof(TEntity).Name}.");

        // Call the specific post-add hook
        OnAfterAdd(entity);
    }

    public virtual void Update(TEntity entity)
    {
        // Apply common pre-update logic
        if (entity is IAuditable auditableEntity)
        {
            auditableEntity.AuditDate = DateTime.UtcNow;
            auditableEntity.AuditUser = "SystemUpdate";
            Console.WriteLine($"[BaseService] Auditing update for {typeof(TEntity).Name}.");
        }
        OnBeforeUpdate(entity);
        _repository.Update(entity);
        Console.WriteLine($"[BaseService] Updated {typeof(TEntity).Name}.");
        OnAfterUpdate(entity);
    }

    public virtual void Delete(object id)
    {
        OnBeforeDelete(id);
        _repository.Delete(id);
        Console.WriteLine($"[BaseService] Deleted {typeof(TEntity).Name} with ID {id}.");
        OnAfterDelete(id);
    }

    // "Hooks" for specific services to override
    protected virtual void OnBeforeAdd(TEntity entity) { }
    protected virtual void OnAfterAdd(TEntity entity) { }
    protected virtual void OnBeforeUpdate(TEntity entity) { }
    protected virtual void OnAfterUpdate(TEntity entity) { }
    protected virtual void OnBeforeDelete(object id) { }
    protected virtual void OnAfterDelete(object id) { }
}

// 2. Specific Service (inheriting from generic base)
public class ProductService : BaseService<Product>
{
    public ProductService(IGenericRepository<Product> repository) : base(repository) { }

    // Override hooks for Product-specific logic
    protected override void OnBeforeAdd(Product product)
    {
        if (string.IsNullOrWhiteSpace(product.Name))
        {
            throw new ArgumentException("Product name cannot be empty.");
        }
        Console.WriteLine($"[ProductService] Performing product-specific validation for {product.Name}.");
    }

    protected override void OnAfterAdd(Product product)
    {
        Console.WriteLine($"[ProductService] Notifying inventory for new product: {product.Name}");
        // Example: Call an inventory service
    }

    // Product-specific method, not part of generic CRUD
    public IEnumerable<Product> GetLowStockProducts(int threshold)
    {
        // This would call a specific repository method or use _repository.Find
        Console.WriteLine($"[ProductService] Getting products below stock threshold: {threshold}");
        return _repository.GetAll().Where(p => p.Price < 100 && p.Id > 0); // Simplified logic
    }
}

// (For demonstration, assume a simple in-memory DbContext and Product entity with IAuditable)
public class InMemoryDbContext
{
    public DbSet<Product> Products { get; set; } = new DbSet<Product>();
}

// Dummy DbSet for InMemoryDbContext
public class DbSet<T> : List<T> where T : class { }

public static void GenericServiceExample()
{
    Console.WriteLine("\n--- Generic Service Example ---");

    var dbContext = new InMemoryDbContext();
    var genericRepo = new ProductRepository(dbContext); // Needs a dbContext to instantiate
    var productService = new ProductService(genericRepo);

    productService.Add(new Product { Name = "New Gadget", Price = 50m });

    try
    {
        productService.Add(new Product { Name = "", Price = 10m }); // Will throw validation error
    }
    catch (ArgumentException ex)
    {
        Console.Error.WriteLine($"Error caught: {ex.Message}");
    }

    var allProducts = productService.GetAll();
    Console.WriteLine($"Total products: {allProducts.Count()}");

    var lowStock = productService.GetLowStockProducts(50);
    Console.WriteLine($"Low stock products found: {lowStock.Count()}");
}
```

This design leverages generics to:

  * **Reuse Core Logic:** The `BaseService` handles the boilerplate CRUD calls to the repository and common cross-cutting concerns like auditing.
  * **Encapsulate Specific Logic:** `ProductService` adds its unique business rules and methods without duplicating the common CRUD scaffolding.
  * **Maintain Type Safety:** All operations are strongly typed for `Product` within `ProductService` and for `TEntity` within `BaseService`, caught at compile time.
  * **Promote Extensibility:** New entity services can be easily added by inheriting from `BaseService` and overriding specific methods.