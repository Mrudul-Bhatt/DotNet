Let's dive into Generic Classes, Interfaces, and Methods in C\#, focusing on their definition, usage, and the benefits they bring to API design, type reuse, and compile-time safety.

## Generic Classes, Interfaces & Methods in C\#

Generics allow you to design classes, interfaces, and methods that defer the specification of one or more types until the class, interface, or method is declared and instantiated by client code. This means you can write a class (or method, or interface) once and use it with various data types without having to duplicate code.

### Understanding how to define and use generics

The core concept is the **type parameter**, which is a placeholder for a specific data type that will be provided later. Type parameters are typically represented by a single uppercase letter, like `T` (for Type), `TKey`, `TValue`, etc.

#### 1\. Generic Classes

**Definition:** A class defined with one or more type parameters.

**Use Case:** Creating data structures or utility classes that can work with any data type while maintaining type safety.

**Example: A Generic Stack**

A stack is a Last-In, First-Out (LIFO) collection. A generic stack can hold elements of any specified type.

```csharp
public class GenericStack<T> // T is the type parameter
{
    private T[] _items;
    private int _top;
    private const int DefaultCapacity = 10;

    public GenericStack(int capacity = DefaultCapacity)
    {
        _items = new T[capacity];
        _top = -1; // -1 indicates an empty stack
    }

    public int Count => _top + 1;
    public bool IsEmpty => _top == -1;
    public bool IsFull => Count == _items.Length;

    public void Push(T item)
    {
        if (IsFull)
        {
            // In a real implementation, you'd resize the array
            throw new InvalidOperationException("Stack is full.");
        }
        _items[++_top] = item;
        Console.WriteLine($"Pushed: {item}");
    }

    public T Pop()
    {
        if (IsEmpty)
        {
            throw new InvalidOperationException("Stack is empty.");
        }
        T item = _items[_top--];
        Console.WriteLine($"Popped: {item}");
        return item;
    }

    public T Peek()
    {
        if (IsEmpty)
        {
            throw new InvalidOperationException("Stack is empty.");
        }
        return _items[_top];
    }
}

public static void GenericClassExample()
{
    Console.WriteLine("--- Generic Stack Example ---");

    // Using GenericStack with integers
    GenericStack<int> intStack = new GenericStack<int>();
    intStack.Push(10);
    intStack.Push(20);
    Console.WriteLine($"Peek: {intStack.Peek()}"); // Output: Peek: 20
    intStack.Pop();
    intStack.Pop();
    // intStack.Pop(); // This would throw an exception

    Console.WriteLine("\n");

    // Using GenericStack with strings
    GenericStack<string> stringStack = new GenericStack<string>();
    stringStack.Push("Hello");
    stringStack.Push("World");
    Console.WriteLine($"Peek: {stringStack.Peek()}"); // Output: Peek: World
    stringStack.Pop();
    stringStack.Push("C#");
    Console.WriteLine($"Current Count: {stringStack.Count}"); // Output: Current Count: 2
}
```

#### 2\. Generic Interfaces

**Definition:** An interface defined with one or more type parameters.

**Use Case:** Defining contracts for types that operate on specific data types, allowing for polymorphic behavior with type safety. Common in collections (`IEnumerable<T>`, `IComparer<T>`) and repository patterns (`IRepository<TEntity>`).

**Example: A Generic Repository Interface**

A repository pattern abstracts data access. A generic repository can define common CRUD (Create, Read, Update, Delete) operations for any entity type.

```csharp
public interface IRepository<TEntity> where TEntity : class // TEntity is the type parameter, 'class' is a constraint
{
    TEntity GetById(int id);
    IEnumerable<TEntity> GetAll();
    void Add(TEntity entity);
    void Update(TEntity entity);
    void Delete(int id);
}

// Example Entity
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
}

// Concrete implementation of the generic interface
public class ProductRepository : IRepository<Product>
{
    private List<Product> _products = new List<Product>();
    private int _nextId = 1;

    public ProductRepository()
    {
        // Seed some data
        Add(new Product { Name = "Laptop", Price = 1200m });
        Add(new Product { Name = "Mouse", Price = 25m });
    }

    public TEntity GetById(int id)
    {
        Console.WriteLine($"Getting Product with ID: {id}");
        return _products.FirstOrDefault(p => p.Id == id) as TEntity;
    }

    public IEnumerable<TEntity> GetAll()
    {
        Console.WriteLine("Getting all Products.");
        return _products.Cast<TEntity>();
    }

    public void Add(TEntity entity)
    {
        if (entity is Product product) // Type check due to 'class' constraint
        {
            product.Id = _nextId++;
            _products.Add(product);
            Console.WriteLine($"Added Product: {product.Name} (ID: {product.Id})");
        }
    }

    public void Update(TEntity entity)
    {
        if (entity is Product updatedProduct)
        {
            var existingProduct = _products.FirstOrDefault(p => p.Id == updatedProduct.Id);
            if (existingProduct != null)
            {
                existingProduct.Name = updatedProduct.Name;
                existingProduct.Price = updatedProduct.Price;
                Console.WriteLine($"Updated Product: {updatedProduct.Name} (ID: {updatedProduct.Id})");
            }
        }
    }

    public void Delete(int id)
    {
        var productToDelete = _products.FirstOrDefault(p => p.Id == id);
        if (productToDelete != null)
        {
            _products.Remove(productToDelete);
            Console.WriteLine($"Deleted Product with ID: {id}");
        }
    }
}

public static void GenericInterfaceExample()
{
    Console.WriteLine("\n--- Generic Interface Example ---");

    IRepository<Product> productRepo = new ProductRepository();

    productRepo.Add(new Product { Name = "Keyboard", Price = 75m });

    var laptop = productRepo.GetById(1);
    if (laptop != null)
    {
        Console.WriteLine($"Found: {laptop.Name}");
    }

    var allProducts = productRepo.GetAll();
    Console.WriteLine("All Products:");
    foreach (Product p in allProducts)
    {
        Console.WriteLine($"- {p.Name} ({p.Price:C})");
    }

    laptop.Price = 1150m;
    productRepo.Update(laptop);
    Console.WriteLine($"Updated laptop price: {productRepo.GetById(1).Price:C}");
}
```

#### 3\. Generic Methods

**Definition:** A method defined with one or more type parameters. These can be part of non-generic classes, generic classes, or even static methods.

**Use Case:** Performing an operation on a specific data type without requiring the entire class to be generic. Common in utility methods, LINQ extensions (`Where<TSource>`, `Select<TSource, TResult>`), and factory methods.

**Example: A Generic Swap Method**

A simple method to swap the values of two variables of any type.

```csharp
public static class SwapUtility
{
    public static void Swap<T>(ref T a, ref T b) // T is the type parameter for the method
    {
        Console.WriteLine($"Swapping {a} and {b}...");
        T temp = a;
        a = b;
        b = temp;
        Console.WriteLine($"Swapped: {a} and {b}");
    }
}

// Example: A generic factory method
public static class Factory
{
    public static T CreateInstance<T>() where T : new() // Constraint: T must have a parameterless constructor
    {
        Console.WriteLine($"Creating instance of {typeof(T).Name}");
        return new T();
    }
}

public static void GenericMethodExample()
{
    Console.WriteLine("\n--- Generic Method Example ---");

    int x = 5, y = 10;
    SwapUtility.Swap(ref x, ref y); // T is inferred as int
    Console.WriteLine($"After swap: x={x}, y={y}"); // Output: After swap: x=10, y=5

    string s1 = "Alpha", s2 = "Beta";
    SwapUtility.Swap(ref s1, ref s2); // T is inferred as string
    Console.WriteLine($"After swap: s1={s1}, s2={s2}"); // Output: After swap: s1=Beta, s2=Alpha

    Product p1 = new Product { Name = "Gizmo" }, p2 = new Product { Name = "Widget" };
    SwapUtility.Swap(ref p1, ref p2); // T is inferred as Product
    Console.WriteLine($"After swap: p1.Name={p1.Name}, p2.Name={p2.Name}"); // Output: After swap: p1.Name=Widget, p2.Name=Gizmo

    // Using generic factory method
    Product newProduct = Factory.CreateInstance<Product>(); // T is Product
    Console.WriteLine($"Created new product with default values: Id={newProduct.Id}, Name={newProduct.Name}");
}
```

### Constraints on Type Parameters

Generics allow you to apply constraints to type parameters, restricting the types that can be used. This is crucial for enabling specific operations within the generic code while maintaining type safety.

  * `where T : class`: `T` must be a reference type.
  * `where T : struct`: `T` must be a value type (excluding nullable types).
  * `where T : new()`: `T` must have a public parameterless constructor.
  * `where T : BaseClass`: `T` must be `BaseClass` or derive from `BaseClass`.
  * `where T : IMyInterface`: `T` must implement `IMyInterface`.
  * `where T : U`: `T` must be or derive from `U` (where `U` is another type parameter).

**Example of Constraints:**

```csharp
public class DataProcessor<T> where T : IAuditable, new() // T must implement IAuditable and have a parameterless constructor
{
    public void ProcessAndAudit(T item)
    {
        item.AuditDate = DateTime.Now;
        item.AuditUser = "System";
        Console.WriteLine($"Processing and auditing {item.GetType().Name} on {item.AuditDate}");
        // Can also create new instances: T newItem = new T();
    }
}

public interface IAuditable
{
    DateTime AuditDate { get; set; }
    string AuditUser { get; set; }
}

public class Report : IAuditable
{
    public DateTime AuditDate { get; set; }
    public string AuditUser { get; set; }
    public string Title { get; set; }

    public Report() { /* Parameterless constructor */ }
}

public static void GenericConstraintsExample()
{
    Console.WriteLine("\n--- Generic Constraints Example ---");
    DataProcessor<Report> processor = new DataProcessor<Report>();
    Report myReport = new Report { Title = "Monthly Sales" };
    processor.ProcessAndAudit(myReport);
    Console.WriteLine($"Report audited by: {myReport.AuditUser}");

    // DataProcessor<string> invalidProcessor = new DataProcessor<string>(); // Compile-time error: string does not implement IAuditable or have new()
}
```

### Interview Focus: Clean API Design, Type Reuse, and Compile-Time Safety

#### 1\. Clean API Design

  * **Clarity and Intent:** Generics make the intent of your API clear. For instance, `List<T>` immediately tells you it's a list *of some type `T`*. `IRepository<TEntity>` clearly indicates a repository *for a specific entity type*.
  * **Reduced Overloads:** Without generics, you might end up with multiple overloads or methods that take `object` and require casting (e.g., `AddInt(int)`, `AddString(string)` vs. `Add<T>(T)`). Generics consolidate common logic into a single, elegant API.
  * **Self-Documenting:** The type parameters in method signatures or class definitions inherently describe what kind of types the component is designed to work with.

#### 2\. Type Reuse

  * **Write Once, Use Many:** This is the cornerstone. You write the generic algorithm or data structure logic once, and it automatically adapts to various data types without needing separate implementations for each.
      * **Example:** A generic `Sort` method doesn't care if it's sorting integers, strings, or custom objects, as long as a comparison mechanism is provided (e.g., `IComparable<T>`).
  * **Reduced Duplication (DRY Principle):** Eliminates the need to write nearly identical code for different types, reducing the codebase size and maintenance burden.
  * **Consistency:** Ensures that the same logic is applied consistently across different types, minimizing potential bugs arising from subtle differences in duplicated code.

#### 3\. Compile-Time Safety

  * **Strong Typing:** Generics provide strong typing at compile time. This is perhaps their most significant advantage over older techniques like using `object` and runtime casting.
      * **Without Generics:**
        ```csharp
        ArrayList list = new ArrayList();
        list.Add(1);
        list.Add("hello"); // No compile-time error
        int num = (int)list[1]; // Runtime error (InvalidCastException)
        ```
      * **With Generics:**
        ```csharp
        List<int> list = new List<int>();
        list.Add(1);
        // list.Add("hello"); // Compile-time error! C# prevents this
        int num = list[0]; // Type is guaranteed
        ```
  * **Early Error Detection:** Type mismatch errors are caught by the compiler, not at runtime, leading to more robust applications and faster debugging cycles.
  * **Improved IDE Support:** With strong typing, IDEs can provide better IntelliSense, auto-completion, and refactoring tools, as they know the exact types involved.

**Summary of Benefits:**

Generics are a fundamental feature of modern C\# that enables:

  * **Polymorphic code** without sacrificing type safety.
  * **Highly reusable components** that adapt to various data types.
  * **Cleaner, more readable APIs** by expressing intent precisely.
  * **Robust applications** by catching type errors at compile time rather than runtime.

By mastering generics, you can build more flexible, efficient, and reliable software systems.