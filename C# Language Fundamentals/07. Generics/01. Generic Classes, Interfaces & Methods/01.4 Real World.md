Let's explore these scenarios to illustrate how generics provide robust, reusable, and type-safe solutions in various C\# design challenges.

### Youâ€™re designing a logging utility for various types (string, int, custom objects). How would you use generics?

Generics are perfectly suited for a logging utility because the core logging mechanism (e.g., writing to a file, console, database) remains the same regardless of *what* data type is being logged. Generics allow you to accept any type while maintaining type safety and providing specific handling if needed.

**How to use Generics:**

1.  **Generic Log Method:** Define a generic method that accepts any type `T`.
    ```csharp
    public class Logger
    {
        public void Log<T>(T data, string level = "INFO")
        {
            // Use typeof(T) to get the type name for context
            string typeName = typeof(T).Name;
            string dataString;

            // Optional: Special handling for certain common types
            if (data is string strData)
            {
                dataString = strData;
            }
            else if (data is int intData)
            {
                dataString = $"Integer: {intData}";
            }
            else if (data is Exception ex) // Log exceptions specially
            {
                dataString = $"Exception: {ex.GetType().Name} - {ex.Message}\nStackTrace: {ex.StackTrace}";
                level = "ERROR"; // Force level to ERROR for exceptions
            }
            else
            {
                // For custom objects, use ToString() or JSON serialization
                dataString = data?.ToString() ?? "null"; // Default to ToString()
                // Or if you have a serializer: dataString = JsonConvert.SerializeObject(data);
            }

            Console.WriteLine($"[{DateTime.Now:HH:mm:ss} {level}] ({typeName}) {dataString}");
            // In a real app, this would write to a file, database, or a dedicated logging framework
        }

        // Overload for simply logging a message (defaults to string)
        public void Log(string message, string level = "INFO")
        {
            Log<string>(message, level);
        }
    }

    public class CustomLogObject
    {
        public int Id { get; set; }
        public string Message { get; set; }
        public override string ToString() => $"CustomObject(Id: {Id}, Msg: '{Message}')";
    }

    public static void GenericLoggingExample()
    {
        Logger logger = new Logger();

        logger.Log("Application started."); // T is inferred as string
        logger.Log(12345); // T is inferred as int
        logger.Log(true, "DEBUG"); // T is inferred as bool
        logger.Log(new CustomLogObject { Id = 1, Message = "User created" }); // T is CustomLogObject
        logger.Log(DateTime.Now); // T is DateTime

        try
        {
            throw new InvalidOperationException("Something bad happened!");
        }
        catch (Exception ex)
        {
            logger.Log(ex); // T is Exception, level defaults to ERROR
        }
    }
    ```

**Benefits of Generics in this context:**

  * **Type Safety:** The `Log<T>` method ensures that whatever data you pass in, its type is known at compile time. This prevents runtime errors that might occur if you just used `Log(object data)`.
  * **Flexibility:** It can accept *any* type without needing separate `LogInt`, `LogString`, `LogCustomObject` methods.
  * **Code Reusability:** The core logging logic (timestamp, level, output destination) is written once and reused for all types.
  * **Type-Specific Customization (Optional):** As shown, you can use `is` and `as` (or pattern matching) inside the generic method to provide specialized logging behavior for certain common types (strings, integers, exceptions, etc.) while still having a fallback for custom objects. This is a powerful combination of generics with polymorphism.

### You have services returning different models from the database. How would you build a generic API response wrapper?

This is a very common and essential use case for generics in API design, as it ensures consistent response structures across different endpoints regardless of the underlying data.

**How to build it:**

1.  **Generic Response Class:** Define a class with a type parameter `TData` that will hold the actual data payload.
    ```csharp
    public class ApiResponse<TData>
    {
        public bool IsSuccess { get; set; }
        public int StatusCode { get; set; }
        public string Message { get; set; }
        public TData Data { get; set; } // The generic data payload
        public DateTime Timestamp { get; set; } = DateTime.UtcNow;
        // Additional properties for pagination, errors list, etc., can be added here
        public List<string> Errors { get; set; } = new List<string>();

        // Private constructor to force use of static factory methods
        private ApiResponse() { }

        // Static factory method for success responses
        public static ApiResponse<TData> Success(TData data, string message = "Operation successful.")
        {
            return new ApiResponse<TData>
            {
                IsSuccess = true,
                StatusCode = 200,
                Message = message,
                Data = data
            };
        }

        // Static factory method for error responses
        public static ApiResponse<TData> Error(string message, int statusCode = 500, List<string> errors = null)
        {
            return new ApiResponse<TData>
            {
                IsSuccess = false,
                StatusCode = statusCode,
                Message = message,
                Data = default(TData), // Data will be null for error responses
                Errors = errors ?? new List<string>()
            };
        }

        // You might want a specific 'NotFound' helper
        public static ApiResponse<TData> NotFound(string message = "Resource not found.")
        {
            return Error(message, 404);
        }

        // For cases where there's no data (e.g., only status)
        public static ApiResponse<object> EmptySuccess(string message = "Operation successful.", int statusCode = 200)
        {
            return new ApiResponse<object>
            {
                IsSuccess = true,
                StatusCode = statusCode,
                Message = message,
                Data = null
            };
        }
    }

    // Example DTOs (Data Transfer Objects) returned by services
    public class UserDto { public int Id { get; set; } public string Name { get; set; } public string Email { get; set; } }
    public class OrderDto { public int Id { get; set; } public decimal TotalAmount { get; set; } public DateTime OrderDate { get; set; } }

    public static void GenericApiResponseExample()
    {
        // Service returning a UserDto
        UserDto user = new UserDto { Id = 1, Name = "Alice", Email = "alice@example.com" };
        ApiResponse<UserDto> userResponse = ApiResponse<UserDto>.Success(user, "User details fetched.");
        Console.WriteLine($"User Response: Success={userResponse.IsSuccess}, Data.Name={userResponse.Data.Name}");

        // Service returning a list of OrderDtos
        List<OrderDto> orders = new List<OrderDto>
        {
            new OrderDto { Id = 101, TotalAmount = 150.00m, OrderDate = DateTime.Now.AddDays(-5) },
            new OrderDto { Id = 102, TotalAmount = 230.50m, OrderDate = DateTime.Now.AddDays(-2) }
        };
        ApiResponse<List<OrderDto>> ordersResponse = ApiResponse<List<OrderDto>>.Success(orders, "Orders retrieved.");
        Console.WriteLine($"Orders Response: Success={ordersResponse.IsSuccess}, Data.Count={ordersResponse.Data.Count}");

        // Example of an error response
        ApiResponse<UserDto> notFoundResponse = ApiResponse<UserDto>.NotFound("User with ID 99 not found.");
        Console.WriteLine($"Not Found Response: Success={notFoundResponse.IsSuccess}, Message='{notFoundResponse.Message}'");

        // Example of a response with no specific data (e.g., successful delete)
        ApiResponse<object> deleteSuccessResponse = ApiResponse<object>.EmptySuccess("Resource deleted successfully.", 204);
        Console.WriteLine($"Delete Response: Success={deleteSuccessResponse.IsSuccess}, Message='{deleteSuccessResponse.Message}'");
    }
    ```

**Benefits:**

  * **Consistency:** All API responses will have the same outer structure (`IsSuccess`, `StatusCode`, `Message`, `Timestamp`, `Data`), making client-side parsing predictable.
  * **Type Safety:** The `Data` property is strongly typed (`TData`), eliminating the need for casting and catching errors at compile time.
  * **Reusability:** The `ApiResponse` class and its factory methods are written once and reused across all API endpoints, regardless of the specific data being returned.
  * **Clarity:** Clearly separates metadata (status, message) from the actual business data.

### You need to build a validation pipeline for multiple data types. Would you use a generic interface or abstract class? Why?

For a validation pipeline for multiple data types, a **generic interface is generally preferred over a generic abstract class.**

**Justification for Generic Interface (`IValidator<T>`):**

1.  **Flexibility (No Inheritance Hierarchy Restriction):**
      * A class can implement multiple interfaces, but it can only inherit from one abstract class. If your data types (`Customer`, `Product`, `Order`) already inherit from different base classes (e.g., `Customer` might inherit from `Person`, `Product` from `InventoryItem`), forcing them to also inherit from a `ValidationBase<T>` would prevent multi-inheritance.
      * With an interface, any class can implement `IValidator<T>` regardless of its existing inheritance hierarchy.
2.  **Loose Coupling:**
      * Interfaces promote loose coupling. The validation pipeline only depends on the `IValidator<T>` contract, not a concrete implementation or a specific base class.
      * This makes it easier to swap out different validation implementations or test validators in isolation.
3.  **Explicit Contract:**
      * An interface clearly defines *what* a validator *must do* (e.g., `Validate(T entity)`). It's a contract without providing any implementation details.
4.  **Dependency Injection Friendly:**
      * Dependency Injection (DI) containers work seamlessly with interfaces. You can register different concrete `IValidator<T>` implementations for different `T` types.

**When a Generic Abstract Class (`BaseValidator<T>`) might be considered (and its drawbacks for this scenario):**

An abstract class would be useful if:

  * You have a significant amount of **common validation logic** that is shared across *most* (or all) validators that would be burdensome to duplicate.
  * You need to maintain **internal state** that all validators must share and access in a controlled way.
  * You want to define **template methods** that dictate a fixed algorithm for validation, allowing subclasses to fill in specific steps.

However, for a validation *pipeline* (where individual validators are combined), the flexibility of interfaces usually outweighs the benefits of a shared implementation provided by an abstract class. Common utility methods can be placed in separate static helper classes or injected as dependencies into the validators.

**Code Example (`IValidator<T>`):**

```csharp
// 1. Generic Validation Interface
public interface IValidator<T>
{
    ValidationResult Validate(T entity);
}

// Simple Validation Result class
public class ValidationResult
{
    public bool IsValid { get; private set; }
    public List<string> Errors { get; private set; } = new List<string>();

    public ValidationResult(bool isValid = true)
    {
        IsValid = isValid;
    }

    public void AddError(string error)
    {
        Errors.Add(error);
        IsValid = false;
    }
}

// 2. Concrete Validators for different types
public class UserValidator : IValidator<UserDto>
{
    public ValidationResult Validate(UserDto user)
    {
        var result = new ValidationResult();
        if (string.IsNullOrWhiteSpace(user.Name))
            result.AddError("User name cannot be empty.");
        if (string.IsNullOrWhiteSpace(user.Email) || !user.Email.Contains("@"))
            result.AddError("Invalid email format.");
        return result;
    }
}

public class ProductValidator : IValidator<ProductDto>
{
    public ValidationResult Validate(ProductDto product)
    {
        var result = new ValidationResult();
        if (string.IsNullOrWhiteSpace(product.Name))
            result.AddError("Product name cannot be empty.");
        if (product.Price <= 0)
            result.AddError("Product price must be positive.");
        return result;
    }
}

// 3. The Validation Pipeline/Service
public class ValidationService
{
    private readonly IServiceProvider _serviceProvider; // For resolving validators via DI

    public ValidationService(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }

    public ValidationResult Validate<T>(T entity)
    {
        // Dynamically resolve the correct validator for T
        var validator = _serviceProvider.GetService(typeof(IValidator<T>)) as IValidator<T>;

        if (validator == null)
        {
            // No validator registered for this type, or no validation needed
            Console.WriteLine($"No validator found for type {typeof(T).Name}.");
            return new ValidationResult(true);
        }

        Console.WriteLine($"Validating {typeof(T).Name} using {validator.GetType().Name}...");
        return validator.Validate(entity);
    }
}

public static void GenericValidationPipelineExample()
{
    // Simulate DI setup
    var services = new ServiceCollection();
    services.AddTransient<IValidator<UserDto>, UserValidator>();
    services.AddTransient<IValidator<ProductDto>, ProductValidator>();
    services.AddTransient<ValidationService>();
    var serviceProvider = services.BuildServiceProvider();

    var validationService = serviceProvider.GetRequiredService<ValidationService>();

    UserDto validUser = new UserDto { Id = 1, Name = "Alice", Email = "alice@example.com" };
    UserDto invalidUser = new UserDto { Id = 2, Name = "", Email = "bob" };
    ProductDto validProduct = new ProductDto { Id = 101, Name = "Laptop", Price = 1200m };
    ProductDto invalidProduct = new ProductDto { Id = 102, Name = "Mouse", Price = -5m };

    var userResult = validationService.Validate(validUser);
    Console.WriteLine($"User validation (valid): {userResult.IsValid}");

    var invalidUserResult = validationService.Validate(invalidUser);
    Console.WriteLine($"User validation (invalid): {invalidUserResult.IsValid}");
    invalidUserResult.Errors.ForEach(e => Console.WriteLine($"- {e}"));

    var productResult = validationService.Validate(validProduct);
    Console.WriteLine($"Product validation (valid): {productResult.IsValid}");

    var invalidProductResult = validationService.Validate(invalidProduct);
    Console.WriteLine($"Product validation (invalid): {invalidProductResult.IsValid}");
    invalidProductResult.Errors.ForEach(e => Console.WriteLine($"- {e}"));
}
```

### You want to build a retry mechanism for various functions. How would generics help in abstracting the retry logic?

Generics are perfect for abstracting retry logic because the mechanism of retrying (e.g., how many times, delay) is independent of *what* operation is being retried or *what* result it returns.

**How Generics Help:**

1.  **Generic Operation:** The retry method will accept a `Func<TResult>` (for operations that return a value) or an `Action` (for operations that don't return a value). This `Func` or `Action` is the "function" that needs to be retried.
2.  **Type-Agnostic Retry Logic:** The retry loop, delay logic, and error handling are written once, independently of `TResult`.

**Code Example:**

```csharp
using System.Threading.Tasks; // For Task.Delay

public static class RetryHelper
{
    // Generic method for operations that return a value
    public static TResult Retry<TResult>(
        Func<TResult> operation,
        int maxRetries,
        TimeSpan delay,
        Action<int, Exception> onRetry = null)
    {
        for (int i = 0; i <= maxRetries; i++)
        {
            try
            {
                return operation(); // Execute the generic operation
            }
            catch (Exception ex)
            {
                if (i == maxRetries)
                {
                    Console.WriteLine($"Operation failed after {maxRetries} retries.");
                    throw; // Re-throw if max retries reached
                }

                onRetry?.Invoke(i + 1, ex); // Invoke optional callback for each retry
                Task.Delay(delay * (i + 1)).Wait(); // Exponential backoff
            }
        }
        return default; // Should not be reached
    }

    // Generic method for operations that return void
    public static void Retry(
        Action operation,
        int maxRetries,
        TimeSpan delay,
        Action<int, Exception> onRetry = null)
    {
        Retry<bool>(() => { operation(); return true; }, maxRetries, delay, onRetry);
    }
}

public static void GenericRetryMechanismExample()
{
    Console.WriteLine("\n--- Generic Retry Mechanism Example ---");
    int attemptCount = 0;

    // Scenario 1: Retrying a function that returns a value (simulating network call)
    Func<string> fetchData = () =>
    {
        attemptCount++;
        Console.WriteLine($"  Fetching data (Attempt {attemptCount})...");
        if (attemptCount < 3) // Succeeds on 3rd attempt
        {
            throw new HttpRequestException("Network temporarily unavailable.");
        }
        return "Data successfully fetched!";
    };

    string result = RetryHelper.Retry(
        fetchData,
        maxRetries: 3,
        delay: TimeSpan.FromSeconds(1),
        onRetry: (retryNum, ex) => Console.WriteLine($"  Retry {retryNum} failed: {ex.Message}")
    );
    Console.WriteLine($"Final result: {result}");

    // Scenario 2: Retrying a void function (simulating writing to a flaky log)
    attemptCount = 0;
    Action writeToLog = () =>
    {
        attemptCount++;
        Console.WriteLine($"  Writing to log (Attempt {attemptCount})...");
        if (attemptCount < 2) // Succeeds on 2nd attempt
        {
            throw new UnauthorizedAccessException("Log file locked.");
        }
        Console.WriteLine("  Log write successful!");
    };

    RetryHelper.Retry(
        writeToLog,
        maxRetries: 2,
        delay: TimeSpan.FromMilliseconds(500),
        onRetry: (retryNum, ex) => Console.WriteLine($"  Log retry {retryNum} failed: {ex.Message}")
    );
}
```

**Benefits:**

  * **Abstraction:** The `Retry` method encapsulates all the retry-specific logic (looping, delay, error handling) away from the actual business operation.
  * **Reusability:** It can be used for *any* `Func` or `Action`, regardless of the types involved, leading to significant code reduction.
  * **Type Safety:** The `TResult` ensures that the retry method's return type matches the operation's return type, and the compiler enforces this.
  * **Configurability:** Allows easy configuration of `maxRetries`, `delay`, and `onRetry` callbacks.

### You are creating a background job system that queues tasks of different types. How would you leverage generics for task handlers?

Generics are crucial for building a flexible and type-safe background job system where tasks (and their corresponding handlers) can vary in type.

**How to leverage Generics:**

1.  **Generic Job Interface/Class:** Define a generic interface for your background jobs (`IJob<TData>`) where `TData` represents the specific payload for that job.
2.  **Generic Job Handler Interface:** Define a generic interface for the handlers (`IJobHandler<TData>`) that know how to process a specific `IJob<TData>`.
3.  **Job Queue:** The queue itself might store a non-generic `IJob` interface or use a common base class, and rely on the handlers to resolve the correct generic types.
4.  **Job Dispatcher:** A dispatcher (often with DI) will resolve the appropriate `IJobHandler<TData>` based on the `TData` type of the queued job.

**Code Example:**

```csharp
// 1. Base interface for all jobs (non-generic, for queueing)
public interface IJob { /* Marker interface */ }

// 2. Generic Job Interface/Class (holds specific data)
public interface IJob<TData> : IJob
{
    TData Data { get; }
    string JobId { get; }
}

public class GenericJob<TData> : IJob<TData>
{
    public string JobId { get; } = Guid.NewGuid().ToString();
    public TData Data { get; }

    public GenericJob(TData data)
    {
        Data = data;
    }
}

// 3. Generic Job Handler Interface
public interface IJobHandler<TData>
{
    Task Handle(TData data); // Asynchronous handling
}

// 4. Specific Job Data Types
public class SendEmailJobData { public string To { get; set; } public string Subject { get; set; } public string Body { get; set; } }
public class ProcessImageJobData { public string ImageUrl { get; set; } public string FilterType { get; set; } }

// 5. Specific Job Handler Implementations
public class SendEmailJobHandler : IJobHandler<SendEmailJobData>
{
    public async Task Handle(SendEmailJobData data)
    {
        Console.WriteLine($"  [EmailHandler] Sending email to: {data.To}, Subject: {data.Subject}");
        await Task.Delay(100); // Simulate async work
        Console.WriteLine($"  [EmailHandler] Email sent.");
    }
}

public class ProcessImageJobHandler : IJobHandler<ProcessImageJobData>
{
    public async Task Handle(ProcessImageJobData data)
    {
        Console.WriteLine($"  [ImageHandler] Processing image: {data.ImageUrl} with filter: {data.FilterType}");
        await Task.Delay(200); // Simulate async work
        Console.WriteLine($"  [ImageHandler] Image processed.");
    }
}

// 6. Job Queue (stores non-generic IJob)
public class JobQueue
{
    private readonly ConcurrentQueue<IJob> _queue = new ConcurrentQueue<IJob>();

    public void Enqueue<TData>(TData data)
    {
        var job = new GenericJob<TData>(data);
        _queue.Enqueue(job);
        Console.WriteLine($"Queued job {job.JobId} of type {typeof(TData).Name}");
    }

    public IJob Dequeue()
    {
        _queue.TryDequeue(out var job);
        return job;
    }

    public bool IsEmpty => _queue.IsEmpty;
}

// 7. Job Dispatcher (resolves and executes handlers using DI)
public class JobDispatcher
{
    private readonly IServiceProvider _serviceProvider;

    public JobDispatcher(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }

    public async Task Dispatch(IJob job)
    {
        if (job == null) return;

        // Use reflection to get the generic type of the job data
        Type jobDataType = job.GetType().GetGenericArguments().FirstOrDefault();
        if (jobDataType == null)
        {
            Console.Error.WriteLine($"Could not determine data type for job: {job.JobId}");
            return;
        }

        // Construct the generic handler type (e.g., IJobHandler<SendEmailJobData>)
        Type handlerType = typeof(IJobHandler<>).MakeGenericType(jobDataType);

        // Resolve the handler from the DI container
        dynamic handler = _serviceProvider.GetService(handlerType);

        if (handler == null)
        {
            Console.Error.WriteLine($"No handler found for job type {jobDataType.Name}");
            return;
        }

        // Dynamically invoke the Handle method
        dynamic jobData = ((dynamic)job).Data; // Access the generic Data property
        await handler.Handle(jobData);
    }
}

public static async Task GenericBackgroundJobSystemExample()
{
    Console.WriteLine("\n--- Generic Background Job System Example ---");

    // Setup DI Container
    var services = new ServiceCollection();
    services.AddTransient<IJobHandler<SendEmailJobData>, SendEmailJobHandler>();
    services.AddTransient<IJobHandler<ProcessImageJobData>, ProcessImageJobHandler>();
    services.AddSingleton<JobQueue>();
    services.AddTransient<JobDispatcher>();
    var serviceProvider = services.BuildServiceProvider();

    var jobQueue = serviceProvider.GetRequiredService<JobQueue>();
    var dispatcher = serviceProvider.GetRequiredService<JobDispatcher>();

    // Enqueue various types of jobs
    jobQueue.Enqueue(new SendEmailJobData { To = "user@example.com", Subject = "Welcome", Body = "..." });
    jobQueue.Enqueue(new ProcessImageJobData { ImageUrl = "http://example.com/pic.jpg", FilterType = "Blur" });
    jobQueue.Enqueue(new SendEmailJobData { To = "admin@example.com", Subject = "Alert", Body = "Urgent!" });

    Console.WriteLine("\nProcessing jobs...");
    while (!jobQueue.IsEmpty)
    {
        IJob job = jobQueue.Dequeue();
        if (job != null)
        {
            await dispatcher.Dispatch(job);
        }
    }
    Console.WriteLine("All jobs processed.");
}
```

**Benefits of Generics:**

  * **Type Safety for Payloads and Handlers:** Each job (`IJob<TData>`) precisely defines its payload type, and each handler (`IJobHandler<TData>`) is guaranteed to work with that specific payload type. The compiler enforces this.
  * **Extensibility:** Adding new job types and their handlers simply involves creating new `TData` classes and implementing `IJobHandler<TData>`. The core queue and dispatcher logic remain unchanged.
  * **Clear Separation of Concerns:** Jobs hold data, handlers process data. The queue manages storage, and the dispatcher manages execution.
  * **Improved Readability and Maintainability:** The code is cleaner because specific types don't pollute the core infrastructure classes.
  * **Dependency Injection Compatibility:** Handlers can have their own dependencies injected, making them testable and manageable.

This generic approach provides a highly scalable and maintainable foundation for background job processing.