Today, July 14, 2025, let's explore how to create custom collections and powerful extension methods in C\#. This demonstrates a deep understanding of object-oriented design principles, interfaces, and how to build reusable, type-safe abstractions.

-----

### Custom Collections & Extension Methods

In C\#, you often interact with built-in collections like `List<T>`, `Dictionary<K,V>`, etc. However, there are scenarios where these don't perfectly fit your domain model, or you want to provide a specific, controlled view of your data. This is where custom collections and extension methods become invaluable.

**Focus:** Creating reusable, type-safe abstractions

  * **Custom Collections:** Allow you to define how your specific domain objects behave like collections, encapsulating their internal storage and providing controlled access.
  * **Extension Methods:** Enable you to add new methods to existing types (even interfaces) without modifying their source code, promoting code reuse and a more fluent API.

-----

### 1\. Implementing Custom `IEnumerable<T>` / `ICollection<T>`

When building custom collections, you often implement interfaces like `IEnumerable<T>`, `ICollection<T>`, or `IList<T>` (and their read-only counterparts). This makes your custom collection compatible with LINQ and standard collection operations.

**Scenario:** Let's say we have a `Team` class, and we want to treat its `Members` as a collection, but perhaps we want to add some specific team-related logic when managing members.

**Steps:**

1.  **Define the inner type:** `Player` in this case.
2.  **Define the custom collection class:** `Team` will contain a collection of `Player` objects.
3.  **Implement `IEnumerable<T>`:** This is the minimum to allow `foreach` loops and LINQ. You'll need to implement `GetEnumerator()`.
4.  **Implement `ICollection<T>` (Optional, but common):** If you need `Add()`, `Remove()`, `Count`, `Clear()`, etc., for your custom collection directly. This often means wrapping an internal `List<T>` or similar.

**Code Example:**

```csharp
using System;
using System.Collections; // For IEnumerator, IEnumerable
using System.Collections.Generic; // For IEnumerator<T>, IEnumerable<T>, ICollection<T>
using System.Linq; // For LINQ operations

// Step 1: Define the inner type (our domain model for an item in the collection)
public class Player
{
    public string Name { get; set; }
    public int JerseyNumber { get; set; }
    public string Position { get; set; }

    public override string ToString() => $"Player: {Name} (No. {JerseyNumber}, {Position})";
}

// Step 2 & 3: Define the custom collection class implementing IEnumerable<T>
// Step 4: Implement ICollection<T> to add mutation capabilities
public class Team : ICollection<Player> // Also implicitly implements IEnumerable<Player>
{
    private List<Player> _players; // Internal storage

    public string TeamName { get; set; }

    public Team(string teamName)
    {
        TeamName = teamName;
        _players = new List<Player>();
    }

    // ICollection<Player> Members:

    public int Count => _players.Count;
    public bool IsReadOnly => false; // This collection is designed to be modifiable

    public void Add(Player player)
    {
        // Custom logic can go here, e.g., check for duplicate jersey numbers
        if (_players.Any(p => p.JerseyNumber == player.JerseyNumber))
        {
            Console.WriteLine($"[Team {TeamName}]: Warning! Player with jersey number {player.JerseyNumber} already exists. Not adding {player.Name}.");
            return;
        }
        Console.WriteLine($"[Team {TeamName}]: Adding player: {player.Name}");
        _players.Add(player);
    }

    public bool Remove(Player player)
    {
        Console.WriteLine($"[Team {TeamName}]: Removing player: {player.Name}");
        return _players.Remove(player);
    }

    public void Clear()
    {
        Console.WriteLine($"[Team {TeamName}]: Clearing all players.");
        _players.Clear();
    }

    public bool Contains(Player player)
    {
        return _players.Contains(player);
    }

    public void CopyTo(Player[] array, int arrayIndex)
    {
        _players.CopyTo(array, arrayIndex);
    }

    // IEnumerable<Player> Members:
    public IEnumerator<Player> GetEnumerator()
    {
        // Return the enumerator of the internal list
        return _players.GetEnumerator();
    }

    // IEnumerable (non-generic) Member:
    IEnumerator IEnumerable.GetEnumerator()
    {
        // Explicitly implement the non-generic GetEnumerator()
        return GetEnumerator();
    }

    // Custom Team-specific methods
    public Player GetPlayerByJerseyNumber(int jerseyNumber)
    {
        return _players.FirstOrDefault(p => p.JerseyNumber == jerseyNumber);
    }

    public IEnumerable<Player> GetPlayersByPosition(string position)
    {
        return _players.Where(p => p.Position.Equals(position, StringComparison.OrdinalIgnoreCase));
    }
}

public static class CustomCollectionExample
{
    public static void Run()
    {
        Console.WriteLine("--- Custom Collection (Team) Example ---");

        Team dreamTeam = new Team("Dream Team");

        dreamTeam.Add(new Player { Name = "Messi", JerseyNumber = 10, Position = "Forward" });
        dreamTeam.Add(new Player { Name = "Ronaldo", JerseyNumber = 7, Position: "Forward" });
        dreamTeam.Add(new Player { Name = "Pele", JerseyNumber = 10, Position: "Forward" }); // Duplicate jersey number handling
        dreamTeam.Add(new Player { Name = "Maradona", JerseyNumber = 10, Position: "Midfielder" }); // Another duplicate for different position

        Player defender = new Player { Name = "Maldini", JerseyNumber = 3, Position: "Defender" };
        dreamTeam.Add(defender);

        Console.WriteLine($"\nDream Team has {dreamTeam.Count} players.");

        // Iterate using foreach (works because of IEnumerable<T>)
        Console.WriteLine("\nAll players in Dream Team:");
        foreach (Player player in dreamTeam)
        {
            Console.WriteLine(player);
        }

        // Use LINQ (works because of IEnumerable<T>)
        Console.WriteLine("\nForwards in Dream Team:");
        var forwards = dreamTeam.GetPlayersByPosition("Forward");
        foreach (Player forward in forwards)
        {
            Console.WriteLine(forward);
        }

        // Use ICollection<T> methods
        Console.WriteLine($"\nDoes team contain Messi? {dreamTeam.Contains(new Player { Name = "Messi", JerseyNumber = 10, Position = "Forward" })}"); // Note: Requires Player.Equals override for true comparison based on content
                                                                                                                          // For this example, it will be false because it's a new object, not the same reference.
                                                                                                                          // Let's use the actual object:
        Player messi = dreamTeam.FirstOrDefault(p => p.Name == "Messi");
        Console.WriteLine($"Does team contain Messi (object reference)? {dreamTeam.Contains(messi)}"); // True

        dreamTeam.Remove(defender);
        Console.WriteLine($"\nDream Team has {dreamTeam.Count} players after removing Maldini.");

        Console.WriteLine("--- End Custom Collection Example ---");
    }
}
```

**Note on `Contains` and `Remove`:** For `Contains` and `Remove` (and `Distinct` in LINQ) to work as expected based on *value equality* rather than *reference equality*, you would need to override `Equals()` and `GetHashCode()` in the `Player` class. The example above demonstrates reference equality.

-----

### 2\. Writing Extension Methods like `ToDictionary()` or `ToLookup()`

Extension methods are static methods defined in a static class, but they are called as if they were instance methods on the extended type. They are powerful for adding functionality to existing types (including interfaces) without modifying their source code. LINQ is a prime example of extension methods.

**Scenario:** You have a collection of objects, and you want to convert it to a `Dictionary` or a `Lookup` based on specific properties of your objects, similar to how LINQ's `ToDictionary()` works.

**Steps:**

1.  **Create a static class:** This class will hold your extension methods.
2.  **Define a static method:** The first parameter of the method must be preceded by the `this` keyword, and its type is the type you are extending (e.g., `this IEnumerable<Player> source`).
3.  **Implement the logic:** Use LINQ or custom logic to achieve the desired transformation.

**Code Example:**

```csharp
using System;
using System.Collections.Generic;
using System.Linq; // Essential for LINQ

// Static class to hold extension methods
public static class PlayerCollectionExtensions
{
    // Extension method: ToDictionary by JerseyNumber
    public static Dictionary<int, Player> ToDictionaryByJerseyNumber(this IEnumerable<Player> source)
    {
        // Uses LINQ's built-in ToDictionary method
        return source.ToDictionary(player => player.JerseyNumber);
    }

    // Extension method: ToDictionary by Position (might have duplicates, so this will throw if not handled)
    // A more robust version would use a GroupBy or ToLookup first, or GetOrAdd.
    public static Dictionary<string, Player> ToDictionaryByPosition(this IEnumerable<Player> source)
    {
        // This will throw if multiple players have the same position
        return source.ToDictionary(player => player.Position);
    }

    // Extension method: ToLookup by Position (handles multiple players per position)
    public static ILookup<string, Player> ToLookupByPosition(this IEnumerable<Player> source)
    {
        return source.ToLookup(player => player.Position);
    }

    // A more custom extension method: CountPlayersByPosition
    public static Dictionary<string, int> CountPlayersByPosition(this IEnumerable<Player> source)
    {
        return source.GroupBy(player => player.Position)
                     .ToDictionary(
                         group => group.Key,
                         group => group.Count()
                     );
    }

    // A custom filter extension method
    public static IEnumerable<Player> GetPlayersWithHighJerseyNumbers(this IEnumerable<Player> source, int minJerseyNumber = 7)
    {
        return source.Where(player => player.JerseyNumber >= minJerseyNumber);
    }
}

public static class ExtensionMethodsExample
{
    public static void Run()
    {
        Console.WriteLine("\n--- Extension Methods Example ---");

        List<Player> allPlayers = new List<Player>
        {
            new Player { Name = "Messi", JerseyNumber = 10, Position = "Forward" },
            new Player { Name = "Ronaldo", JerseyNumber = 7, Position = "Forward" },
            new Player { Name = "Modric", JerseyNumber = 10, Position = "Midfielder" },
            new Player { Name = "Maldini", JerseyNumber = 3, Position: "Defender" },
            new Player { Name = "Buffon", JerseyNumber = 1, Position: "Goalkeeper" }
        };

        // Use custom ToDictionaryByJerseyNumber extension method
        Console.WriteLine("\nPlayers by Jersey Number:");
        Dictionary<int, Player> playersByJersey = allPlayers.ToDictionaryByJerseyNumber();
        foreach (var entry in playersByJersey)
        {
            Console.WriteLine($"  {entry.Key}: {entry.Value.Name}");
        }

        // Use custom ToLookupByPosition extension method
        Console.WriteLine("\nPlayers by Position (Lookup):");
        ILookup<string, Player> playersByPosition = allPlayers.ToLookupByPosition();
        foreach (var group in playersByPosition)
        {
            Console.WriteLine($"  {group.Key}:");
            foreach (var player in group)
            {
                Console.WriteLine($"    - {player.Name}");
            }
        }

        // Use custom CountPlayersByPosition extension method
        Console.WriteLine("\nPlayer Counts by Position:");
        Dictionary<string, int> positionCounts = allPlayers.CountPlayersByPosition();
        foreach (var entry in positionCounts)
        {
            Console.WriteLine($"  {entry.Key}: {entry.Value}");
        }

        // Use custom filter extension method
        Console.WriteLine("\nPlayers with high jersey numbers:");
        IEnumerable<Player> highJerseyPlayers = allPlayers.GetPlayersWithHighJerseyNumbers(8);
        foreach(var player in highJerseyPlayers)
        {
            Console.WriteLine($"  - {player.Name} (No. {player.JerseyNumber})");
        }

        Console.WriteLine("--- End Extension Methods Example ---");
    }
}
```

-----

### Interview Focus: Show deep understanding by building collection-like behavior for domain models.

This type of question aims to see if you can apply collection interface concepts to real-world objects, not just use `List<T>`. It demonstrates:

1.  **Abstraction:** Can you design interfaces that represent a concept (e.g., "a collection of members") without exposing the underlying storage details?
2.  **Encapsulation:** Can you hide the internal data structure (`_players` in `Team`) and expose only controlled operations?
3.  **Polymorphism:** Can you make your custom types compatible with existing frameworks (like LINQ) by implementing standard interfaces (`IEnumerable<T>`, `ICollection<T>`)?
4.  **API Design:** Can you create a clean and intuitive API for your domain models that leverages C\#'s language features (like extension methods)?

**Scenario and Approach for Interview:**

**Interviewer:** "Imagine you're building a system for managing a university. You have `Course` objects, and each `Course` has a collection of `Student` objects enrolled in it. How would you design the `Course` class so that you can easily iterate through its students, count them, and perhaps add/remove students, while still keeping the internal implementation clean?"

**Your Answer (walking through the design):**

"I would start by defining the `Student` class as a simple Plain Old C\# Object (POCO)."

```csharp
public class Student
{
    public int StudentId { get; set; }
    public string Name { get; set; }
    public string Major { get; set; }

    public override string ToString() => $"Student ID: {StudentId}, Name: {Name}, Major: {Major}";
}
```

"Then, for the `Course` class, I would make it implement `ICollection<Student>`. This is the best choice because it gives us the ability to `Add`, `Remove`, and `Count` students directly on the `Course` object, which makes semantic sense for a `Course` managing its enrollments. By implementing `ICollection<Student>`, it automatically means it also implements `IEnumerable<Student>`, so we get LINQ compatibility and `foreach` loops for free."

```csharp
using System.Collections.Generic; // For ICollection<T>
using System.Linq; // For LINQ operations

public class Course : ICollection<Student>
{
    private List<Student> _enrolledStudents; // Internal storage

    public string CourseCode { get; private set; }
    public string Title { get; private set; }
    public int MaxCapacity { get; private set; }

    public Course(string courseCode, string title, int maxCapacity)
    {
        CourseCode = courseCode;
        Title = title;
        MaxCapacity = maxCapacity;
        _enrolledStudents = new List<Student>();
    }

    // --- ICollection<Student> Implementation ---

    public int Count => _enrolledStudents.Count;
    public bool IsReadOnly => false; // This collection is designed to be mutable

    public void Add(Student student)
    {
        if (_enrolledStudents.Count >= MaxCapacity)
        {
            throw new InvalidOperationException($"Course '{Title}' is at full capacity ({MaxCapacity} students). Cannot add {student.Name}.");
        }
        if (_enrolledStudents.Any(s => s.StudentId == student.StudentId))
        {
            Console.WriteLine($"[Course {CourseCode}]: Warning! Student ID {student.StudentId} already enrolled. Not adding {student.Name}.");
            return;
        }

        _enrolledStudents.Add(student);
        Console.WriteLine($"[Course {CourseCode}]: {student.Name} enrolled.");
    }

    public bool Remove(Student student)
    {
        bool removed = _enrolledStudents.Remove(student);
        if (removed)
        {
            Console.WriteLine($"[Course {CourseCode}]: {student.Name} unenrolled.");
        }
        return removed;
    }

    public void Clear()
    {
        Console.WriteLine($"[Course {CourseCode}]: Clearing all enrollments.");
        _enrolledStudents.Clear();
    }

    public bool Contains(Student student)
    {
        // For accurate comparison, Student needs to override Equals and GetHashCode
        return _enrolledStudents.Contains(student);
    }

    public void CopyTo(Student[] array, int arrayIndex)
    {
        _enrolledStudents.CopyTo(array, arrayIndex);
    }

    // --- IEnumerable<Student> Implementation (implicit via ICollection<Student>) ---

    public IEnumerator<Student> GetEnumerator()
    {
        return _enrolledStudents.GetEnumerator();
    }

    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }

    // --- Course-specific business logic (can use internal collection directly) ---

    public Student FindStudentById(int studentId)
    {
        return _enrolledStudents.FirstOrDefault(s => s.StudentId == studentId);
    }

    public IEnumerable<Student> GetStudentsByMajor(string major)
    {
        return _enrolledStudents.Where(s => s.Major.Equals(major, StringComparison.OrdinalIgnoreCase));
    }
}
```

"Now, to use this `Course` class, it feels very natural. We can add students, remove them, and count them directly, just like a standard collection. And because it's `IEnumerable<Student>`, we can use LINQ queries on it directly."

```csharp
using System;
using System.Linq;
using System.Collections.Generic; // For List, etc.

public static class UniversityManagement
{
    public static void Run()
    {
        Console.WriteLine("--- University Course Management Example ---");

        Course math101 = new Course("MATH101", "Calculus I", 3); // Max 3 students
        Course cs201 = new Course("CS201", "Data Structures", 5);

        Student alice = new Student { StudentId = 101, Name = "Alice Smith", Major = "Computer Science" };
        Student bob = new Student { StudentId = 102, Name = "Bob Johnson", Major = "Mathematics" };
        Student charlie = new Student { StudentId = 103, Name = "Charlie Brown", Major = "Physics" };
        Student david = new Student { StudentId = 104, Name = "David Lee", Major = "Computer Science" };
        Student eve = new Student { StudentId = 105, Name = "Eve Davis", Major = "Mathematics" };

        Console.WriteLine($"\nEnrollments for {math101.Title} ({math101.CourseCode}):");
        math101.Add(alice);
        math101.Add(bob);
        math101.Add(charlie);
        try
        {
            math101.Add(david); // This will throw an exception due to capacity
        }
        catch (InvalidOperationException ex)
        {
            Console.WriteLine($"  Error enrolling David in MATH101: {ex.Message}");
        }

        Console.WriteLine($"\nStudents in {math101.Title}:");
        foreach (Student s in math101) // Using foreach (IEnumerable<T> enabled)
        {
            Console.WriteLine($"  - {s.Name}");
        }
        Console.WriteLine($"Total students in {math101.Title}: {math101.Count}"); // Using ICollection<T>.Count

        Console.WriteLine($"\nEnrollments for {cs201.Title} ({cs201.CourseCode}):");
        cs201.Add(alice); // Alice already added to another course, but can be here.
        cs201.Add(david);
        cs201.Add(bob);

        // Use LINQ (IEnumerable<T> enabled)
        Console.WriteLine($"\nCS Majors in {cs201.Title}:");
        var csMajors = cs201.Where(s => s.Major == "Computer Science");
        foreach (Student s in csMajors)
        {
        Console.WriteLine($"  - {s.Name}");
        }

        Console.WriteLine($"\nTotal students in {cs201.Title}: {cs201.Count}");

        cs201.Remove(bob); // Remove a student
        Console.WriteLine($"\nTotal students in {cs201.Title} after Bob unenrolled: {cs201.Count}");

        Console.WriteLine("--- End University Course Management Example ---");
    }
}
```

"Finally, I might add some **extension methods** to `IEnumerable<Student>` if there are common operations I want to perform on *any* collection of students, not just those within a `Course`."

```csharp
// In a static class, e.g., StudentExtensions.cs
public static class StudentExtensions
{
    public static ILookup<string, Student> ToLookupByMajor(this IEnumerable<Student> students)
    {
        return students.ToLookup(s => s.Major);
    }

    public static IEnumerable<Student> GetStudentsByIdRange(this IEnumerable<Student> students, int minId, int maxId)
    {
        return students.Where(s => s.StudentId >= minId && s.StudentId <= maxId);
    }
}
```

"This approach gives us a strong, type-safe, and intuitive way to manage collections of `Student` objects within our `Course` domain model, leveraging standard .NET interfaces and LINQ for powerful queries, while maintaining encapsulation."

This answer demonstrates:

  * **Domain Modeling:** Applying collection concepts to specific business entities (`Course`, `Student`).
  * **Interface Selection:** Correctly choosing `ICollection<T>` for the required mutation and iteration capabilities.
  * **Encapsulation:** Hiding `_enrolledStudents` and providing controlled access through `Add`, `Remove`, etc., with built-in validation (e.g., `MaxCapacity`).
  * **Compatibility:** Showing how implementing `ICollection<T>` automatically makes the `Course` compatible with `foreach` loops and LINQ.
  * **Extensibility:** Suggesting extension methods for reusable logic across any `IEnumerable<Student>`.
  * **Thought Process:** Walking through the design decisions.