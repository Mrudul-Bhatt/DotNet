Let's differentiate between common C# collection types.

## Difference between `List<T>` and `Array` in C#

The fundamental difference between `List<T>` and `Array` in C# lies in their **flexibility regarding size** and their underlying implementation.

* **`Array`**: üìè
    * **Fixed Size**: An array has a **fixed size** that is determined at the time of its creation. Once an array is declared with a certain size, you cannot change it. If you need more (or less) space, you must create a new array and copy the elements over.
    * **Homogeneous**: Arrays store elements of a **single, specific data type** (or a type derived from it).
    * **Direct Memory Access**: Arrays are value types and provide direct, contiguous memory allocation for their elements. This makes element access (by index) very fast.
    * **Lower Overhead**: Generally, arrays have less overhead than `List<T>` as they don't carry the baggage of dynamic resizing logic.
    * **Example**: `int[] numbers = new int[5];`

* **`List<T>`**: üìà
    * **Dynamic Size**: A `List<T>` is a **dynamic, resizable collection**. You can add or remove elements, and the list will automatically manage its internal capacity. When its capacity is exceeded, it typically doubles its internal array size and copies existing elements.
    * **Generic**: `List<T>` is a generic collection, meaning it can store elements of a specified type `T`.
    * **Higher Overhead**: Due to its dynamic nature, `List<T>` has more overhead than arrays. Operations like adding elements can occasionally involve resizing the internal array, which is an expensive operation (copying all elements).
    * **More Features**: `List<T>` provides a rich set of methods for adding, removing, searching, sorting, and iterating over elements, making it more convenient for many scenarios.
    * **Example**: `List<int> numbers = new List<int>();`

**Summary**: Use `Array` when you know the exact number of elements in advance and the size won't change, or when performance is absolutely critical for direct indexed access. Use `List<T>` for most general-purpose collection needs where the size can vary, or when you need the convenience of its built-in methods.

---

## How does a `Dictionary<K,V>` store and look up elements?

A `Dictionary<K,V>` in C# stores and looks up elements using a **hash table** internally. This mechanism provides very efficient (average O(1) time complexity) lookups, insertions, and deletions.

Here's a simplified explanation of how it works:

1.  **Key-Value Pairs**: A dictionary stores data as **key-value pairs**. Each key must be unique within the dictionary.
2.  **Hashing**: When you add a key-value pair, or when you try to look up a key:
    * The `Dictionary` first calls the `GetHashCode()` method on the provided **key (K)**. This method returns an integer hash code.
    * This hash code is then used to quickly determine an initial "bucket" or "slot" in an internal array where the key-value pair should ideally reside.
    * **Keys must be hashable**: This means the `GetHashCode()` method must be consistently implemented for the key type.
3.  **Collision Handling**: It's possible for two different keys to produce the same hash code (a "hash collision"). The `Dictionary` handles collisions by storing multiple key-value pairs in the same bucket, typically using a linked list or similar structure.
4.  **Equality Check**: After identifying the bucket, the `Dictionary` doesn't just rely on the hash code. It then iterates through the items in that specific bucket and calls the `Equals()` method on the key object to perform a precise comparison with the actual keys stored there. This is to ensure that even if hash codes match (due to collision), the correct, unique key is identified.
    * **Keys should be immutable**: For consistent hashing and equality, it's highly recommended that the types used as keys (K) are **immutable**. If a key's value changes after it's added to the dictionary, its hash code might change, making it impossible to retrieve the original entry.
    * **Keys must correctly implement `Equals()` and `GetHashCode()`**: If you use custom objects as keys, you *must* override both `Equals()` and `GetHashCode()` methods consistently.



**In essence**: `Dictionary<K,V>` uses `GetHashCode()` for quick approximate placement and `Equals()` for precise identification, enabling very fast data retrieval.

---

## What is the purpose of a `Queue<T>` and `Stack<T>`? How are they different?

`Queue<T>` and `Stack<T>` are specialized collection types designed to manage data in specific orders, representing two fundamental data structures:

### `Queue<T>` (FIFO: First-In, First-Out) ‚û°Ô∏è

* **Purpose**: A `Queue<T>` is used when you need to process items in the **order they were added**. It's like a real-world queue or a line. The first element added is the first one to be removed.
* **Operations**:
    * `Enqueue(T item)`: Adds an item to the end of the queue.
    * `Dequeue()`: Removes and returns the item from the front of the queue.
    * `Peek()`: Returns the item at the front of the queue without removing it.
* **Analogy**: A waiting line at a bank, a print spooler, message queues in an application.
* **Use Cases**:
    * Task scheduling or job processing.
    * Buffering data for sequential processing.
    * Implementing breadth-first search (BFS) algorithms.

### `Stack<T>` (LIFO: Last-In, First-Out) ‚¨ÖÔ∏è

* **Purpose**: A `Stack<T>` is used when you need to process items in the **reverse order they were added**. It's like a stack of plates or a pile of documents. The last element added is the first one to be removed.
* **Operations**:
    * `Push(T item)`: Adds an item to the top of the stack.
    * `Pop()`: Removes and returns the item from the top of the stack.
    * `Peek()`: Returns the item at the top of the stack without removing it.
* **Analogy**: A stack of books, the Undo/Redo functionality in software, browser history (back button).
* **Use Cases**:
    * Managing function calls on the call stack.
    * Implementing Undo/Redo functionality.
    * Parsing expressions or validating parentheses.
    * Implementing depth-first search (DFS) algorithms.

**Key Difference Summary**:

The core difference is the **order of access**:

* **Queue**: The element that has been in the collection the **longest** is accessed next.
* **Stack**: The element that has been in the collection the **shortest** amount of time is accessed next.

