## What is the difference between `IReadOnlyList<T>` and `List<T>`?

The primary difference between `IReadOnlyList<T>` and `List<T>` lies in their **mutability and the operations they expose**.

  * **`List<T>`**: üõ†Ô∏è

      * `List<T>` is a **concrete, mutable** class that implements `IList<T>`, `ICollection<T>`, and `IEnumerable<T>`.
      * It provides methods for **adding, removing, inserting, clearing, and modifying** elements (e.g., `Add()`, `Remove()`, `Insert()`, `Clear()`, indexer for setting values).
      * You have full control to change the contents of a `List<T>` after it's created.

  * **`IReadOnlyList<T>`**: üîí

      * `IReadOnlyList<T>` is an **interface** that provides a **read-only view** of a list.
      * It only exposes methods for **reading** elements:
          * `this[int index] { get; }`: Allows indexed access to retrieve elements.
          * `int Count { get; }`: Gets the number of elements.
          * It inherits `IEnumerable<T>`, so you can iterate over it.
      * Crucially, it **does not** expose any methods for adding, removing, or modifying elements (`Add()`, `Remove()`, `Clear()`, `Insert()`, setter for indexer are absent).
      * While the `IReadOnlyList<T>` interface itself is read-only, the underlying collection *might* still be mutable if it's, for example, a `List<T>` instance cast to `IReadOnlyList<T>`. It only guarantees that you cannot modify it *through that interface*.

**In essence:** `List<T>` is for when you need to change the contents of your list. `IReadOnlyList<T>` is for when you want to pass a list around and guarantee to consumers of your code that they can only read from it, not alter it.

-----

## What are immutable collections in .NET? Give examples.

**Immutable collections** in .NET are collections that **cannot be modified after they are created**. Once you create an instance of an immutable collection, its contents remain fixed for its entire lifetime. Any operation that appears to "modify" the collection (like adding an item) actually returns a *new instance* of the collection with the change applied, leaving the original collection untouched.

**Why are they used?**

  * **Thread Safety:** Since they cannot be changed, they are inherently thread-safe. Multiple threads can access the same immutable collection concurrently without any risk of race conditions or data corruption, as there's no shared mutable state.
  * **Predictability:** They lead to more predictable and easier-to-reason-about code. You don't have to worry about a collection's state changing unexpectedly from another part of the program.
  * **Functional Programming:** They align well with functional programming paradigms, where immutability is a core principle.
  * **Simpler Caching and Hashing:** Immutable objects can be safely cached and their hash codes can be computed once.

**Examples of common immutable collections in .NET (found in the `System.Collections.Immutable` NuGet package):**

  * **`ImmutableList<T>`**: An immutable version of `List<T>`.
      * Example: `ImmutableList<int> list = ImmutableList<int>.Empty.Add(1).Add(2);`
  * **`ImmutableArray<T>`**: An immutable version of an array.
      * Example: `ImmutableArray<string> array = ImmutableArray.Create("a", "b");`
  * **`ImmutableDictionary<TKey, TValue>`**: An immutable version of `Dictionary<K,V>`.
      * Example: `ImmutableDictionary<string, int> dict = ImmutableDictionary<string, int>.Empty.Add("one", 1);`
  * **`ImmutableHashSet<T>`**: An immutable version of `HashSet<T>`.
  * **`ImmutableQueue<T>`**: An immutable version of `Queue<T>`.
  * **`ImmutableStack<T>`**: An immutable version of `Stack<T>`.
  * **`ImmutableSortedDictionary<TKey, TValue>`**: An immutable version of `SortedDictionary<K,V>`.
  * **`ImmutableSortedSet<T>`**: An immutable version of `SortedSet<T>`.

-----

## How are `ImmutableList<T>` and `ReadOnlyCollection<T>` different?

While both `ImmutableList<T>` and `ReadOnlyCollection<T>` provide a way to work with collections that appear read-only, their fundamental nature and guarantees are distinct:

### `ReadOnlyCollection<T>`: A Read-Only Wrapper üéÅ

  * **Nature:** `ReadOnlyCollection<T>` is a **wrapper class** that provides a read-only view over an **existing, potentially mutable, underlying `IList<T>`**.

  * **Mutability of Underlying Data:** The crucial point is that if the original `IList<T>` (the one `ReadOnlyCollection<T>` is wrapping) is modified, those changes **will be reflected** in the `ReadOnlyCollection<T>` because they both point to the *same* underlying data.

  * **Purpose:** Primarily used to expose an `IList<T>` to external code or layers without allowing them to modify the collection *through that specific wrapper instance*. It acts as a defensive copy of the *interface*, not the data.

  * **Example:**

    ```csharp
    List<int> mutableList = new List<int> { 1, 2, 3 };
    ReadOnlyCollection<int> readOnlyView = new ReadOnlyCollection<int>(mutableList);

    Console.WriteLine($"ReadOnlyView count: {readOnlyView.Count}"); // Output: 3

    mutableList.Add(4); // Modifying the original list

    Console.WriteLine($"ReadOnlyView count after original modified: {readOnlyView.Count}"); // Output: 4 (Change is reflected!)
    // readOnlyView.Add(5); // Compile-time error: 'ReadOnlyCollection<T>' does not contain a definition for 'Add'
    ```

### `ImmutableList<T>`: Truly Immutable Data üß±

  * **Nature:** `ImmutableList<T>` (and other immutable collections) are **fundamentally different**; they are **truly immutable**. Once an `ImmutableList<T>` instance is created, its contents can **never be changed**.

  * **Mutation Operation:** Any method that appears to "modify" an `ImmutableList<T>` (like `Add()`, `Remove()`, `SetItem()`) actually returns a **new `ImmutableList<T>` instance** with the desired change. The original instance remains unchanged.

  * **Purpose:** Guarantees data integrity and simplifies concurrent programming because you know the collection's state will never be altered once created. Each "modification" results in a new version.

  * **Efficiency:** Immutable collections are often implemented using persistent data structures (like hash array mapped tries) that allow new versions to share large parts of the underlying data structure with previous versions, making modifications efficient without deep copying everything.

  * **Example:**

    ```csharp
    ImmutableList<int> originalList = ImmutableList<int>.Empty.Add(1).Add(2).Add(3);
    Console.WriteLine($"Original List count: {originalList.Count}"); // Output: 3

    ImmutableList<int> newList = originalList.Add(4); // This returns a NEW list

    Console.WriteLine($"Original List count after 'Add': {originalList.Count}"); // Output: 3 (Original is unchanged!)
    Console.WriteLine($"New List count: {newList.Count}"); // Output: 4 (New list has the added item)
    ```

**Summary of Differences:**

| Feature               | `ReadOnlyCollection<T>`                     | `ImmutableList<T>`                          |
| :-------------------- | :------------------------------------------ | :------------------------------------------ |
| **Underlying Data** | Can be mutable                              | Truly immutable                             |
| **Changes Reflected** | Yes, changes to original are reflected      | No, operations return a new instance        |
| **Modification** | Prevents modification *through its interface* | Guarantees no mutation *of the instance* |
| **Thread Safety** | Only if the underlying collection is also read-only or externally synchronized | Inherently thread-safe                      |
| **Package** | `System.Collections.ObjectModel`            | `System.Collections.Immutable` (NuGet)      |