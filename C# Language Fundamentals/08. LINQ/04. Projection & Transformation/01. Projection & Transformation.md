Let's explore **Projection & Transformation** in LINQ, focusing on how you can reshape and reformat data to fit your exact output requirements. This is one of the most powerful aspects of LINQ.

## Projection & Transformation in LINQ

Projection in LINQ refers to the operation of transforming the elements of a sequence into a new form. This new form can be:

  * A subset of the original element's properties.
  * A calculated value.
  * A completely new type (e.g., an anonymous type, a named class/DTO, or a tuple).
  * A flattened collection from a nested one.

The primary LINQ operators for projection are `Select` and `SelectMany`. Other operators like `ToDictionary` also facilitate transformation into different collection types.

### 1\. `Select`: Projecting Each Element

`Select` is used to transform each element in a sequence into a new object or value. It's a one-to-one transformation: for every input element, there is exactly one output element.

**Common uses:**

  * Selecting a single property: `products.Select(p => p.Name)`
  * Creating an anonymous type (subset of properties): `employees.Select(e => new { e.Name, e.Department })`
  * Creating a new named type (DTO): `orders.Select(o => new OrderSummaryDto { Id = o.Id, Total = o.Amount })`
  * Performing calculations: `items.Select(i => i.Quantity * i.UnitPrice)`
  * Creating Tuples: `users.Select(u => (u.Id, u.Email))`

**Code Example - `Select`:**

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

public class Employee
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public string Department { get; set; }
    public decimal Salary { get; set; }
}

public class EmployeeSummaryDto // A Data Transfer Object (DTO)
{
    public string FullName { get; set; }
    public string Department { get; set; }
}

public static class LinqProjectionSelect
{
    public static void Run()
    {
        Console.WriteLine("--- Select: Projecting Each Element ---");

        var employees = new List<Employee>
        {
            new Employee { Id = 1, FirstName = "Alice", LastName = "Smith", Department = "HR", Salary = 60000m },
            new Employee { Id = 2, FirstName = "Bob", LastName = "Johnson", Department = "IT", Salary = 85000m },
            new Employee { Id = 3, FirstName = "Charlie", LastName = "Brown", Department = "HR", Salary = 62000m },
            new Employee { Id = 4, FirstName = "David", LastName = "Davis", Department = "IT", Salary = 90000m }
        };

        // 1. Selecting a single property (employee names)
        var employeeNames = employees.Select(e => e.FirstName);
        Console.WriteLine("Employee Names:");
        foreach (var name in employeeNames) { Console.WriteLine($"- {name}"); }

        // 2. Creating Anonymous Types (subset of properties)
        var employeeShortDetails = employees.Select(e => new { e.FirstName, e.Department });
        Console.WriteLine("\nEmployee Short Details (Anonymous Type):");
        foreach (var detail in employeeShortDetails) { Console.WriteLine($"- Name: {detail.FirstName}, Dept: {detail.Department}"); }
        // Note: You can't return an anonymous type from a method directly without 'dynamic' or casting.

        // 3. Creating a New Named Type (DTO)
        var employeeSummaries = employees.Select(e => new EmployeeSummaryDto
        {
            FullName = $"{e.FirstName} {e.LastName}",
            Department = e.Department
        });
        Console.WriteLine("\nEmployee Summaries (DTO):");
        foreach (var summary in employeeSummaries) { Console.WriteLine($"- {summary.FullName} works in {summary.Department}"); }

        // 4. Performing Calculations
        var annualSalaries = employees.Select(e => new { e.FirstName, AnnualSalary = e.Salary * 12 });
        Console.WriteLine("\nAnnual Salaries:");
        foreach (var salaryInfo in annualSalaries) { Console.WriteLine($"- {salaryInfo.FirstName}: {salaryInfo.AnnualSalary:C}"); }

        // 5. Creating Tuples (ValueTuple in C# 7+)
        var employeeTuples = employees.Select(e => (e.Id, e.FirstName, e.Department));
        Console.WriteLine("\nEmployee Tuples:");
        foreach (var tuple in employeeTuples) { Console.WriteLine($"- ID: {tuple.Id}, Name: {tuple.FirstName}, Dept: {tuple.Department}"); }

        Console.WriteLine();
    }
}
```

### 2\. `SelectMany`: Flattening Nested Collections

`SelectMany` is used when you have a collection of objects, and each of those objects also contains a collection. `SelectMany` "flattens" these nested collections into a single, unified sequence. It's a one-to-many-then-flatten transformation.

**Common uses:**

  * Getting all items from all orders.
  * Getting all tags from all blog posts.
  * Combining elements from multiple inner collections.

**Code Example - `SelectMany`:**

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

public class Order
{
    public int OrderId { get; set; }
    public List<OrderItem> Items { get; set; } = new List<OrderItem>();
}

public class OrderItem
{
    public int ProductId { get; set; }
    public string ProductName { get; set; }
    public int Quantity { get; set; }
    public decimal UnitPrice { get; set; }
}

public class Customer
{
    public int CustomerId { get; set; }
    public string Name { get; set; }
    public List<Order> Orders { get; set; } = new List<Order>();
}

public static class LinqProjectionSelectMany
{
    public static void Run()
    {
        Console.WriteLine("--- SelectMany: Flattening Nested Collections ---");

        var customers = new List<Customer>
        {
            new Customer { CustomerId = 1, Name = "CustA", Orders = new List<Order>
                {
                    new Order { OrderId = 101, Items = new List<OrderItem>
                        {
                            new OrderItem { ProductId = 1, ProductName = "Laptop", Quantity = 1, UnitPrice = 1200m },
                            new OrderItem { ProductId = 2, ProductName = "Mouse", Quantity = 2, UnitPrice = 25m }
                        }
                    },
                    new Order { OrderId = 102, Items = new List<OrderItem>
                        {
                            new OrderItem { ProductId = 3, ProductName = "Keyboard", Quantity = 1, UnitPrice = 75m }
                        }
                    }
                }
            },
            new Customer { CustomerId = 2, Name = "CustB", Orders = new List<Order>
                {
                    new Order { OrderId = 201, Items = new List<OrderItem>
                        {
                            new OrderItem { ProductId = 1, ProductName = "Laptop", Quantity = 1, UnitPrice = 1200m }
                        }
                    }
                }
            }
        };

        // Get all unique product names across all customer orders
        var allProductNames = customers
            .SelectMany(c => c.Orders)         // Flatten customers' orders into a single sequence of orders
            .SelectMany(o => o.Items)          // Flatten orders' items into a single sequence of order items
            .Select(item => item.ProductName)  // Project to just the product names
            .Distinct()                        // Get unique names
            .OrderBy(name => name)             // Order alphabetically
            .ToList();

        Console.WriteLine("All unique product names ordered:");
        foreach (var name in allProductNames) { Console.WriteLine($"- {name}"); }

        // Get all OrderItems along with the Customer Name and Order ID
        var detailedOrderItems = customers
            .SelectMany(c => c.Orders.Select(o => new { Customer = c, Order = o })) // Flatten orders with their customer context
            .SelectMany(co => co.Order.Items.Select(item => new // Flatten items with customer and order context
            {
                co.Customer.Name,
                co.Order.OrderId,
                item.ProductName,
                item.Quantity,
                item.UnitPrice,
                LineTotal = item.Quantity * item.UnitPrice
            }))
            .ToList();

        Console.WriteLine("\nDetailed Order Items (flattened and enriched):");
        foreach (var item in detailedOrderItems)
        {
            Console.WriteLine($"- Customer: {item.Name}, Order: {item.OrderId}, Product: {item.ProductName}, Total: {item.LineTotal:C}");
        }

        Console.WriteLine();
    }
}
```

### 3\. `ToDictionary`: Transforming to a Dictionary

`ToDictionary` allows you to transform a sequence into a `Dictionary<TKey, TValue>`. You provide two lambda expressions: one for extracting the key and one for extracting the value.

**Code Example - `ToDictionary`:**

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

public class User
{
    public int UserId { get; set; }
    public string Username { get; set; }
    public string Email { get; set; }
}

public static class LinqProjectionToDictionary
{
    public static void Run()
    {
        Console.WriteLine("--- ToDictionary: Transforming to a Dictionary ---");

        var users = new List<User>
        {
            new User { UserId = 1, Username = "jdoe", Email = "john.doe@example.com" },
            new User { UserId = 2, Username = "asmith", Email = "anna.smith@example.com" },
            new User { UserId = 3, Username = "cjones", Email = "chris.jones@example.com" }
        };

        // Create a dictionary with UserId as key and Username as value
        var userDictionaryById = users.ToDictionary(u => u.UserId, u => u.Username);
        Console.WriteLine("User Dictionary (Id -> Username):");
        foreach (var entry in userDictionaryById) { Console.WriteLine($"- {entry.Key}: {entry.Value}"); }

        // Create a dictionary with Email as key and the User object as value
        // Note: You must ensure keys are unique, or ToDictionary will throw an exception.
        var userDictionaryByEmail = users.ToDictionary(u => u.Email, u => u);
        Console.WriteLine("\nUser Dictionary (Email -> User Object):");
        foreach (var entry in userDictionaryByEmail) { Console.WriteLine($"- {entry.Key}: {entry.Value.Username}"); }

        Console.WriteLine();
    }
}
```

```csharp
// To run all examples:
public class Program
{
    public static void Main(string[] args)
    {
        LinqProjectionSelect.Run();
        LinqProjectionSelectMany.Run();
        LinqProjectionToDictionary.Run();
        LinqInterviewAngle.Run(); // For interview angle
    }
}
```

-----

### 🧠 Interview Angle: Project a list of employees to only names and departments, sorted alphabetically.

This question tests your understanding of `Select` for projection and `OrderBy` for sorting.

**Scenario:** You have a full list of `Employee` objects with many properties, but for a specific report, you only need their full name and department, and the list should be sorted by full name.

**Code Example:**

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

public class Employee
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public string Department { get; set; }
    public decimal Salary { get; set; }
}

public static class LinqInterviewAngle
{
    public static void Run()
    {
        Console.WriteLine("--- Interview Angle: Projecting and Sorting Employees ---");

        var employees = new List<Employee>
        {
            new Employee { Id = 1, FirstName = "Charlie", LastName = "Brown", Department = "HR", Salary = 62000m },
            new Employee { Id = 2, FirstName = "Alice", LastName = "Smith", Department = "IT", Salary = 85000m },
            new Employee { Id = 3, FirstName = "Bob", LastName = "Johnson", Department = "Finance", Salary = 70000m },
            new Employee { Id = 4, FirstName = "David", LastName = "Davis", Department = "HR", Salary = 65000m }
        };

        // Project to anonymous type with FullName and Department
        // Then order by FullName alphabetically
        var projectedAndSortedEmployees = employees
            .Select(e => new
            {
                FullName = $"{e.FirstName} {e.LastName}", // Create a new 'FullName' property
                e.Department                               // Include the 'Department' property
            })
            .OrderBy(e => e.FullName) // Sort by the newly created FullName property
            .ToList(); // Materialize into a List

        Console.WriteLine("Projected and Sorted Employees:");
        foreach (var emp in projectedAndSortedEmployees)
        {
            Console.WriteLine($"- Name: {emp.FullName}, Department: {emp.Department}");
        }
        Console.WriteLine();
    }
}
```

**Explanation:**

1.  **`employees.Select(...)`**: This is the core projection step.
      * We use an **anonymous type** (`new { ... }`) to create new objects on the fly. Anonymous types are perfect when you need a simple, temporary structure for a subset of data or derived values, and you don't need to define a formal class for it.
      * `FullName = $"{e.FirstName} {e.LastName}"`: This creates a new property called `FullName` by concatenating the first and last names.
      * `e.Department`: This directly includes the `Department` property from the original `Employee` object.
2.  **`.OrderBy(e => e.FullName)`**: After projection, the sequence now consists of these anonymous types, each having a `FullName` property. We then use `OrderBy` to sort this sequence based on the `FullName` property alphabetically (ascending is the default).
3.  **`.ToList()`**: Finally, `ToList()` materializes the result into a concrete `List` of these anonymous types, making it ready for consumption (e.g., displaying in a console or binding to a UI).