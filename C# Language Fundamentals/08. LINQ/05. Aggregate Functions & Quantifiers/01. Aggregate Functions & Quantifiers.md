Let's dive into LINQ's **Aggregate Functions & Quantifiers** and then explore how to build your own **Custom LINQ Extensions** using `yield return`. This will solidify your understanding of how LINQ works under the hood, especially with lazy evaluation.

## Aggregate Functions & Quantifiers

These LINQ operators are used to perform calculations or checks across an entire sequence, reducing it to a single value (aggregates) or a boolean result (quantifiers). They always trigger **immediate execution**.

### Quantifiers

Quantifiers return a `bool` value, indicating whether some or all elements in a sequence satisfy a condition.

1.  **`Any()`**: Checks if *any* element in a sequence satisfies a condition.

      * `sequence.Any(predicate)`: Returns `true` if at least one element satisfies the predicate, otherwise `false`.
      * `sequence.Any()`: Returns `true` if the sequence contains any elements, otherwise `false`.

2.  **`All()`**: Checks if *all* elements in a sequence satisfy a condition.

      * `sequence.All(predicate)`: Returns `true` if all elements satisfy the predicate, otherwise `false`. Returns `true` for an empty sequence.

3.  **`Contains()`**: Checks if a sequence contains a specified element.

      * `sequence.Contains(item)`: Returns `true` if the sequence contains `item`, otherwise `false`. Uses the default equality comparer.

**Code Example - Quantifiers:**

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

public class Order
{
    public int OrderId { get; set; }
    public decimal TotalAmount { get; set; }
    public bool IsShipped { get; set; }
    public List<string> Items { get; set; } = new List<string>();
}

public static class LinqQuantifiers
{
    public static void Run()
    {
        Console.WriteLine("--- LINQ Quantifiers (Any, All, Contains) ---");

        var orders = new List<Order>
        {
            new Order { OrderId = 1, TotalAmount = 150.00m, IsShipped = true, Items = { "Laptop", "Mouse" } },
            new Order { OrderId = 2, TotalAmount = 25.50m, IsShipped = false, Items = { "Keyboard" } },
            new Order { OrderId = 3, TotalAmount = 500.00m, IsShipped = true, Items = { "Monitor", "Webcam" } },
            new Order { OrderId = 4, TotalAmount = 10.00m, IsShipped = false, Items = { "Cable" } }
        };

        // Any() examples
        bool hasShippedOrders = orders.Any(o => o.IsShipped);
        Console.WriteLine($"Are there any shipped orders? {hasShippedOrders}"); // True

        bool hasLargeOrders = orders.Any(o => o.TotalAmount > 1000m);
        Console.WriteLine($"Are there any orders over $1000? {hasLargeOrders}"); // False

        bool hasAnyOrders = orders.Any();
        Console.WriteLine($"Are there any orders in the list? {hasAnyOrders}"); // True

        // All() examples
        bool allOrdersShipped = orders.All(o => o.IsShipped);
        Console.WriteLine($"Are all orders shipped? {allOrdersShipped}"); // False

        bool allOrdersHaveItems = orders.All(o => o.Items.Any());
        Console.WriteLine($"Do all orders have at least one item? {allOrdersHaveItems}"); // True

        // Contains() examples
        var orderItemToFind = "Laptop";
        bool containsLaptop = orders.Any(o => o.Items.Contains(orderItemToFind));
        Console.WriteLine($"Does any order contain '{orderItemToFind}'? {containsLaptop}"); // True

        bool containsNonExistentItem = orders.Any(o => o.Items.Contains("Tablet"));
        Console.WriteLine($"Does any order contain 'Tablet'? {containsNonExistentItem}"); // False

        Console.WriteLine();
    }
}
```

### Aggregation Functions

Aggregation functions compute a single value from a sequence of values.

1.  **`Count()`**: Returns the number of elements in a sequence, or the number of elements that satisfy a condition.

      * `sequence.Count()`
      * `sequence.Count(predicate)`

2.  **`Sum()`**: Calculates the sum of the elements in a sequence. Can be applied to numeric types directly or with a selector.

3.  **`Average()`**: Calculates the average of the elements in a sequence. Can be applied to numeric types directly or with a selector.

4.  **`Min()`**: Returns the minimum value in a sequence. Can be applied to comparable types directly or with a selector.

5.  **`Max()`**: Returns the maximum value in a sequence. Can be applied to comparable types directly or with a selector.

6.  **`Aggregate()`**: The most versatile aggregation operator. It applies an accumulator function over a sequence. You can specify a seed value and a result selector. It's essentially a "fold" or "reduce" operation.

      * `sequence.Aggregate(func)`: Applies `func` (`(accumulator, current) => result`) to each element, where the accumulator is the result of the previous operation. The first element becomes the initial accumulator.
      * `sequence.Aggregate(seed, func)`: Starts with `seed` as the initial accumulator.
      * `sequence.Aggregate(seed, func, resultSelector)`: Allows a final transformation of the accumulated result.

**Code Example - Aggregation Functions:**

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
    public int Stock { get; set; }
}

public static class LinqAggregations
{
    public static void Run()
    {
        Console.WriteLine("--- LINQ Aggregation Functions ---");

        var products = new List<Product>
        {
            new Product { Id = 1, Name = "Laptop", Price = 1200m, Stock = 10 },
            new Product { Id = 2, Name = "Mouse", Price = 25m, Stock = 50 },
            new Product { Id = 3, Name = "Keyboard", Price = 75m, Stock = 5 },
            new Product { Id = 4, Name = "Monitor", Price = 300m, Stock = 0 }
        };

        // Count() examples
        int totalProducts = products.Count();
        Console.WriteLine($"Total number of products: {totalProducts}"); // 4

        int productsInStock = products.Count(p => p.Stock > 0);
        Console.WriteLine($"Products currently in stock: {productsInStock}"); // 3

        // Sum() examples
        decimal totalValue = products.Sum(p => p.Price * p.Stock);
        Console.WriteLine($"Total inventory value: {totalValue:C}"); // (1200*10) + (25*50) + (75*5) + (300*0) = 12000 + 1250 + 375 + 0 = 13625

        // Average() examples
        decimal averagePrice = products.Average(p => p.Price);
        Console.WriteLine($"Average product price: {averagePrice:C}"); // (1200+25+75+300) / 4 = 400

        // Min() and Max() examples
        decimal cheapestProductPrice = products.Min(p => p.Price);
        Console.WriteLine($"Cheapest product price: {cheapestProductPrice:C}"); // 25

        string productNameWithMaxStock = products.OrderByDescending(p => p.Stock).Select(p => p.Name).FirstOrDefault();
        Console.WriteLine($"Product with highest stock: {productNameWithMaxStock}"); // Mouse

        // Aggregate() examples
        // Concatenate all product names
        string allProductNames = products.Aggregate("", (currentNames, p) => currentNames + p.Name + ", ").TrimEnd(',', ' ');
        Console.WriteLine($"All product names (aggregated): {allProductNames}"); // Laptop, Mouse, Keyboard, Monitor

        // Calculate total stock using Aggregate
        int totalStock = products.Aggregate(0, (currentStock, p) => currentStock + p.Stock);
        Console.WriteLine($"Total stock of all products (aggregated): {totalStock}"); // 65

        // Calculate a custom string summary
        string productSummary = products.Aggregate(
            "Products:",
            (summary, p) => $"{summary} {p.Name} (${p.Price:N0}, Stock: {p.Stock});",
            finalSummary => finalSummary.TrimEnd(';')); // Remove trailing semicolon
        Console.WriteLine($"Custom product summary (aggregated): {productSummary}");
        // Products: Laptop ($1,200, Stock: 10); Mouse ($25, Stock: 50); Keyboard ($75, Stock: 5); Monitor ($300, Stock: 0)

        Console.WriteLine();
    }
}
```

-----

## Custom LINQ Extensions

Implementing your own LINQ-style methods demonstrates a deep understanding of `IEnumerable<T>`, extension methods, and the power of `yield return` for deferred execution.

Custom LINQ extensions are typically implemented as `static` methods within a `static` class, and they take `this IEnumerable<TSource>` (or `this IQueryable<TSource>`) as their first parameter.

### Key Concepts for Custom Extensions:

1.  **Extension Methods:** The `this` keyword on the first parameter makes a `static` method appear as if it's an instance method of the type `IEnumerable<T>`.
2.  **`yield return`:** This is the magic behind deferred execution for custom enumerable methods. When the C\# compiler encounters `yield return`, it transforms your method into an **iterator block**.
      * The method doesn't execute fully when called. Instead, it returns an `IEnumerable<T>` (or `IEnumerator<T>`).
      * The code within the iterator block only runs **one step at a time** each time the caller requests the *next* element (e.g., in a `foreach` loop).
      * The state of the method is preserved between calls, allowing it to pick up where it left off.
      * This makes the custom extension **lazily evaluated**.

**Code Example - Custom LINQ Extensions:**

```csharp
using System;
using System.Collections.Generic;
using System.Linq; // Important for using built-in LINQ methods alongside custom ones

public static class MyLinqExtensions
{
    // Custom Where (Filter) Extension
    // This demonstrates deferred execution using yield return
    public static IEnumerable<TSource> MyWhere<TSource>(
        this IEnumerable<TSource> source,
        Func<TSource, bool> predicate)
    {
        if (source == null) throw new ArgumentNullException(nameof(source));
        if (predicate == null) throw new ArgumentNullException(nameof(predicate));

        Console.WriteLine("[MyWhere]: Iterator block entered.");
        foreach (var item in source)
        {
            Console.WriteLine($"[MyWhere]: Checking item: {item}");
            if (predicate(item))
            {
                Console.WriteLine($"[MyWhere]: Item {item} passed predicate. Yielding...");
                yield return item; // This is where deferred execution happens
            }
        }
        Console.WriteLine("[MyWhere]: Iterator block exited.");
    }

    // Custom Map (Projection) Extension (similar to Select)
    // Also demonstrates deferred execution
    public static IEnumerable<TResult> MyMap<TSource, TResult>(
        this IEnumerable<TSource> source,
        Func<TSource, TResult> selector)
    {
        if (source == null) throw new ArgumentNullException(nameof(source));
        if (selector == null) throw new ArgumentNullException(nameof(selector));

        Console.WriteLine("[MyMap]: Iterator block entered.");
        foreach (var item in source)
        {
            Console.WriteLine($"[MyMap]: Mapping item...");
            yield return selector(item);
        }
        Console.WriteLine("[MyMap]: Iterator block exited.");
    }

    // Custom ForEach (Immediate execution, for side effects)
    public static void MyForEach<TSource>(
        this IEnumerable<TSource> source,
        Action<TSource> action)
    {
        if (source == null) throw new ArgumentNullException(nameof(source));
        if (action == null) throw new ArgumentNullException(nameof(action));

        Console.WriteLine("[MyForEach]: Executing immediately.");
        foreach (var item in source)
        {
            action(item);
        }
        Console.WriteLine("[MyForEach]: Execution finished.");
    }
}

public static class CustomLinqExtensionsExample
{
    public static void Run()
    {
        Console.WriteLine("--- Custom LINQ Extensions ---");

        List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6 };

        Console.WriteLine("\n--- Testing MyWhere (Deferred) ---");
        // Defining the query - no output from MyWhere yet
        IEnumerable<int> evenNumbersQuery = numbers.MyWhere(n => n % 2 == 0);
        Console.WriteLine("Query 'evenNumbersQuery' defined.");

        Console.WriteLine("Iterating 'evenNumbersQuery' (MyWhere executes here):");
        foreach (var num in evenNumbersQuery)
        {
            Console.WriteLine($"  - Got even number: {num}");
        }

        Console.WriteLine("\n--- Testing MyMap (Deferred) ---");
        // Defining the query - no output from MyMap yet
        IEnumerable<string> mappedStrings = numbers.MyMap(n => $"Number_{n}");
        Console.WriteLine("Query 'mappedStrings' defined.");

        Console.WriteLine("Iterating 'mappedStrings' (MyMap executes here):");
        foreach (var str in mappedStrings)
        {
            Console.WriteLine($"  - Got mapped string: {str}");
        }

        Console.WriteLine("\n--- Testing MyForEach (Immediate) ---");
        // MyForEach executes as soon as it's called
        numbers.MyForEach(n => Console.WriteLine($"  - ForEach item: {n}"));

        Console.WriteLine();
    }
}
```

```csharp
// To run all examples:
public class Program
{
    public static void Main(string[] args)
    {
        LinqQuantifiers.Run();
        LinqAggregations.Run();
        CustomLinqExtensionsExample.Run();
        CustomWhereInterviewAngle.Run(); // For interview angle
    }
}
```

-----

### 🧠 Interview Angle: Write a custom `Where` extension using `yield return`. Why is it lazily evaluated?

This question directly tests your understanding of iterator blocks and deferred execution.

**Custom `Where` Extension (from `MyLinqExtensions` above):**

```csharp
using System;
using System.Collections.Generic;
using System.Linq;

public static class MyCustomLinqExtensions
{
    public static IEnumerable<TSource> CustomWhere<TSource>(
        this IEnumerable<TSource> source,
        Func<TSource, bool> predicate)
    {
        // Basic argument validation (important for robust code)
        if (source == null) throw new ArgumentNullException(nameof(source));
        if (predicate == null) throw new ArgumentNullException(nameof(predicate));

        // This is the iterator block
        // It provides the deferred execution behavior
        Console.WriteLine("[CustomWhere]: Iterator block initialized."); // This line runs immediately when CustomWhere is called
        foreach (var item in source)
        {
            Console.WriteLine($"[CustomWhere]: Checking item: {item}");
            if (predicate(item))
            {
                Console.WriteLine($"[CustomWhere]: Item {item} passed predicate. Yielding...");
                yield return item; // Execution pauses here and returns 'item' to the caller
            }
            else
            {
                Console.WriteLine($"[CustomWhere]: Item {item} failed predicate.");
            }
        }
        Console.WriteLine("[CustomWhere]: Iterator block completed."); // This line runs only after all items are processed
    }
}

public static class CustomWhereInterviewAngle
{
    public static void Run()
    {
        Console.WriteLine("--- Custom Where Extension (Interview Angle) ---");

        List<int> values = new List<int> { 10, 21, 30, 42, 50, 63 };

        Console.WriteLine("\nStep 1: Defining the query using CustomWhere.");
        // Calling CustomWhere doesn't execute the loop inside it yet.
        // It simply returns an IEnumerable<int> (an iterator object).
        IEnumerable<int> evenNumbers = values.CustomWhere(n => {
            Console.WriteLine($"  [Predicate]: Evaluating {n} % 2 == 0");
            return n % 2 == 0;
        });

        Console.WriteLine("Query defined. No items processed yet from CustomWhere.");

        Console.WriteLine("\nStep 2: Iterating the query (execution starts).");
        // The foreach loop drives the execution of CustomWhere
        foreach (var number in evenNumbers)
        {
            Console.WriteLine($"  [Consumer]: Received: {number}");
            if (number > 40) // Simulate early exit from consumer
            {
                Console.WriteLine("  [Consumer]: Breaking iteration after receiving a number > 40.");
                break;
            }
        }
        Console.WriteLine("Iteration finished.");

        Console.WriteLine("\nStep 3: Trying to iterate again (demonstrates re-execution if source is still live).");
        // If the source (values) hasn't changed, iterating again would re-execute from scratch.
        // For demonstration, let's just show it's possible.
        // Console.WriteLine("Iterating again:");
        // foreach (var number in evenNumbers)
        // {
        //     Console.WriteLine($"  [Consumer 2]: Received: {number}");
        // }
    }
}
```

**Why it is Lazily Evaluated (Detailed Explanation):**

The custom `CustomWhere` extension method is lazily evaluated because of the **`yield return`** keyword. Here's a breakdown of how it works:

1.  **Method Call vs. Execution:**

      * When you call `values.CustomWhere(...)`, the code *inside* the `CustomWhere` method (the `foreach` loop and the `if` condition) does **not** execute immediately.
      * Instead, the C\# compiler transforms the `CustomWhere` method into a state machine (an **iterator block**). This state machine implements the `IEnumerable<TSource>` (and `IEnumerator<TSource>`) interface.
      * The call to `CustomWhere` simply returns an instance of this generated state machine object. You're getting a "recipe" or a "promise" to produce items later, not the items themselves.

2.  **`yield return` as a Pause Point:**

      * The `yield return item;` statement acts as a **pause point**. When the caller requests the next item (e.g., during a `foreach` loop or a call to `enumerator.MoveNext()`), the code in `CustomWhere` executes up to the `yield return` statement.
      * The `item` is returned to the caller.
      * The state of the `CustomWhere` method (e.g., the current position in the `foreach` loop, the values of local variables) is **preserved**.

3.  **Resumption on Next Request:**

      * When the caller asks for the *next* item, execution *resumes* immediately after the `yield return` statement. The loop continues to the next item, evaluates the predicate, and either continues or hits another `yield return`.
      * This process continues until the `foreach` loop in `CustomWhere` finishes, or a `yield break` statement is encountered.

4.  **No Unnecessary Processing:**

      * If the consumer of the `IEnumerable<T>` stops iterating early (e.g., uses `break` in a `foreach` loop, or calls `Take()` on the sequence), the `CustomWhere` method stops executing. It won't process any more items from the `source` than are strictly necessary. This is clearly demonstrated in the `[Consumer]: Breaking iteration after receiving a number > 40` example. The `CustomWhere` stops checking subsequent items (50, 63) once the consumer breaks.

**In essence, `yield return` enables a "pull" model:** the consumer "pulls" items from the enumerable one at a time, and the enumerator method only generates items as they are requested. This is the hallmark of lazy evaluation and is fundamental to how many LINQ operators (like `Where`, `Select`, `OrderBy`, `SelectMany`) achieve their efficiency by not processing all data unless absolutely needed.