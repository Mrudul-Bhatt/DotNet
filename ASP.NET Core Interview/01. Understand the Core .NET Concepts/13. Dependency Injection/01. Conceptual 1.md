Here’s a clean, interview-focused breakdown with **Question first → Answer** format, including **code snippets** for clarity.

---

### **1. What is Inversion of Control (IoC)? Explain its core principle and how it differs from traditional control flow.**

**Answer:**

* **Definition:** IoC is a principle where the control of object creation and dependency management is transferred from the class itself to an external entity.
* **Core Principle:** “Don’t call us, we’ll call you.” Instead of classes controlling their own dependencies, an external controller (like a DI container) supplies them.
* **Traditional Control Flow:** The class creates its dependencies directly:

  ```csharp
  public class OrderService {
      private readonly EmailService _emailService = new EmailService(); // tightly coupled
  }
  ```
* **With IoC:** Dependencies are injected from the outside:

  ```csharp
  public class OrderService {
      private readonly IEmailService _emailService;
      public OrderService(IEmailService emailService) {
          _emailService = emailService; // loosely coupled
      }
  }
  ```
* This allows **loose coupling** and **flexibility**.

---

### **2. How does Dependency Injection (DI) relate to IoC? Is DI a pattern, a principle, or a framework?**

**Answer:**

* **Relationship:** DI is an implementation of the IoC principle, specifically focusing on injecting dependencies into a class rather than letting the class create them.
* **Nature:**

  * **Principle:** IoC is the high-level principle.
  * **Pattern:** DI is a design pattern that implements IoC.
  * **Framework:** Tools like **Microsoft.Extensions.DependencyInjection**, Autofac, Ninject, etc., are frameworks/libraries that facilitate DI.

---

### **3. What are the primary benefits of using DI/IoC? Discuss loose coupling, testability, and code reusability.**

**Answer:**

1. **Loose Coupling** – Classes depend on abstractions (interfaces), not concrete implementations.
2. **Testability** – Dependencies can be mocked or stubbed easily in unit tests.
3. **Code Reusability** – Components are reusable across projects because they aren’t tied to specific implementations.

Example:

```csharp
public interface IPaymentService {
    void ProcessPayment(decimal amount);
}

public class PayPalService : IPaymentService {
    public void ProcessPayment(decimal amount) { /* ... */ }
}

public class Checkout {
    private readonly IPaymentService _paymentService;
    public Checkout(IPaymentService paymentService) {
        _paymentService = paymentService;
    }
    public void CompleteOrder() => _paymentService.ProcessPayment(100);
}
```

Here, `Checkout` can use any payment service without changing its code.

---

### **4. Explain the three main types of Dependency Injection: constructor injection, property injection, and method injection. When would you use each?**

**Answer:**

#### **1. Constructor Injection (Most common)**

* **Definition:** Dependencies are provided via constructor parameters.
* **When to Use:** For required dependencies that the class cannot function without.

```csharp
public class ReportService {
    private readonly ILogger _logger;
    public ReportService(ILogger logger) {
        _logger = logger; // Required dependency
    }
}
```

#### **2. Property Injection**

* **Definition:** Dependencies are set through public properties.
* **When to Use:** For optional dependencies that can be changed after object creation.

```csharp
public class ReportService {
    public ILogger Logger { get; set; } // Optional dependency
}
```

#### **3. Method Injection**

* **Definition:** Dependencies are passed as method parameters.
* **When to Use:** For dependencies needed only during a specific method execution.

```csharp
public class ReportService {
    public void GenerateReport(ILogger logger) {
        logger.Log("Report generated.");
    }
}
```

---

### **5. What is a DI container? How does it work, and what is its role in a .NET Core application?**

**Answer:**

* **Definition:** A DI container is a framework component responsible for:

  * Registering service mappings (interface → implementation)
  * Creating instances of classes with all their dependencies
  * Managing lifetime scopes of services (Singleton, Scoped, Transient)

* **How It Works:**

  1. **Register Services** (usually in `Program.cs` / `Startup.cs`)

     ```csharp
     var builder = WebApplication.CreateBuilder(args);
     builder.Services.AddScoped<IEmailService, EmailService>();
     builder.Services.AddTransient<ILogger, ConsoleLogger>();
     ```
  2. **Resolve Dependencies** (automatically by constructor injection)

     ```csharp
     public class OrderController {
         private readonly IEmailService _emailService;
         public OrderController(IEmailService emailService) {
             _emailService = emailService;
         }
     }
     ```

* **Role in .NET Core:**

  * Centralizes dependency management.
  * Eliminates manual `new` keyword usage for dependencies.
  * Handles lifetime management automatically.

---

If you want, I can prepare a **follow-up table comparing all DI types with pros/cons & examples** so it’s ready for a product-company-level interview. That would make it even crisper to recall during an interview.
