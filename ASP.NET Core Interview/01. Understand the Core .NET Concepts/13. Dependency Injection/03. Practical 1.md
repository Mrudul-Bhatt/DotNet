Got it — here’s the Q\&A in the **"Question first → Answer"** format with clear explanations and code snippets for each.

---

## **1. You have a class `ProductService` that needs to log messages. Demonstrate how to refactor this class to use constructor injection for a logger interface (`ILogger<T>`).**

**Answer:**
Constructor injection allows the logger to be provided by the DI container rather than creating it manually, improving testability and maintainability.

**Before (Tightly Coupled, No DI)**

```csharp
public class ProductService
{
    private readonly ILogger _logger;

    public ProductService()
    {
        _logger = new ConsoleLogger(); // hard dependency
    }

    public void ProcessProduct()
    {
        _logger.Log("Processing product...");
    }
}
```

**After (Constructor Injection with `ILogger<ProductService>`)**

```csharp
public class ProductService
{
    private readonly ILogger<ProductService> _logger;

    public ProductService(ILogger<ProductService> logger)
    {
        _logger = logger;
    }

    public void ProcessProduct()
    {
        _logger.LogInformation("Processing product...");
    }
}
```

In **Program.cs**:

```csharp
builder.Services.AddTransient<ProductService>();
```

The DI container will automatically inject the correct logger instance.

---

## **2. Given a .NET Core application, show how you would register a service in the Program.cs file using the built-in DI container. Provide examples for `AddTransient`, `AddScoped`, and `AddSingleton`.**

**Answer:**
The lifetime determines how long a service instance lives.

**Program.cs**:

```csharp
var builder = WebApplication.CreateBuilder(args);

// Transient – new instance every time it's requested
builder.Services.AddTransient<IEmailService, EmailService>();

// Scoped – one instance per HTTP request
builder.Services.AddScoped<IOrderService, OrderService>();

// Singleton – one instance for the entire application lifetime
builder.Services.AddSingleton<ICacheService, MemoryCacheService>();

var app = builder.Build();
app.Run();
```

**Use Cases:**

* **Transient**: Lightweight, stateless services (e.g., email senders, validators).
* **Scoped**: Services tied to a request (e.g., database repositories).
* **Singleton**: Services holding shared state/configuration (e.g., caching, configuration providers).

---

## **3. Imagine you have an `OrderController` that depends on an `IOrderService`. The `IOrderService` itself depends on an `IOrderRepository`. Show how the DI container would resolve this entire dependency chain when a request comes in.**

**Answer:**
The DI container recursively resolves dependencies when constructing the root object (controller).

**Interfaces and Implementations**:

```csharp
public interface IOrderRepository
{
    void SaveOrder(Order order);
}

public class OrderRepository : IOrderRepository
{
    public void SaveOrder(Order order)
    {
        // Save to database
    }
}

public interface IOrderService
{
    void ProcessOrder(Order order);
}

public class OrderService : IOrderService
{
    private readonly IOrderRepository _repo;

    public OrderService(IOrderRepository repo)
    {
        _repo = repo;
    }

    public void ProcessOrder(Order order)
    {
        _repo.SaveOrder(order);
    }
}

[ApiController]
[Route("[controller]")]
public class OrderController : ControllerBase
{
    private readonly IOrderService _service;

    public OrderController(IOrderService service)
    {
        _service = service;
    }

    [HttpPost]
    public IActionResult PlaceOrder(Order order)
    {
        _service.ProcessOrder(order);
        return Ok();
    }
}
```

**Program.cs**:

```csharp
builder.Services.AddScoped<IOrderRepository, OrderRepository>();
builder.Services.AddScoped<IOrderService, OrderService>();
```

**How DI Resolves on a Request:**

1. HTTP request comes to `OrderController`.
2. DI creates `OrderController`, needs `IOrderService`.
3. DI creates `OrderService`, needs `IOrderRepository`.
4. DI creates `OrderRepository` and injects it.
5. Fully constructed `OrderController` is returned.

---

## **4. Write a unit test for a `UserService` class that uses DI. How would you mock or stub the dependencies (e.g., a database context) to isolate the class for testing?**

**Answer:**
We mock dependencies so that the test focuses only on `UserService` logic.

**`UserService` Implementation**:

```csharp
public interface IUserRepository
{
    User GetUserById(int id);
}

public class UserService
{
    private readonly IUserRepository _repo;

    public UserService(IUserRepository repo)
    {
        _repo = repo;
    }

    public string GetUserName(int id)
    {
        var user = _repo.GetUserById(id);
        return user?.Name ?? "Unknown";
    }
}
```

**Unit Test with Moq**:

```csharp
using Moq;
using Xunit;

public class UserServiceTests
{
    [Fact]
    public void GetUserName_ReturnsCorrectName_WhenUserExists()
    {
        // Arrange
        var mockRepo = new Mock<IUserRepository>();
        mockRepo.Setup(r => r.GetUserById(1)).Returns(new User { Id = 1, Name = "John" });

        var service = new UserService(mockRepo.Object);

        // Act
        var result = service.GetUserName(1);

        // Assert
        Assert.Equal("John", result);
    }

    [Fact]
    public void GetUserName_ReturnsUnknown_WhenUserNotFound()
    {
        var mockRepo = new Mock<IUserRepository>();
        mockRepo.Setup(r => r.GetUserById(It.IsAny<int>())).Returns((User)null);

        var service = new UserService(mockRepo.Object);

        var result = service.GetUserName(99);

        Assert.Equal("Unknown", result);
    }
}
```

---

If you want, I can also give you **a visual diagram** of **how DI resolves dependencies in .NET Core** so that it’s interview-friendly and easy to explain. This would make the "dependency chain" answer pop.
