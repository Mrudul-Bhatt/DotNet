Alright — let’s go through your four questions one by one, keeping it both **technically accurate** and **interview-focused**.

---

## **1️⃣ Exception Flow in Chained Async Calls**

**Scenario:**

```csharp
async Task MethodA()
{
    try
    {
        await MethodB();
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Caught in MethodA: {ex.Message}");
    }
}

async Task MethodB() => await MethodC();

async Task MethodC()
{
    throw new InvalidOperationException("Something went wrong in MethodC");
}
```

**Flow:**

1. **MethodC** throws an exception.
2. Since **MethodC** is awaited in **MethodB**, the exception is stored inside the returned `Task`.
3. When **MethodB** awaits MethodC, the exception is rethrown in **MethodB**’s async state machine.
4. This propagates back to **MethodA**, which is awaiting **MethodB**.
5. The exception is rethrown in **MethodA** and is caught by its `try-catch`.

**Key point:**
Exceptions in async methods travel **through the awaited Task chain**, not via the stack frames like synchronous code.

---

## **2️⃣ Async Method Returning a Custom Value + Calling from Non-Async Context**

```csharp
public async Task<int> GetRandomNumberAsync()
{
    await Task.Delay(1000); // Simulate work
    return new Random().Next(1, 100);
}

// Calling from async context:
int result = await GetRandomNumberAsync();
```

**Calling from a non-async context (❌ problematic way):**

```csharp
int result = GetRandomNumberAsync().Result; // Can deadlock in UI/ASP.NET
```

**Why deadlock happens:**

* `.Result` and `.Wait()` block the current thread until the task completes.
* If the async method tries to resume on the same synchronization context (UI thread or ASP.NET request thread), it can’t because that thread is blocked — **classic deadlock**.

**Correct approaches:**

1. **Make the caller async** (best solution):

   ```csharp
   async Task MainMethod()
   {
       int result = await GetRandomNumberAsync();
   }
   ```
2. **If forced into sync context** (e.g., console app initialization), run without capturing context:

   ```csharp
   int result = Task.Run(() => GetRandomNumberAsync()).GetAwaiter().GetResult();
   ```

---

## **3️⃣ `await` vs `.Wait()` / `.Result`**

| Feature                   | `await`                           | `.Wait()` / `.Result`                  |
| ------------------------- | --------------------------------- | -------------------------------------- |
| Blocking?                 | No (async, non-blocking)          | Yes (blocks current thread)            |
| Exception handling        | Throws the **original** exception | Wraps in `AggregateException`          |
| Deadlock risk             | No (if used properly)             | Yes, especially in UI/ASP.NET contexts |
| State machine integration | Yes                               | No                                     |

**Rule of thumb:**
Always use **`await`** inside async methods. Avoid `.Wait()` and `.Result` unless you have a *very controlled* environment.

---

## **4️⃣ ConfigureAwait in Library Code**

**Recommendation:**
In a **library**, you almost always use **`ConfigureAwait(false)`** for internal awaits.

**Reasoning:**

* A library should **not** assume or depend on the caller’s synchronization context (UI thread, ASP.NET context, etc.).
* `ConfigureAwait(false)` avoids the overhead of context capturing and improves throughput.
* The caller decides whether to marshal back to a specific thread.

**Example:**

```csharp
public async Task<string> GetDataAsync()
{
    using var client = new HttpClient();
    string data = await client.GetStringAsync("https://example.com")
                              .ConfigureAwait(false);
    return data;
}
```

**When to use `ConfigureAwait(true)`**:

* In UI code (WPF/WinForms) **inside the UI project**, when you need to update UI elements after the await.

---

If you want, I can now prepare **one complete end-to-end example** showing:

* exception propagation
* safe async-to-sync bridging
* ConfigureAwait in library
  all in a **single flow** so it’s easy to remember in interviews.

Do you want me to put that together?
