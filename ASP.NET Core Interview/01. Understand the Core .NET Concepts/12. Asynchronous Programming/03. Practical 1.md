Alright — let’s break this down one question at a time with concise but thorough answers and examples.

---

## **1. Two Long-Running Independent Async Operations in Parallel with `Task.WhenAll`**

We use `Task.WhenAll` to run multiple independent asynchronous tasks concurrently and wait for all of them to complete.

```csharp
public async Task RunParallelOperationsAsync()
{
    Task<int> task1 = LongRunningOperationAsync(1);
    Task<int> task2 = LongRunningOperationAsync(2);

    // Wait for both to complete
    int[] results = await Task.WhenAll(task1, task2);

    Console.WriteLine($"Result 1: {results[0]}, Result 2: {results[1]}");
}

private async Task<int> LongRunningOperationAsync(int id)
{
    await Task.Delay(2000); // Simulate delay
    return id * 10;
}
```

**Why:** Both operations are independent, so they can be executed in parallel rather than sequentially.

---

## **2. Async REST API Call with Error Handling**

We use `HttpClient` along with `async/await`, proper status code checking, and exception handling.

```csharp
public async Task<T> FetchDataAsync<T>(string url)
{
    using var client = new HttpClient();

    try
    {
        HttpResponseMessage response = await client.GetAsync(url);
        response.EnsureSuccessStatusCode(); // Throws if status code is not success

        string json = await response.Content.ReadAsStringAsync();
        return JsonSerializer.Deserialize<T>(json);
    }
    catch (HttpRequestException ex)
    {
        Console.WriteLine($"Network or HTTP error: {ex.Message}");
        throw;
    }
    catch (JsonException ex)
    {
        Console.WriteLine($"Deserialization error: {ex.Message}");
        throw;
    }
}
```

---

## **3. WPF/WinForms Button Click Handler Without Freezing UI**

In UI applications, `await` keeps the UI thread free to process user input while waiting.

```csharp
private async void btnFetch_Click(object sender, EventArgs e)
{
    btnFetch.Enabled = false;
    try
    {
        string data = await GetDatabaseDataAsync();
        lblResult.Text = data;
    }
    finally
    {
        btnFetch.Enabled = true;
    }
}

private async Task<string> GetDatabaseDataAsync()
{
    await Task.Delay(3000); // Simulate DB query
    return "Data fetched!";
}
```

**Key Point:** The method is `async void` here because it's an event handler — this is the only place `async void` is recommended.

---

## **4. Handling Cancellation in Long-Running Async Operations**

Use `CancellationTokenSource` and pass its `Token` into async methods.

```csharp
public async Task ProcessDataAsync(CancellationToken token)
{
    for (int i = 0; i < 10; i++)
    {
        token.ThrowIfCancellationRequested(); // Stop if cancelled
        Console.WriteLine($"Processing {i}...");
        await Task.Delay(1000, token); // Delay that respects cancellation
    }
}

// Usage:
public async Task RunWithCancellationAsync()
{
    var cts = new CancellationTokenSource();

    Task task = ProcessDataAsync(cts.Token);

    // Cancel after 3 seconds
    cts.CancelAfter(TimeSpan.FromSeconds(3));

    try
    {
        await task;
    }
    catch (OperationCanceledException)
    {
        Console.WriteLine("Operation cancelled.");
    }
}
```

---

If you want, I can **merge all these async/await code examples into a single cohesive C# console app** so you can run and see all behaviors in one place — that would make them easier to test together.

Do you want me to prepare that unified example?
