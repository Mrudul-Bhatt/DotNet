Here’s the **Question first → Answer** format for all four — with code, reasoning, and performance considerations.

---

### **1. Given a complex query with multiple joins, filters, and groups, how would you approach debugging it if it's producing incorrect results or is running slowly? What tools would you use (e.g., EF Core logging, SQL Server Profiler) and what specific things would you look for?**

**Answer:**

**Approach:**

1. **Check the generated SQL**

   * Use EF Core logging:

     ```csharp
     optionsBuilder.LogTo(Console.WriteLine, LogLevel.Information);
     ```
   * Or `.ToQueryString()` (EF Core 5+):

     ```csharp
     var sql = query.ToQueryString();
     ```
2. **Run the SQL directly in SQL Server Management Studio (SSMS)**

   * Verify correctness and compare results to expectations.
3. **Profile performance**

   * Use **SQL Server Profiler** or **Extended Events** to see actual execution time, index usage, and query plans.
4. **Look for:**

   * Missing indexes.
   * N+1 problems (`Include()` missing).
   * Redundant joins or `Distinct`.
   * Filters applied **after** `.ToList()` (causing in-memory filtering).
   * Large projections (fetching entire entity when only a few columns are needed).

---

### **2. You're building a reporting feature that needs to query a database, but the filtering and sorting are dynamic based on user input. Design a flexible LINQ query that can conditionally apply `Where`, `OrderBy`, and `Skip/Take` clauses without duplicating code.**

**Answer:**
Use **deferred execution** with `IQueryable` and conditionally chain operators.

**Code Example:**

```csharp
public IQueryable<Product> GetProducts(
    bool? isActive, 
    string sortBy, 
    bool desc, 
    int? page, 
    int? pageSize)
{
    IQueryable<Product> query = dbContext.Products;

    if (isActive.HasValue)
        query = query.Where(p => p.IsActive == isActive.Value);

    if (!string.IsNullOrEmpty(sortBy))
    {
        query = desc
            ? query.OrderByDescending(p => EF.Property<object>(p, sortBy))
            : query.OrderBy(p => EF.Property<object>(p, sortBy));
    }

    if (page.HasValue && pageSize.HasValue)
        query = query.Skip((page.Value - 1) * pageSize.Value).Take(pageSize.Value);

    return query;
}
```

* **Benefits**: Only applies filters if needed, executes as one optimized SQL query.

---

### **3. Write a LINQ query to get the top 5 most expensive products in each category from a database. The query should be executed efficiently on the server side.**

**Answer:**
Use grouping + ordering inside the query so EF translates it into SQL with **ROW\_NUMBER()** or **TOP** per group.

**Code Example (EF Core):**

```csharp
var topProductsByCategory = dbContext.Products
    .GroupBy(p => p.CategoryId)
    .SelectMany(g => g.OrderByDescending(p => p.Price).Take(5))
    .ToList();
```

* This ensures **server-side execution** (EF translates `Take(5)` per group into SQL).
* **No in-memory filtering** → avoids performance hit on large datasets.

---

### **4. Design a generic repository method that accepts an `Expression<Func<T, bool>>` predicate. Explain why an expression is used instead of a standard `Func<T, bool>` delegate for database queries.**

**Answer:**

* `Expression<Func<T, bool>>` is **parsed** by the LINQ provider and translated into SQL.
* `Func<T, bool>` is compiled into C# code → runs **in memory** (can’t be converted to SQL).

**Code Example:**

```csharp
public interface IRepository<T> where T : class
{
    IEnumerable<T> Find(Expression<Func<T, bool>> predicate);
}

public class Repository<T> : IRepository<T> where T : class
{
    private readonly DbContext _context;

    public Repository(DbContext context) => _context = context;

    public IEnumerable<T> Find(Expression<Func<T, bool>> predicate)
    {
        return _context.Set<T>().Where(predicate).ToList();
    }
}

// Usage:
var expensiveProducts = repo.Find(p => p.Price > 1000);
```

* **Why Expression?**
  This lets EF inspect the expression tree and convert it into `WHERE Price > 1000` in SQL instead of pulling all data into memory.

---

If you want, I can now **combine all three sets of LINQ Q\&A we’ve done into a single “advanced LINQ interview guide” PDF** so you can keep it as a quick reference for prep. That would make this super handy in a product-company interview setting. Would you like me to do that?
