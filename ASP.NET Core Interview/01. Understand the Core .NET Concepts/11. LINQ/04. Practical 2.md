Here’s the **Question first → Answer** format for your next batch, keeping both correctness and performance in focus.

---

### **1. You need to perform a search that looks for a substring within a large text field in a database. Write the LINQ query and explain how the underlying database provider translates this into an efficient SQL command. What potential performance issues could arise from this and how can they be mitigated?**

**Answer:**
**LINQ Query:**

```csharp
var results = dbContext.Articles
    .Where(a => a.Content.Contains("climate change"))
    .ToList();
```

**SQL Translation (SQL Server via EF Core):**

```sql
SELECT * 
FROM Articles
WHERE Content LIKE N'%climate change%'
```

**Performance Issues:**

* `LIKE '%term%'` **cannot use an index** efficiently → full table scan.
* For large text fields (e.g., `nvarchar(max)`), this can be very slow.

**Mitigation:**

* Use **Full-Text Search** (`CONTAINS`, `FREETEXT`) instead of `LIKE`.
* Pre-index searchable columns.
* For prefix matches (`term%`), indexes can be used effectively.
* Limit the search scope with additional filters before substring matching.

---

### **2. Consider a scenario where you have two unrelated lists: one of `Product` objects and one of `OrderItem` objects. Write a LINQ query to find all products that have never been ordered, and explain how the query's execution would be handled in memory.**

**Answer:**
**Data Model:**

```csharp
class Product { public int Id { get; set; } public string Name { get; set; } }
class OrderItem { public int ProductId { get; set; } public int Quantity { get; set; } }
```

**LINQ Query:**

```csharp
var productsNeverOrdered = products
    .Where(p => !orderItems.Any(o => o.ProductId == p.Id))
    .ToList();
```

**Execution Details:**

* Since both lists are in memory, **LINQ to Objects** is used.
* The `Any()` check runs for each product → O(n\*m) complexity in worst case.
* Can be optimized by building a `HashSet<int>` of ordered product IDs:

```csharp
var orderedIds = new HashSet<int>(orderItems.Select(o => o.ProductId));
var productsNeverOrdered = products
    .Where(p => !orderedIds.Contains(p.Id))
    .ToList();
```

* This reduces lookup to O(1) per product.

---

### **3. Given a list of `Student` objects, where each `Student` has a collection of `Course` objects, write a single LINQ query that returns a flattened list of all unique courses from all students.**

**Answer:**
**Data Model:**

```csharp
class Student { public string Name { get; set; } public List<Course> Courses { get; set; } }
class Course { public string Title { get; set; } }
```

**LINQ Query:**

```csharp
var uniqueCourses = students
    .SelectMany(s => s.Courses)
    .Distinct()
    .ToList();
```

* **`SelectMany`** flattens all `Courses` collections into one sequence.
* **`Distinct`** removes duplicates (uses default equality comparer or custom one via `IEqualityComparer<Course>` if needed).

---

### **4. You are working with a legacy database where you cannot use an ORM like Entity Framework. How would you use LINQ to Objects to process data retrieved from a raw SQL query or a `DataReader`?**

**Answer:**

* Retrieve the data into in-memory objects first, then apply LINQ to Objects.

**Example:**

```csharp
var products = new List<Product>();

using (var connection = new SqlConnection(connectionString))
{
    connection.Open();
    using (var command = new SqlCommand("SELECT Id, Name FROM Products", connection))
    using (var reader = command.ExecuteReader())
    {
        while (reader.Read())
        {
            products.Add(new Product
            {
                Id = reader.GetInt32(0),
                Name = reader.GetString(1)
            });
        }
    }
}

// LINQ to Objects on in-memory list
var expensiveProducts = products.Where(p => p.Price > 1000).ToList();
```

**Key Points:**

* LINQ to Objects works on **any in-memory collection**.
* Database access is still manual; LINQ is only for post-processing.

---

If you want, I can now compile **all the LINQ interview Q\&A we’ve done so far into one structured “Advanced LINQ Guide”** that you could literally study in one sitting before an interview. That would save you from scrolling through scattered answers. Would you like me to do that?


### **What is the purpose of Parallel LINQ (PLINQ)?**

**Answer:**

* **Purpose:** PLINQ enables LINQ queries to run in **parallel** across multiple threads/cores, improving performance for **CPU-bound** operations over large in-memory data sets.
* It’s built on top of the **Task Parallel Library (TPL)** and can speed up queries by splitting work across cores automatically.
* Syntax is similar to LINQ, with `.AsParallel()` used to enable parallel execution.

---

### **Example — When to Use PLINQ**

**Scenario:** Processing a **large in-memory dataset** where each item’s computation is CPU-intensive and independent.

```csharp
var numbers = Enumerable.Range(1, 10_000_000);

// CPU-bound operation (e.g., complex calculation)
var results = numbers
    .AsParallel()
    .Where(n => IsPrime(n))
    .ToList();

bool IsPrime(int n)
{
    if (n < 2) return false;
    for (int i = 2; i <= Math.Sqrt(n); i++)
        if (n % i == 0) return false;
    return true;
}
```

* **Why PLINQ here?**

  * Large dataset.
  * CPU-bound work (prime check).
  * No order dependency between items.

---

### **Example — When to Avoid PLINQ**

**Scenario:** Querying a **small dataset** or performing **I/O-bound** operations (like database calls or file reads).

```csharp
var smallList = new List<string> { "A", "B", "C" };

// Avoid PLINQ for I/O-bound work
var results = smallList
    .AsParallel() // adds overhead
    .Select(item => File.ReadAllText($"{item}.txt"))
    .ToList();
```

* **Why avoid here?**

  * Small dataset → parallel overhead outweighs gains.
  * I/O-bound operations don’t benefit much from CPU parallelism.
  * Can cause thread starvation if too many simultaneous I/O requests are made.

---

If you want, I can give you a **quick decision checklist** for “Should I use PLINQ or not?” so you can answer instantly in interviews without hesitation. That would be a good follow-up here.
