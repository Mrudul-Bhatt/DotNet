### Delegating Calculations

A **delegate** defines the signature for a method, allowing methods with matching signatures to be treated as variables.

```csharp
using System;

// 1. Define the delegate
public delegate int CalculateDelegate(int a, int b);

public class Calculator
{
    // Methods matching the delegate's signature
    public int Add(int a, int b)
    {
        return a + b;
    }

    public int Subtract(int a, int b)
    {
        return a - b;
    }

    public int Multiply(int a, int b)
    {
        return a * b;
    }
}

public class Program
{
    public static void Main(string[] args)
    {
        Calculator calc = new Calculator();

        // Assign methods to the delegate
        CalculateDelegate addOperation = new CalculateDelegate(calc.Add);
        CalculateDelegate subtractOperation = calc.Subtract; // Shorthand syntax
        CalculateDelegate multiplyOperation = calc.Multiply;

        // Invoke the methods through the delegate
        Console.WriteLine($"Addition: {addOperation(10, 5)}");
        Console.WriteLine($"Subtraction: {subtractOperation(10, 5)}");
        Console.WriteLine($"Multiplication: {multiplyOperation(10, 5)}");
    }
}
```

-----

### Temperature Sensor Event

This `TemperatureSensor` class demonstrates how to use an event to notify subscribers when the temperature changes significantly.

```csharp
using System;

// Custom EventArgs to pass event data
public class TemperatureChangeEventArgs : EventArgs
{
    public double OldTemperature { get; }
    public double NewTemperature { get; }

    public TemperatureChangeEventArgs(double oldTemp, double newTemp)
    {
        OldTemperature = oldTemp;
        NewTemperature = newTemp;
    }
}

public class TemperatureSensor
{
    private double _currentTemperature;
    private double _threshold;

    // 1. Declare the event using the EventHandler<TEventArgs> delegate
    public event EventHandler<TemperatureChangeEventArgs> TemperatureChanged;

    public TemperatureSensor(double initialTemperature, double threshold)
    {
        _currentTemperature = initialTemperature;
        _threshold = threshold;
    }

    public double CurrentTemperature
    {
        get { return _currentTemperature; }
        set
        {
            if (Math.Abs(value - _currentTemperature) >= _threshold)
            {
                double oldTemp = _currentTemperature;
                _currentTemperature = value;
                // 2. Raise the event if the threshold is met
                OnTemperatureChanged(oldTemp, _currentTemperature);
            }
            else
            {
                _currentTemperature = value; // Update temperature even if not crossing threshold
            }
        }
    }

    // 3. Protected virtual method to raise the event (convention)
    protected virtual void OnTemperatureChanged(double oldTemp, double newTemp)
    {
        TemperatureChanged?.Invoke(this, new TemperatureChangeEventArgs(oldTemp, newTemp));
    }
}

public class SensorApp
{
    public static void Main(string[] args)
    {
        TemperatureSensor sensor = new TemperatureSensor(20.0, 2.0); // Initial 20째C, threshold 2째C

        // Subscribe to the event
        sensor.TemperatureChanged += (sender, e) =>
        {
            Console.WriteLine($"ALERT: Temperature changed from {e.OldTemperature}째C to {e.NewTemperature}째C!");
        };

        Console.WriteLine($"Initial Temp: {sensor.CurrentTemperature}");

        sensor.CurrentTemperature = 21.0; // No alert (change < threshold)
        Console.WriteLine($"Current Temp: {sensor.CurrentTemperature}");

        sensor.CurrentTemperature = 24.0; // Alert (change >= threshold)
        Console.WriteLine($"Current Temp: {sensor.CurrentTemperature}");

        sensor.CurrentTemperature = 22.5; // No alert
        Console.WriteLine($"Current Temp: {sensor.CurrentTemperature}");

        sensor.CurrentTemperature = 19.0; // Alert
        Console.WriteLine($"Current Temp: {sensor.CurrentTemperature}");
    }
}
```

-----

### Custom UI Control Event Exposure

To expose an event from a custom UI control, you follow a standard C\# event pattern. This allows other parts of the application to subscribe and react to interactions within your control.

```csharp
using System;

// 1. (Optional but recommended) Define custom EventArgs if you need to pass specific data
public class ButtonClickedEventArgs : EventArgs
{
    public string ButtonId { get; }
    public DateTime ClickTime { get; }

    public ButtonClickedEventArgs(string buttonId)
    {
        ButtonId = buttonId;
        ClickTime = DateTime.Now;
    }
}

public class CustomButtonControl
{
    // 2. Declare the event using EventHandler<TEventArgs>
    //    or a custom delegate if you don't use EventArgs or need a different signature.
    public event EventHandler<ButtonClickedEventArgs> ButtonClicked;

    public string Name { get; set; }

    public CustomButtonControl(string name)
    {
        Name = name;
    }

    // 3. A method to simulate a user click and raise the event
    public void SimulateClick()
    {
        Console.WriteLine($"'{Name}' button was simulated clicked.");
        // Call the protected virtual method to raise the event
        OnButtonClicked();
    }

    // 4. Protected virtual method to raise the event (convention)
    //    This allows derived classes to hook into the event raising logic.
    protected virtual void OnButtonClicked()
    {
        // Check if there are any subscribers before invoking to avoid NullReferenceException
        ButtonClicked?.Invoke(this, new ButtonClickedEventArgs(this.Name));
    }
}

public class UIManager
{
    public static void Main(string[] args)
    {
        CustomButtonControl myButton = new CustomButtonControl("SubmitButton");

        // Other parts of the application subscribe to the event
        myButton.ButtonClicked += (sender, e) =>
        {
            Console.WriteLine($"UI Manager received ButtonClick event from '{e.ButtonId}' at {e.ClickTime}.");
            Console.WriteLine("Performing submission logic...");
        };

        myButton.ButtonClicked += (sender, e) =>
        {
            Console.WriteLine($"Analytics logging click on '{e.ButtonId}'.");
        };

        // Simulate a user interacting with the button
        myButton.SimulateClick();
        Console.WriteLine("\n--- Another click ---\n");
        myButton.SimulateClick();
    }
}
```

-----

### Flexible Data Validation with Delegates

Using delegates as parameters allows you to inject custom logic into a generic operation, making it highly flexible and reusable. This is a common pattern for applying different algorithms without modifying the core processing loop.

```csharp
using System;
using System.Collections.Generic;

public class User
{
    public int Id { get; set; }
    public string Username { get; set; }
    public string Email { get; set; }
    public int Age { get; set; }

    public override string ToString()
    {
        return $"User [Id: {Id}, Username: {Username}, Email: {Email}, Age: {Age}]";
    }
}

// Define a delegate for validation logic:
// It takes a User object and returns true if valid, false otherwise.
public delegate bool ValidationRule(User user);

public class DataProcessor
{
    public static List<User> ValidateUsers(List<User> users, ValidationRule validationLogic)
    {
        List<User> validUsers = new List<User>();
        List<User> invalidUsers = new List<User>();

        foreach (User user in users)
        {
            if (validationLogic(user)) // Invoke the delegate
            {
                validUsers.Add(user);
            }
            else
            {
                invalidUsers.Add(user);
            }
        }

        Console.WriteLine("\n--- Validation Results ---");
        Console.WriteLine("Valid Users:");
        validUsers.ForEach(u => Console.WriteLine($"- {u}"));
        Console.WriteLine("Invalid Users:");
        invalidUsers.ForEach(u => Console.WriteLine($"- {u}"));

        return validUsers;
    }
}

public class Program
{
    public static void Main(string[] args)
    {
        List<User> userList = new List<User>
        {
            new User { Id = 1, Username = "alice123", Email = "alice@example.com", Age = 25 },
            new User { Id = 2, Username = "bob", Email = "bob@example.com", Age = 17 }, // Invalid age
            new User { Id = 3, Username = "charlie_d", Email = "", Age = 30 }, // Invalid email
            new User { Id = 4, Username = "david", Email = "david@email.com", Age = 40 }
        };

        Console.WriteLine("Initial User List:");
        userList.ForEach(u => Console.WriteLine($"- {u}"));

        // Scenario 1: Validate users for registration (age >= 18, email not empty)
        Console.WriteLine("\n*** Scenario 1: Validating for Registration ***");
        ValidationRule registrationValidation = user =>
            user.Age >= 18 && !string.IsNullOrWhiteSpace(user.Email);

        List<User> registeredUsers = DataProcessor.ValidateUsers(userList, registrationValidation);

        // Scenario 2: Validate users for marketing campaigns (age between 20 and 35)
        Console.WriteLine("\n*** Scenario 2: Validating for Marketing Campaign ***");
        ValidationRule marketingValidation = user =>
            user.Age >= 20 && user.Age <= 35;

        List<User> marketingEligibleUsers = DataProcessor.ValidateUsers(userList, marketingValidation);
    }
}
```