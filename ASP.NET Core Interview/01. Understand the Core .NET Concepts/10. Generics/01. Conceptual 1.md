Q: What are Generics in C\#? What problem do they solve?

A: **Generics** in C\# allow you to define classes, methods, interfaces, and delegates with a **placeholder** for a specific data type. This placeholder, known as a type parameter (typically represented by `T`), is replaced with an actual type at compile time.

They solve the problem of creating reusable code that is both **type-safe** and **efficient**. Before generics, developers often had to choose between two less ideal approaches:

1.  Using the `object` type to work with any data type. This led to a lack of type safety, as the compiler couldn't catch type errors, and required manual casting at runtime, which could cause `InvalidCastException`s. It also incurred a performance penalty due to boxing and unboxing of value types.
2.  Writing separate, nearly identical code for each data type. This created code duplication and was difficult to maintain.

Generics provide a clean solution by allowing you to write the code once, while the compiler ensures it works correctly for whatever type is specified.

-----

Q: Explain the key advantages of using Generics. Why are they a significant improvement over pre-generics approaches?

A: The key advantages of using generics are:

  * **Type Safety:** Generics enforce type constraints at **compile time**. This means the compiler catches type mismatch errors, such as trying to add a `string` to a `List<int>`, before the program even runs. This eliminates the need for manual casting and prevents runtime errors like `InvalidCastException`.
  * **Code Reusability:** You can write a single class, method, or data structure (e.g., a `List<T>`) that can operate on any data type. This prevents code duplication and makes your codebase easier to maintain.
  * **Performance:** For value types (`int`, `struct`), generics avoid the performance overhead of **boxing and unboxing**. When you store a value type in an `object`, it must be "boxed" (wrapped) in a heap object. When you retrieve it, it must be "unboxed," which is a performance-intensive operation. Generics, however, create a specialized version of the code for each value type, eliminating this overhead.

These benefits make generics a significant improvement over pre-generics approaches, offering a powerful combination of safety, reusability, and performance that was not possible before.

-----

Q: What is the difference between a generic class and a non-generic class? Provide an example.

A: The main difference is that a **generic class** is defined with one or more **type parameters**, while a **non-generic class** works with specific, hard-coded data types.

A generic class definition uses a placeholder (e.g., `<T>`) that is replaced with a real type when an object of the class is instantiated. This allows the class to be flexible and reusable. A non-generic class, on the other hand, is limited to the types specified in its definition.

**Example:**

A non-generic `Stack` class might be implemented to only work with `int` types. To create a stack for `string` types, you would have to duplicate the entire class and change the type, which is inefficient.

```csharp
// Non-generic class (limited to int)
public class IntStack
{
    private int[] _items;
    private int _top = -1;

    public void Push(int item) { /* ... */ }
    public int Pop() { /* ... */ return _items[_top--]; }
}
```

A generic `Stack` class, however, can be written once and then used with any type, such as `int`, `string`, or a custom class like `Person`. The type is specified at the time of instantiation.

```csharp
// Generic class (works with any type T)
public class GenericStack<T>
{
    private T[] _items;
    private int _top = -1;

    public void Push(T item) { /* ... */ }
    public T Pop() { /* ... */ return _items[_top--]; }
}

// Usage of the generic class with different types
var intStack = new GenericStack<int>();
intStack.Push(10);
int poppedInt = intStack.Pop();

var stringStack = new GenericStack<string>();
stringStack.Push("Hello");
string poppedString = stringStack.Pop();
```

-----

Q: What are "constraints" in generics? Why are they useful, and what types of constraints are available?

A: **Constraints** are used in generics to restrict the types that can be used for a type parameter. They are defined using the `where` keyword.

**Why are they useful?**
Constraints are useful because they allow you to perform specific operations on the generic type that would otherwise not be possible. Without a constraint, the compiler only knows that the type is `object`, which has a very limited set of accessible members. By applying a constraint, you're telling the compiler that the generic type will at least have the members of the specified constraint, which allows you to call methods or access properties of that type parameter.

**Types of constraints available:**

| Constraint Type | Description | Example |
| :--- | :--- | :--- |
| **`where T : class`** | `T` must be a reference type. | `public class MyClass<T> where T : class { /* ... */ }` |
| **`where T : struct`** | `T` must be a non-nullable value type. | `public class MyStruct<T> where T : struct { /* ... */ }` |
| **`where T : new()`** | `T` must have a public parameterless constructor. This constraint must be last. | `public class MyFactory<T> where T : new() { /* ... */ }` |
| **`where T : IMyInterface`** | `T` must implement a specific interface. | `public class MyLogger<T> where T : ILoggable { /* ... */ }` |
| **`where T : MyBaseClass`** | `T` must be or derive from a specific base class. | `public class MyContainer<T> where T : Animal { /* ... */ }` |
| **`where T : U`** | `T` must be or derive from the generic type `U`. | `public class MyComparer<T, U> where T : U { /* ... */ }` |

Constraints enable a balance between generic flexibility and type-specific functionality. For example, a generic method that needs to call a `Clone()` method on a type parameter can only do so if it applies a constraint that the type implements an interface with a `Clone()` method.