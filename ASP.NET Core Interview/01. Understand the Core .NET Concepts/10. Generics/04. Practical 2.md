Alright — I’ll go through each interview question with the **Question first → Answer** style, and include code snippets where needed.

---

### **1. Write a generic method `CreateInstance<T>()` that creates a new instance of a given type. What constraint is necessary for this to work?**

**Answer:**
To create an instance of a type `T` inside a generic method, the compiler must know that `T` has a **public parameterless constructor**.
This is enforced using the **`where T : new()`** constraint.

**Code Example:**

```csharp
public static T CreateInstance<T>() where T : new()
{
    return new T();
}

// Usage:
var obj = CreateInstance<MyClass>(); // MyClass must have a parameterless constructor
```

---

### **2. You are using a `List<T>` but need to ensure that the items added to the list are not null. How can you enforce this at the class or method level using generics?**

**Answer:**

* There’s **no built-in constraint** in C# (before C# 8.0) to enforce “not null” for reference types.
* You can:

  1. **Check manually** in the `Add` method and throw an `ArgumentNullException`.
  2. **C# 8.0 and later**: Use `where T : notnull` to ensure that `T` is a non-nullable reference type or a value type.

**Code Example (Manual Check):**

```csharp
public class SafeList<T>
{
    private readonly List<T> _items = new List<T>();

    public void Add(T item)
    {
        if (item == null)
            throw new ArgumentNullException(nameof(item), "Item cannot be null");

        _items.Add(item);
    }
}
```

**Code Example (C# 8.0+ with `notnull` constraint):**

```csharp
public class SafeList<T> where T : notnull
{
    private readonly List<T> _items = new List<T>();

    public void Add(T item)
    {
        _items.Add(item); // Compiler ensures T is not nullable
    }
}
```

---

### **3. Explain a scenario where a generic class might contain a non-generic method, and a non-generic class might contain a generic method.**

**Answer:**

#### **Generic class with non-generic method:**

A generic class can still have members that do not depend on the type parameter.
Example: `List<T>` has a `Count` property and a `Clear()` method, which are not generic themselves.

```csharp
public class MyGenericClass<T>
{
    private readonly List<T> _items = new();

    public void Add(T item) => _items.Add(item);

    // Non-generic method in a generic class
    public int Count() => _items.Count;
}
```

---

#### **Non-generic class with generic method:**

A non-generic class can still declare generic methods if the type parameter applies only to that method.
Example: A utility class with a generic `Swap` method.

```csharp
public class Utilities
{
    public static void Swap<T>(ref T a, ref T b)
    {
        T temp = a;
        a = b;
        b = temp;
    }
}

// Usage:
int x = 1, y = 2;
Utilities.Swap(ref x, ref y); // Works for any type
```

---

If you want, I can **add one extra twist** to these answers showing **possible follow-up interview questions** the interviewer might ask based on them. That would make them even more “product-company” ready.
