### ✅ **Question 1:**

Create a base class `Shape` with a `CalculateArea()` method. Then, create two derived classes, `Circle` and `Rectangle`, each providing their own implementation of `CalculateArea()`. Demonstrate how you can use polymorphism to calculate the area of various shapes stored in a collection of `Shape` objects.

---

### ✅ **Answer 1:**

```csharp
using System;
using System.Collections.Generic;

public class Shape
{
    // Marking as virtual enables overriding in derived classes
    public virtual double CalculateArea()
    {
        return 0; // Default implementation (could also be abstract)
    }
}

public class Circle : Shape
{
    public double Radius { get; }

    public Circle(double radius) => Radius = radius;

    public override double CalculateArea() =>
        Math.PI * Radius * Radius;
}

public class Rectangle : Shape
{
    public double Width  { get; }
    public double Height { get; }

    public Rectangle(double width, double height)
    {
        Width  = width;
        Height = height;
    }

    public override double CalculateArea() =>
        Width * Height;
}

public class Program
{
    public static void Main()
    {
        // Polymorphic collection of shapes
        List<Shape> shapes = new()
        {
            new Circle(5),        // Area ≈ 78.54
            new Rectangle(4, 6)   // Area = 24
        };

        foreach (Shape shape in shapes)
        {
            Console.WriteLine($"Area: {shape.CalculateArea():F2}");
        }
    }
}
```

**Polymorphism in action:**

* The list stores each object as the **base type** `Shape`.
* At runtime, the CLR chooses the **correct overridden implementation** (`Circle.CalculateArea()` or `Rectangle.CalculateArea()`) for each element, even though the loop’s variable type is `Shape`.
* This lets you extend the hierarchy with new shape types (e.g., `Triangle`) without changing the loop logic.
