### ✅ Question 1:

**Design an abstract class `Employee` with an abstract method `CalculateSalary()`. Create two concrete derived classes, `FullTimeEmployee` and `PartTimeEmployee`, each providing a different implementation for `CalculateSalary()`.**

---

### ✅ Answer 1:

This example demonstrates **abstraction and polymorphism** using an abstract base class and two concrete implementations.

```csharp
public abstract class Employee
{
    public string Name { get; set; }
    public abstract decimal CalculateSalary(); // Abstract method to enforce implementation
}

public class FullTimeEmployee : Employee
{
    public decimal MonthlySalary { get; set; }

    public override decimal CalculateSalary()
    {
        return MonthlySalary;
    }
}

public class PartTimeEmployee : Employee
{
    public decimal HourlyRate { get; set; }
    public int HoursWorked { get; set; }

    public override decimal CalculateSalary()
    {
        return HourlyRate * HoursWorked;
    }
}
```

**Usage (Polymorphism):**

```csharp
List<Employee> employees = new List<Employee>
{
    new FullTimeEmployee { Name = "Alice", MonthlySalary = 50000 },
    new PartTimeEmployee { Name = "Bob", HourlyRate = 500, HoursWorked = 80 }
};

foreach (var emp in employees)
{
    Console.WriteLine($"{emp.Name}'s Salary: {emp.CalculateSalary()}");
}
```

---

### ✅ Question 2:

**Define an interface `ILogger` with methods like `LogInfo(string message)` and `LogError(string message)`. Then, create two classes, `FileLogger` and `ConsoleLogger`, that implement this interface.**

---

### ✅ Answer 2:

This showcases **interface-based programming** for loose coupling and flexible logging strategies.

```csharp
public interface ILogger
{
    void LogInfo(string message);
    void LogError(string message);
}
```

**ConsoleLogger Implementation:**

```csharp
public class ConsoleLogger : ILogger
{
    public void LogInfo(string message)
    {
        Console.WriteLine($"[INFO] {message}");
    }

    public void LogError(string message)
    {
        Console.Error.WriteLine($"[ERROR] {message}");
    }
}
```

**FileLogger Implementation:**

```csharp
using System.IO;

public class FileLogger : ILogger
{
    private const string LogFilePath = "log.txt";

    public void LogInfo(string message)
    {
        File.AppendAllText(LogFilePath, $"INFO: {message}\n");
    }

    public void LogError(string message)
    {
        File.AppendAllText(LogFilePath, $"ERROR: {message}\n");
    }
}
```

**Usage (Dependency Injection style):**

```csharp
ILogger logger = new ConsoleLogger(); // or new FileLogger();

logger.LogInfo("Application started.");
logger.LogError("Something went wrong.");
```

---

Let me know if you want follow-up questions on abstract/interface combinations, DI patterns, or SOLID principles using these classes.
