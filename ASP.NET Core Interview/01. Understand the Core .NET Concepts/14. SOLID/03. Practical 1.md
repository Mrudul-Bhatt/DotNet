### Given a class that handles user authentication, logging, and data validation, identify the SOLID principle it's violating. How would you refactor this class to adhere to that principle?

**Answer:**

The class is violating the **Single Responsibility Principle (SRP)**. It has more than one reason to change, as it is responsible for three distinct tasks: user authentication, logging, and data validation.

To refactor this class to adhere to SRP, you would split these responsibilities into separate, dedicated classes.

```csharp
// Original class violating SRP
public class UserProcessor
{
    public bool AuthenticateUser(string username, string password) { /* ... */ }
    public void LogAction(string message) { /* ... */ }
    public bool ValidateData(string data) { /* ... */ }
}
```

**Refactored Classes Adhering to SRP:**

```csharp
// 1. Class for User Authentication
public class UserAuthenticator
{
    public bool Authenticate(string username, string password) { /* ... */ }
}

// 2. Class for Logging
public class Logger
{
    public void Log(string message) { /* ... */ }
}

// 3. Class for Data Validation
public class DataValidator
{
    public bool IsValid(string data) { /* ... */ }
}
```

By refactoring, each class now has a single responsibility, making the code more modular, easier to test, and simpler to maintain.

-----

### You have a base `Shape` class with a `CalculateArea()` method, and derived classes like `Circle` and `Square`. A new requirement is to add a `CalculatePerimeter()` method. Demonstrate how you would implement this using the Open/Closed Principle without modifying the existing `Shape` class.

**Answer:**

The **Open/Closed Principle (OCP)** states that software entities should be open for extension but closed for modification. To add the `CalculatePerimeter()` method without changing the existing `Shape` class, you would add an abstract method to the base class (if it is still under development) or to a new interface. This example assumes the base class is still extensible.

**Existing Code:**

```csharp
public abstract class Shape
{
    public abstract double CalculateArea();
}

public class Circle : Shape
{
    private double _radius;
    public Circle(double radius) { _radius = radius; }
    public override double CalculateArea() => Math.PI * _radius * _radius;
}

public class Square : Shape
{
    private double _side;
    public Square(double side) { _side = side; }
    public override double CalculateArea() => _side * _side;
}
```

**Refactored Code Adhering to OCP:**

To add a new method without modifying the base `Shape` class, you can create a new interface that provides the perimeter functionality. The derived classes that need this new functionality can then implement this interface.

```csharp
// New interface for perimeter calculation
public interface IHasPerimeter
{
    double CalculatePerimeter();
}

// The Circle class can now implement the new interface
public class Circle : Shape, IHasPerimeter
{
    private double _radius;
    public Circle(double radius) { _radius = radius; }
    public override double CalculateArea() => Math.PI * _radius * _radius;
    public double CalculatePerimeter() => 2 * Math.PI * _radius;
}

// The Square class can also implement the new interface
public class Square : Shape, IHasPerimeter
{
    private double _side;
    public Square(double side) { _side = side; }
    public override double CalculateArea() => _side * _side;
    public double CalculatePerimeter() => 4 * _side;
}
```

This design allows you to extend the system with new functionality (perimeter calculation) without modifying the original `Shape` class, thus adhering to OCP.

-----

### Consider a `Bird` base class with a `Fly()` method. A new `Penguin` class needs to be created. How would you design the class hierarchy to avoid violating the Liskov Substitution Principle, and why would simply making `Penguin` inherit from `Bird` be problematic?

**Answer:**

Simply having a `Penguin` class inherit from a `Bird` class that has a `Fly()` method would violate the **Liskov Substitution Principle (LSP)**. A `Penguin` cannot fly, so if a `Penguin` object were to be used where a `Bird` object is expected, a call to the `Fly()` method would either throw an exception or produce unexpected behavior, breaking the client's assumption that all `Bird` objects can fly.

To avoid this violation, you should design the class hierarchy around the behavior, not the category. You can introduce an interface for flying.

**Correct Design Adhering to LSP:**

1.  **Introduce a `IFlyable` Interface:** Create an interface for flying behavior. This isolates the flying functionality.

2.  **Make `Bird` a more general base class:** The `Bird` class can remain non-abstract or even be just an interface.

3.  **Implement the interface in specific subclasses:** Only classes that can fly should implement the `IFlyable` interface.

<!-- end list -->

```csharp
// 1. Create a Flyable interface
public interface IFlyable
{
    void Fly();
}

// 2. Base Bird class without a Fly() method
public class Bird
{
    public void Chirp() { /* ... */ }
}

// 3. Classes that can fly implement the interface
public class Eagle : Bird, IFlyable
{
    public void Fly() { /* Logic for flying */ }
}

// 4. The Penguin class inherits from Bird but does not implement IFlyable
public class Penguin : Bird
{
    public void Swim() { /* Logic for swimming */ }
}
```

This design respects LSP because a `Penguin` object is not substitutable for an `Eagle` object in a context that expects the `Fly()` method. This ensures that the program will not encounter unexpected behavior.

-----

### You're designing a notification system that can send messages via email, SMS, or push notifications. Apply the Interface Segregation Principle by designing appropriate interfaces and classes for this system.

**Answer:**

The **Interface Segregation Principle (ISP)** suggests creating many small, specific interfaces rather than one large, general-purpose one. A single "fat" interface for a notification system would force a class like an `EmailSender` to implement methods for SMS or push notifications that it doesn't need.

**Violation of ISP (Fat Interface):**

```csharp
// Fat interface
public interface INotificationSender
{
    void SendEmail(string to, string message);
    void SendSms(string to, string message);
    void SendPushNotification(string deviceToken, string message);
}
```

**Design Adhering to ISP:**

By creating specific interfaces for each notification type, clients only need to depend on the interfaces they use.

```csharp
// 1. Specific interfaces for each notification type
public interface IEmailSender
{
    void SendEmail(string to, string message);
}

public interface ISmsSender
{
    void SendSms(string to, string message);
}

public interface IPushNotificationSender
{
    void SendPushNotification(string deviceToken, string message);
}

// 2. Concrete classes implementing only the interfaces they need
public class EmailService : IEmailSender
{
    public void SendEmail(string to, string message) { /* ... */ }
}

public class SmsService : ISmsSender
{
    public void SendSms(string to, string message) { /* ... */ }
}

public class PushNotificationService : IPushNotificationSender
{
    public void SendPushNotification(string deviceToken, string message) { /* ... */ }
}
```

This design adheres to ISP because each service class is only responsible for the methods relevant to its function, and clients (e.g., a user management class) can simply depend on the specific notification interfaces they need, promoting loose coupling and better maintainability.