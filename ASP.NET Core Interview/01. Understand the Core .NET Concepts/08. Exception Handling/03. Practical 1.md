Here are the C\# code snippets and explanations for the exception handling scenarios you've described:

### Question 1: Write a C\# code snippet that attempts to divide two numbers. Handle potential `DivideByZeroException` and `FormatException` (if parsing input) using multiple `catch` blocks. Include a `finally` block to print a "Calculation finished" message.

**My Answer:**

```csharp
using System;

public class Calculator
{
    public static void PerformDivision(string num1Str, string num2Str)
    {
        int num1 = 0;
        int num2 = 0;
        int result = 0;

        try
        {
            Console.WriteLine($"Attempting to divide '{num1Str}' by '{num2Str}'...");

            // Attempt to parse the first number. Can throw FormatException.
            num1 = int.Parse(num1Str);

            // Attempt to parse the second number. Can throw FormatException.
            num2 = int.Parse(num2Str);

            // Perform division. Can throw DivideByZeroException.
            result = num1 / num2;

            Console.WriteLine($"Result: {num1} / {num2} = {result}");
        }
        catch (FormatException ex) // Specific catch for invalid input format
        {
            Console.WriteLine($"Error: Invalid number format provided. Details: {ex.Message}");
            // Log the exception details here for debugging
        }
        catch (DivideByZeroException ex) // Specific catch for division by zero
        {
            Console.WriteLine($"Error: Cannot divide by zero. Details: {ex.Message}");
            // Log the exception details here for debugging
        }
        catch (Exception ex) // General catch for any other unexpected exception
        {
            Console.WriteLine($"An unexpected error occurred during calculation. Details: {ex.Message}");
            // Always log general exceptions for later investigation
        }
        finally // This block always executes, regardless of whether an exception occurred or was caught
        {
            Console.WriteLine("Calculation finished.");
            Console.WriteLine("------------------------------------");
        }
    }

    public static void Main(string[] args)
    {
        // Test cases:
        PerformDivision("10", "2");      // Normal execution
        PerformDivision("10", "0");      // DivideByZeroException
        PerformDivision("abc", "5");     // FormatException for num1
        PerformDivision("10", "xyz");    // FormatException for num2
        PerformDivision("20", "4");      // Another normal execution
    }
}
```

**Explanation:**

1.  **`try` block:** This block contains the code that might throw exceptions: `int.Parse()` (for `FormatException`) and the division operation (for `DivideByZeroException`).
2.  **`catch (FormatException ex)`:** This block specifically catches errors that occur when the input strings (`num1Str`, `num2Str`) cannot be converted into valid integers.
3.  **`catch (DivideByZeroException ex)`:** This block specifically catches errors that occur when the second number (`num2`) is zero during the division operation.
4.  **`catch (Exception ex)`:** This is a general catch-all block. It will catch any other type of exception that was not caught by the more specific `FormatException` or `DivideByZeroException` blocks. It's good practice to include this at the end to prevent unhandled exceptions, but always log its details.
5.  **`finally` block:** This block is guaranteed to execute after the `try` block and any `catch` block (if an exception occurred). It's used here to print a "Calculation finished" message, demonstrating its use for cleanup or finalization tasks that must always run.

-----

### Question 2: You have a method that reads data from a file. Demonstrate how you would ensure the file handle is always closed, even if an exception occurs during reading. Provide two ways to achieve this.

**My Answer:**

Ensuring file handles are always closed is crucial to prevent resource leaks. Here are two common and effective ways to achieve this in C\#:

#### Way 1: Using a `try-finally` Block (Manual Cleanup)

This method explicitly declares the resource outside the `try` block, initializes it inside, and then ensures its disposal in the `finally` block.

```csharp
using System;
using System.IO;

public class FileHandlerManual
{
    public static void ReadFileWithFinally(string filePath)
    {
        StreamReader? reader = null; // Declare outside try to ensure scope for finally
        Console.WriteLine($"\n--- Reading file '{filePath}' with try-finally ---");
        try
        {
            // Attempt to open the file. This might throw FileNotFoundException, IOException, etc.
            reader = new StreamReader(filePath);
            Console.WriteLine("File opened successfully.");

            // Attempt to read content. This might throw IOException.
            string content = reader.ReadToEnd();
            Console.WriteLine($"Content read (first 50 chars): {content.Substring(0, Math.Min(content.Length, 50))}...");
        }
        catch (FileNotFoundException ex)
        {
            Console.WriteLine($"Error: File not found at '{filePath}'. Details: {ex.Message}");
        }
        catch (IOException ex)
        {
            Console.WriteLine($"Error: An I/O error occurred while reading '{filePath}'. Details: {ex.Message}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An unexpected error occurred: {ex.Message}");
        }
        finally
        {
            // This block is guaranteed to execute.
            // Ensure the reader is not null before attempting to close/dispose it.
            if (reader != null)
            {
                reader.Dispose(); // Dispose() calls Close() internally for StreamReader
                Console.WriteLine("File reader (StreamReader) closed in finally block.");
            }
            else
            {
                Console.WriteLine("File reader was not opened (or was null). No cleanup needed in finally.");
            }
        }
    }

    public static void Main(string[] args)
    {
        // Create a dummy file for testing
        File.WriteAllText("sample.txt", "This is a sample text file for demonstration purposes. It has some content.");

        ReadFileWithFinally("sample.txt");       // File exists, normal read
        ReadFileWithFinally("nonexistent.txt");  // File not found exception
        // Simulate an error during read (e.g., permissions, though harder to force in simple code)
        // For demonstration, imagine an error happens after reader is opened.
        // The finally block would still execute.

        File.Delete("sample.txt"); // Clean up
    }
}
```

#### Way 2: Using the `using` Statement (Idiomatic Cleanup for `IDisposable` Objects)

This is the preferred and most concise way to manage resources that implement the `IDisposable` interface (like `StreamReader`, `SqlConnection`, `HttpClient`, etc.). The `using` statement automatically generates a `try-finally` block behind the scenes and calls `Dispose()` when the block is exited.

```csharp
using System;
using System.IO;

public class FileHandlerUsing
{
    public static void ReadFileWithUsing(string filePath)
    {
        Console.WriteLine($"\n--- Reading file '{filePath}' with using statement ---");
        try
        {
            // The 'using' statement ensures reader.Dispose() is called automatically
            // when control leaves this block, even if an exception occurs.
            using (StreamReader reader = new StreamReader(filePath))
            {
                Console.WriteLine("File opened successfully.");
                string content = reader.ReadToEnd();
                Console.WriteLine($"Content read (first 50 chars): {content.Substring(0, Math.Min(content.Length, 50))}...");
            } // reader.Dispose() is called implicitly here
            Console.WriteLine("File reader (StreamReader) closed automatically by using statement.");
        }
        catch (FileNotFoundException ex)
        {
            Console.WriteLine($"Error: File not found at '{filePath}'. Details: {ex.Message}");
        }
        catch (IOException ex)
        {
            Console.WriteLine($"Error: An I/O error occurred while reading '{filePath}'. Details: {ex.Message}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"An unexpected error occurred: {ex.Message}");
        }
        // No 'finally' block needed specifically for reader cleanup here,
        // as 'using' handles it.
    }

    public static void Main(string[] args)
    {
        // Create a dummy file for testing
        File.WriteAllText("sample.txt", "This is a sample text file for demonstration purposes. It has some content.");

        ReadFileWithUsing("sample.txt");       // File exists, normal read
        ReadFileWithUsing("nonexistent.txt");  // File not found exception

        File.Delete("sample.txt"); // Clean up
    }
}
```

**Comparison:**

  * **`try-finally` (Way 1):** More verbose, requires explicit `null` checks, but is flexible for *any* cleanup logic (even non-`IDisposable` resources).
  * **`using` statement (Way 2):** Concise, idiomatic for `IDisposable` objects, automatically handles `Dispose()` call and `null` checks. **This is the generally preferred method for managing disposable resources in C\#.**
      * **C\# 8.0+ `using` declaration:** Even more concise, the resource is disposed at the end of the current scope (method or block).
        ```csharp
        public static void ReadFileWithUsingDeclaration(string filePath)
        {
            Console.WriteLine($"\n--- Reading file '{filePath}' with using declaration ---");
            try
            {
                using StreamReader reader = new StreamReader(filePath); // No parentheses, no block
                Console.WriteLine("File opened successfully.");
                string content = reader.ReadToEnd();
                Console.WriteLine($"Content read (first 50 chars): {content.Substring(0, Math.Min(content.Length, 50))}...");
            } // reader.Dispose() is called here when the method exits (or an exception occurs)
            catch (FileNotFoundException ex) { /* ... */ }
            // ... other catches
            Console.WriteLine("File reader (StreamReader) closed automatically by using declaration.");
        }
        ```

-----

### Question 3: Design a custom exception called `InsufficientFundsException`. It should have a constructor that takes a message and the `accountBalance` at the time of the error. Demonstrate how to throw and catch this exception.

**My Answer:**

```csharp
using System;

// 1. Design the Custom Exception Class
// Best practice: Derive from System.Exception
// Best practice: End the name with "Exception"
[Serializable] // Recommended if the exception might cross AppDomains (less common in .NET Core/5+)
public class InsufficientFundsException : Exception
{
    // Custom property to hold additional error-specific data
    public decimal AccountBalance { get; }
    public decimal WithdrawalAmount { get; } // Added for more context

    // 2. Implement the three standard constructors (and custom ones)

    // Standard constructor 1: Parameterless constructor
    public InsufficientFundsException() { }

    // Standard constructor 2: Constructor with a message
    public InsufficientFundsException(string message) : base(message) { }

    // Standard constructor 3: Constructor with a message and an inner exception (for chaining)
    public InsufficientFundsException(string message, Exception innerException)
        : base(message, innerException) { }

    // Custom constructor: Takes message, current balance, and withdrawal amount
    public InsufficientFundsException(decimal accountBalance, decimal withdrawalAmount)
        : base($"Insufficient funds. Current balance: {accountBalance:C}, attempted withdrawal: {withdrawalAmount:C}.")
    {
        AccountBalance = accountBalance;
        WithdrawalAmount = withdrawalAmount;
    }

    // Custom constructor with message, balance, and withdrawal amount
    public InsufficientFundsException(string message, decimal accountBalance, decimal withdrawalAmount)
        : base(message)
    {
        AccountBalance = accountBalance;
        WithdrawalAmount = withdrawalAmount;
    }

    // Optional: Constructor for serialization (if [Serializable] is used)
    protected InsufficientFundsException(System.Runtime.Serialization.SerializationInfo info,
                                         System.Runtime.Serialization.StreamingContext context)
        : base(info, context)
    {
        // Deserialize custom properties here if they were serialized
        AccountBalance = info.GetDecimal(nameof(AccountBalance));
        WithdrawalAmount = info.GetDecimal(nameof(WithdrawalAmount));
    }

    // Optional: Override GetObjectData for serialization (if [Serializable] is used)
    public override void GetObjectData(System.Runtime.Serialization.SerializationInfo info,
                                       System.Runtime.Serialization.StreamingContext context)
    {
        base.GetObjectData(info, context);
        info.AddValue(nameof(AccountBalance), AccountBalance);
        info.AddValue(nameof(WithdrawalAmount), WithdrawalAmount);
    }
}

// 2. Demonstrate Throwing and Catching the Exception

public class BankAccount
{
    public decimal Balance { get; private set; }
    public string AccountNumber { get; }

    public BankAccount(string accountNumber, decimal initialBalance)
    {
        AccountNumber = accountNumber;
        Balance = initialBalance;
    }

    public void Withdraw(decimal amount)
    {
        if (amount <= 0)
        {
            throw new ArgumentOutOfRangeException(nameof(amount), "Withdrawal amount must be positive.");
        }

        if (Balance < amount)
        {
            // Throw the custom exception
            throw new InsufficientFundsException(Balance, amount);
        }

        Balance -= amount;
        Console.WriteLine($"Successfully withdrew {amount:C}. New balance: {Balance:C}");
    }
}

public class Program
{
    public static void Main(string[] args)
    {
        BankAccount myAccount = new BankAccount("ACC123", 500m);
        Console.WriteLine($"Account {myAccount.AccountNumber} created with balance: {myAccount.Balance:C}");

        // Successful withdrawal
        try
        {
            myAccount.Withdraw(200m);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Caught unexpected exception: {ex.Message}");
        }

        // Attempting to withdraw more than balance (will throw InsufficientFundsException)
        try
        {
            Console.WriteLine("\nAttempting to withdraw 400m...");
            myAccount.Withdraw(400m); // This will throw InsufficientFundsException
        }
        catch (InsufficientFundsException ex) // Catching the specific custom exception
        {
            Console.WriteLine("\n--- Caught InsufficientFundsException! ---");
            Console.WriteLine($"Error Message: {ex.Message}");
            Console.WriteLine($"Current Balance at error: {ex.AccountBalance:C}");
            Console.WriteLine($"Attempted Withdrawal: {ex.WithdrawalAmount:C}");
            Console.WriteLine("Please deposit more funds or try a smaller amount.");
            // You can also log ex.StackTrace here
        }
        catch (Exception ex) // Catch any other unexpected exceptions
        {
            Console.WriteLine($"\n--- Caught unexpected generic exception! ---");
            Console.WriteLine($"Error: {ex.Message}");
        }

        Console.WriteLine($"\nFinal balance of {myAccount.AccountNumber}: {myAccount.Balance:C}");
    }
}
```

**Explanation:**

1.  **`InsufficientFundsException` Class:**

      * It inherits from `System.Exception`, making it a standard .NET exception.
      * It includes the three standard constructors to allow for various ways of instantiating the exception (with no message, with a message, or with a message and an inner exception for chaining).
      * It has a custom constructor `InsufficientFundsException(decimal accountBalance, decimal withdrawalAmount)` that takes specific context relevant to this financial error. This constructor also calls the base `Exception` constructor with a pre-formatted message.
      * It defines `AccountBalance` and `WithdrawalAmount` as public, read-only properties to carry the specific data related to the error, making the exception more informative.
      * The `[Serializable]` attribute and the serialization constructor/`GetObjectData` override are included for backward compatibility or specific scenarios where the exception might be serialized (e.g., across AppDomains in .NET Framework).

2.  **`BankAccount.Withdraw` Method:**

      * It performs a check `if (Balance < amount)`.
      * If the condition is met, it **throws** a new instance of `InsufficientFundsException`, passing the relevant balance and amount. This immediately halts the `Withdraw` method's execution.

3.  **`Main` Method (`try-catch`):**

      * The call to `myAccount.Withdraw(400m)` is wrapped in a `try` block.
      * A specific `catch (InsufficientFundsException ex)` block is used. This allows the program to precisely identify and handle this particular business error. Inside this block, we can access the custom properties (`ex.AccountBalance`, `ex.WithdrawalAmount`) to provide detailed feedback.
      * A general `catch (Exception ex)` is also included as a fallback for any other unexpected errors.

This approach ensures that financial errors are clearly identified, carry rich context, and can be handled programmatically in a structured way.

-----

### Question 4: Explain what "Global Exception Handling" is in the context of a .NET application (e.g., Console, Web API, WPF/WinForms). Why is it important? How is it typically implemented in an ASP.NET Core Web API?

**My Answer:**

#### What is "Global Exception Handling"?

**Global exception handling** is a centralized mechanism in a .NET application designed to **catch any unhandled exceptions that propagate up to the top level of the application's execution stack**. It acts as a final safety net, ensuring that even if an exception is not caught by specific `try-catch` blocks within the application's logic, it doesn't lead to an immediate, abrupt application crash.

Instead of letting the CLR terminate the process with a raw error message (or a generic crash dialog), global exception handlers intercept these unhandled exceptions, allowing the application to perform last-minute actions.

#### Why is it Important?

Global exception handling is crucial for several reasons, especially in production environments:

1.  **Prevents Application Crashes and Improves Stability:** The most immediate benefit is preventing the application from abruptly terminating due to an unhandled error. This leads to a more stable and resilient user experience.
2.  **Ensures Graceful Degradation/Consistent User Experience:** Instead of a raw stack trace or an unhandled exception dialog, a global handler can present a user-friendly error message, redirect to an error page, or return a standardized error response (e.g., JSON error for APIs). This provides a consistent and professional user experience.
3.  **Crucial for Logging Unhandled Errors:** In production, you absolutely need to know about every unhandled exception. A global handler is the ideal place to log full exception details (message, stack trace, inner exceptions, context) to a persistent store (e.g., database, log file, cloud logging service). This is invaluable for monitoring application health and debugging issues post-deployment.
4.  **Avoids Information Disclosure:** Without a global handler, an unhandled exception might expose sensitive internal information (like database connection strings, file paths, or internal logic) in the stack trace directly to the user or a client, posing a security risk. A global handler can sanitize this.
5.  **Centralized Error Reporting:** It provides a single, consistent point to manage all unhandled errors, making it easier to implement monitoring, alerting, and reporting systems.
6.  **Resource Cleanup (Limited):** While `finally` blocks are for deterministic cleanup, a global handler can sometimes perform very basic, last-ditch cleanup if the application is about to terminate.

#### How is it Typically Implemented in an ASP.NET Core Web API?

In ASP.NET Core Web APIs, global exception handling is primarily implemented using **middleware** in the application's request pipeline.

1.  **`UseExceptionHandler` (Production/Staging):**

      * **Purpose:** This middleware is designed for production environments. When an unhandled exception occurs, it redirects the request to a specified error handling path (e.g., `/Error` or `/Home/Error`), where you can render a generic error page or return a standardized JSON error response.
      * **Implementation (in `Program.cs` or `Startup.cs`):**
        ```csharp
        // In Program.cs (Minimal API example)
        var builder = WebApplication.CreateBuilder(args);
        // ... other services

        var app = builder.Build();

        if (app.Environment.IsDevelopment())
        {
            app.UseDeveloperExceptionPage(); // See point 2
        }
        else
        {
            // UseExceptionHandler for production.
            // When an unhandled exception occurs, it redirects to /Error.
            app.UseExceptionHandler("/Error");
            // Optional: Use HSTS for production
            app.UseHsts();
        }

        // Define the /Error endpoint to handle the redirected requests
        app.Map("/Error", (HttpContext context) =>
        {
            var exceptionHandlerPathFeature =
                context.Features.Get<Microsoft.AspNetCore.Diagnostics.IExceptionHandlerPathFeature>();

            // Log the exception details here (e.g., using ILogger)
            // logger.LogError(exceptionHandlerPathFeature?.Error, "An unhandled exception occurred.");

            // Return a generic error response to the client
            return Results.Problem(
                detail: app.Environment.IsDevelopment() ? exceptionHandlerPathFeature?.Error.StackTrace : null,
                title: "An unexpected error occurred.",
                statusCode: StatusCodes.Status500InternalServerError
            );
        });

        // ... other middleware and endpoints
        app.Run();
        ```
      * **Benefit:** Provides a clean, consistent error response to clients without exposing sensitive stack traces.

2.  **`UseDeveloperExceptionPage` (Development Only):**

      * **Purpose:** This middleware is strictly for development environments. When an unhandled exception occurs, it displays a detailed error page in the browser, including the full stack trace, query string parameters, cookies, and HTTP headers.
      * **Implementation (in `Program.cs` or `Startup.cs`):**
        ```csharp
        if (app.Environment.IsDevelopment())
        {
            app.UseDeveloperExceptionPage(); // Only enable in development
        }
        else
        {
            app.UseExceptionHandler("/Error");
            app.UseHsts();
        }
        ```
      * **Benefit:** Extremely helpful for debugging during development.
      * **Caution:** **NEVER** enable `UseDeveloperExceptionPage` in production environments, as it exposes sensitive application details.

3.  **Custom Exception Handling Middleware:**

      * For more advanced scenarios (e.g., custom error formatting, specific logging requirements, integration with third-party error tracking services), you can create your own custom middleware. This middleware typically sits early in the pipeline and wraps the rest of the pipeline in a `try-catch` block.
      * **Implementation:**
        ```csharp
        public class CustomExceptionMiddleware
        {
            private readonly RequestDelegate _next;
            private readonly ILogger<CustomExceptionMiddleware> _logger;

            public CustomExceptionMiddleware(RequestDelegate next, ILogger<CustomExceptionMiddleware> logger)
            {
                _next = next;
                _logger = logger;
            }

            public async Task InvokeAsync(HttpContext httpContext)
            {
                try
                {
                    await _next(httpContext);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "An unhandled exception occurred in custom middleware.");
                    httpContext.Response.ContentType = "application/json";
                    httpContext.Response.StatusCode = StatusCodes.Status500InternalServerError;

                    await httpContext.Response.WriteAsJsonAsync(new
                    {
                        StatusCode = httpContext.Response.StatusCode,
                        Message = "An unexpected error occurred. Please try again later."
                        // You might include ex.Message or ex.StackTrace ONLY in development
                    });
                }
            }
        }

        // In Program.cs:
        app.UseMiddleware<CustomExceptionMiddleware>(); // Place early in pipeline
        ```

4.  **`IExceptionHandler` (New in .NET 8):**

      * **Purpose:** .NET 8 introduced the `IExceptionHandler` interface, which provides a more structured and testable way to implement global exception handling logic compared to raw middleware. You register implementations of this interface.
      * **Implementation:**
        ```csharp
        // 1. Define your custom exception handler
        public class MyCustomExceptionHandler : IExceptionHandler
        {
            private readonly ILogger<MyCustomExceptionHandler> _logger;

            public MyCustomExceptionHandler(ILogger<MyCustomExceptionHandler> logger)
            {
                _logger = logger;
            }

            public async ValueTask<bool> TryHandleAsync(
                HttpContext httpContext,
                Exception exception,
                CancellationToken cancellationToken)
            {
                _logger.LogError(
                    exception, "An unhandled exception occurred: {Message}", exception.Message);

                // Customize response based on exception type or other logic
                var problemDetails = new ProblemDetails
                {
                    Status = StatusCodes.Status500InternalServerError,
                    Title = "An error occurred while processing your request.",
                    Detail = exception.Message // Only in dev, or sanitized in prod
                };

                httpContext.Response.StatusCode = problemDetails.Status.Value;
                await httpContext.Response.WriteAsJsonAsync(problemDetails, cancellationToken);

                // Return true to indicate that the exception has been handled
                return true;
            }
        }

        // 2. Register it in Program.cs
        var builder = WebApplication.CreateBuilder(args);
        builder.Services.AddProblemDetails(); // Required for ProblemDetails
        builder.Services.AddExceptionHandler<MyCustomExceptionHandler>(); // Register your handler
        // ...

        var app = builder.Build();
        app.UseExceptionHandler(); // This middleware uses registered IExceptionHandler implementations
        // ...
        ```
      * **Benefit:** Cleaner separation of concerns, easier to test, and integrates well with `ProblemDetails` for standardized API error responses.

Global exception handling is an indispensable part of building robust and production-ready .NET applications, providing a last line of defense against unexpected errors.