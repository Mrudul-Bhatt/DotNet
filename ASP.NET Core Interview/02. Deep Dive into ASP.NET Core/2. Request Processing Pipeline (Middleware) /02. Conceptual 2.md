Got it 👍 — I’ll prepare answers **tailored for a 3–5 yrs software engineer** level, keeping them **clear, interview-focused, and with examples**.

---

## **1. Q: What is the difference between `app.Use()`, `app.Run()`, and `app.Map()`? Explain the specific use case for each method.**

**A:**
These are methods used to configure the **middleware pipeline** in ASP.NET Core.

* **`app.Use()`**

  * Adds middleware to the pipeline.
  * Can perform work **before** and **after** the next middleware using `await next()`.
  * Suitable when you want request/response processing to continue through the pipeline.

  ```csharp
  app.Use(async (context, next) =>
  {
      Console.WriteLine("Before next middleware");
      await next(); // Pass control to the next middleware
      Console.WriteLine("After next middleware");
  });
  ```

* **`app.Run()`**

  * Adds a **terminal middleware** (end of pipeline).
  * Does not call `next()`, so it **short-circuits** the pipeline.

  ```csharp
  app.Run(async context =>
  {
      await context.Response.WriteAsync("Hello from Run!");
  });
  ```

* **`app.Map()`**

  * Branches the pipeline based on the **request path**.
  * Useful for creating route-specific middleware.

  ```csharp
  app.Map("/health", builder =>
  {
      builder.Run(async context =>
      {
          await context.Response.WriteAsync("Healthy");
      });
  });
  ```

✅ **Use Cases:**

* `Use` → Cross-cutting concerns (logging, authentication, etc.).
* `Run` → Terminal handling (sending response).
* `Map` → Path-based branching (health checks, admin routes, etc.).

---

## **2. Q: Can you describe the lifecycle of an HTTP request as it travels through the middleware pipeline? What happens on the way "in" and on the way "out" of the pipeline?**

**A:**
The middleware pipeline works like a **chain of delegates**. Each middleware can:

1. Do something **before** passing the request forward (`await next()`).
2. Do something **after** the next middleware finishes (on the way "out").

**Flow:**

* Request comes in.
* Middleware A (logging) → calls `next()` → goes to B.
* Middleware B (authentication) → calls `next()` → goes to C.
* Middleware C (endpoint) → generates a response.
* Response travels back "out" → B → A.

**Example:**

```csharp
app.Use(async (context, next) =>
{
    Console.WriteLine("IN: Logging");
    await next(); // pass to next middleware
    Console.WriteLine("OUT: Logging");
});

app.Use(async (context, next) =>
{
    Console.WriteLine("IN: Authentication");
    await next();
    Console.WriteLine("OUT: Authentication");
});

app.Run(async context =>
{
    await context.Response.WriteAsync("Hello World");
});
```

**Output:**

```
IN: Logging
IN: Authentication
OUT: Authentication
OUT: Logging
```

✅ **Key Point:**

* On the way **in**: request is being processed.
* On the way **out**: response is being processed.

---

## **3. Q: How does the pipeline handle exceptions? What built-in middleware is used for this, and how can you create a custom exception handler?**

**A:**

* **Built-in Middleware:**
  ASP.NET Core provides **`UseExceptionHandler`** for handling exceptions in production.
  It catches unhandled exceptions, logs them, and redirects to an error handling path or delegate.

  ```csharp
  app.UseExceptionHandler("/Error");
  app.Map("/Error", builder =>
  {
      builder.Run(async context =>
      {
          await context.Response.WriteAsync("Something went wrong!");
      });
  });
  ```

* **Developer Mode (for debugging):**
  `app.UseDeveloperExceptionPage()` shows detailed stack trace.

* **Custom Exception Handling Middleware:**
  You can build middleware to catch exceptions and return custom responses.

  ```csharp
  public class CustomExceptionMiddleware
  {
      private readonly RequestDelegate _next;
      public CustomExceptionMiddleware(RequestDelegate next) => _next = next;

      public async Task InvokeAsync(HttpContext context)
      {
          try
          {
              await _next(context);
          }
          catch (Exception ex)
          {
              context.Response.StatusCode = 500;
              await context.Response.WriteAsync($"Custom Error: {ex.Message}");
          }
      }
  }

  // Register
  app.UseMiddleware<CustomExceptionMiddleware>();
  ```

✅ **Key Takeaway:**

* Exceptions bubble up the pipeline.
* Middleware like `UseExceptionHandler` or custom exception middleware can catch them and format the response.
* In dev → `UseDeveloperExceptionPage`. In prod → `UseExceptionHandler`.

---

Would you like me to also prepare **real-world examples** (like logging exceptions to DB, or returning JSON error responses in APIs) for the exception handling part? That often impresses interviewers at the 3–5 yr level.
