### Describe the Liskov Substitution Principle (LSP). What does it mean for a derived class to be "substitutable" for its base class, and what kind of code violations would indicate a violation of this principle?

**Answer:**

The **Liskov Substitution Principle (LSP)** states that if a program uses a base class, it should be able to use a derived class instead without causing any issues or breaking the program. A derived class is "substitutable" for its base class if it maintains the same behavior and contract as the base class.

This means:

  * The derived class's methods should accept the same input parameters as the base class's methods.
  * The derived class should not throw new exceptions that the base class's methods do not.
  * The derived class's methods should not weaken or violate the base class's pre-conditions.
  * The derived class should not change the base class's post-conditions.

Violations often occur when a derived class needs to change the behavior of a method in a way that breaks the expected functionality. For instance, if a `Rectangle` class has a `SetWidth()` and `SetHeight()` method and a `Square` class inherits from it, setting the width should also set the height to maintain the square's properties. However, if a `Square` object is used where a `Rectangle` is expected, a user might call `SetWidth()` and then `SetHeight()` and expect different values, which could lead to unexpected behavior.

A classic example of an LSP violation is when a derived class method returns a `null` value when the base class method guarantees a non-null return.

```csharp
public abstract class Bird
{
    public abstract void Fly();
}

public class Ostrich : Bird
{
    // LSP violation: An Ostrich cannot fly, so this method either throws an exception
    // or does nothing, which breaks the expected behavior of a 'Bird' that can fly.
    public override void Fly()
    {
        throw new NotSupportedException("Ostriches can't fly!");
    }
}
```

-----

### Explain the Interface Segregation Principle (ISP). Why is it better to have many small, specific interfaces than one large, general-purpose interface?

**Answer:**

The **Interface Segregation Principle (ISP)** states that clients should not be forced to depend on methods they do not use. This means it is better to have many small, specific interfaces rather than one large, general-purpose interface.

It's better to use small, specific interfaces because:

  * **Reduced Coupling:** Clients only depend on the interfaces they actually need. This reduces the dependency between classes, making the system more modular and easier to maintain.
  * **Improved Clarity:** Smaller interfaces are easier to understand and implement. A developer looking at a small interface knows exactly what it's for. A large interface with many unrelated methods can be confusing and lead to unnecessary code implementation.
  * **Avoids "Fat" Interfaces:** A large, or "fat," interface can force a class to implement methods it doesn't need, potentially leading to empty method bodies, which is a sign of a design flaw.

**Example of an ISP violation:**

```csharp
// "Fat" interface that is too general
public interface IWorker
{
    void Work();
    void Eat();
    void Sleep();
    void Code();
}

public class Manager : IWorker
{
    public void Work() { /* ... */ }
    public void Eat() { /* ... */ }
    public void Sleep() { /* ... */ }
    // The Manager doesn't code, so this is a violation of ISP.
    public void Code() { throw new NotSupportedException("Managers don't code."); }
}
```

**Adhering to ISP:**

```csharp
public interface IWorkable
{
    void Work();
}

public interface IEatable
{
    void Eat();
}

public interface ICodable
{
    void Code();
}

public class Developer : IWorkable, IEatable, ICodable
{
    public void Work() { /* ... */ }
    public void Eat() { /* ... */ }
    public void Code() { /* ... */ }
}
```

In the second example, `Developer` only implements the interfaces it needs, and the `Manager` class can be created with only the interfaces it needs, avoiding the need to implement irrelevant methods.

-----

### What is the Dependency Inversion Principle (DIP)? How does it differ from traditional dependency and how does it promote loose coupling? What role do interfaces and abstract classes play in adhering to DIP?

**Answer:**

The **Dependency Inversion Principle (DIP)** states that high-level modules should not depend on low-level modules; both should depend on abstractions. Also, abstractions should not depend on details; details should depend on abstractions.

**Traditional vs. Inverted Dependency:**

  * **Traditional Dependency:** In traditional design, a high-level module (e.g., a `PaymentProcessor`) directly depends on and creates an instance of a low-level module (e.g., `CreditCardProcessor`). This creates tight coupling. If you want to change the payment method to `PayPal`, you have to modify the high-level `PaymentProcessor` class.

<!-- end list -->

```csharp
public class CreditCardProcessor
{
    public void ProcessPayment() { /* ... */ }
}

public class PaymentProcessor // High-level module
{
    private CreditCardProcessor _processor = new CreditCardProcessor(); // Direct dependency
    
    public void MakePayment()
    {
        _processor.ProcessPayment();
    }
}
```

  * **Inverted Dependency:** DIP reverses this by introducing an abstraction (an interface or abstract class). Both the high-level and low-level modules depend on this abstraction. The high-level module depends on the interface, and the low-level module implements it. This "inverts" the flow of dependency.

**How DIP promotes loose coupling:**

By depending on an abstraction instead of a concrete implementation, DIP makes the high-level module unaware of the specific details of the low-level module. This promotes **loose coupling**, meaning changes to the low-level module (e.g., swapping `CreditCardProcessor` for a `PayPalProcessor`) do not require changes to the high-level module, as long as the new module implements the same interface.

**Role of Interfaces and Abstract Classes:**

Interfaces and abstract classes are the **abstractions** that DIP requires.

  * **Interfaces:** They define a contract that concrete classes must follow. This allows for dependency injection, where a high-level class receives a low-level class as an interface, and it doesn't care about the concrete implementation.

  * **Abstract Classes:** They can also define a contract and provide some default implementation, which can be extended by derived classes. They serve a similar role to interfaces in providing the necessary abstraction for DIP.

**Example of Adhering to DIP:**

```csharp
// Abstraction (Interface)
public interface IPaymentProcessor
{
    void ProcessPayment();
}

// Low-level modules (concrete implementations)
public class CreditCardProcessor : IPaymentProcessor
{
    public void ProcessPayment() { /* Logic for credit card payment */ }
}

public class PayPalProcessor : IPaymentProcessor
{
    public void ProcessPayment() { /* Logic for PayPal payment */ }
}

// High-level module depends on the abstraction
public class ShoppingCart
{
    private readonly IPaymentProcessor _processor;
    
    // Dependency is injected through the constructor
    public ShoppingCart(IPaymentProcessor processor)
    {
        _processor = processor;
    }
    
    public void Checkout()
    {
        _processor.ProcessPayment();
    }
}
```

In this example, the `ShoppingCart` class (high-level) depends on the `IPaymentProcessor` interface (abstraction), not on a concrete `CreditCardProcessor`. This allows you to easily switch the payment method by injecting a different implementation, promoting a highly flexible and maintainable system.