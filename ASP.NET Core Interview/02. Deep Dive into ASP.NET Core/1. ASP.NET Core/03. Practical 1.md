**Q. You're building a new ASP.NET Core Web API. Show the minimal code needed in Program.cs to set up a simple "Hello, World!" endpoint.**

**A.**  
In ASP.NET Core (.NET 6+), the minimal code for a Web API uses minimal APIs, which allow endpoint setup directly in `Program.cs` without controllers. Here's the minimal `Program.cs` for a "Hello, World!" endpoint at `/hello`:

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("/hello", () => "Hello, World!");

app.Run();
```

This creates a GET endpoint that returns the string "Hello, World!" when accessed at `http://localhost:<port>/hello`. For production, add more configurations like HTTPS redirection or logging.

---

**Q. How would you create a custom middleware that logs the incoming request path and then passes the request to the next middleware in the pipeline?**

**A.**  
Custom middleware in ASP.NET Core is a class that processes HTTP requests/responses. It must have an `InvokeAsync` method that logs the request path and calls the next middleware via `RequestDelegate`.

Here's the custom middleware class:

```csharp
using Microsoft.AspNetCore.Http;
using System.Threading.Tasks;

public class RequestLoggingMiddleware
{
    private readonly RequestDelegate _next;

    public RequestLoggingMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        // Log the request path
        Console.WriteLine($"Incoming request: {context.Request.Path}");

        // Pass to the next middleware
        await _next(context);
    }
}
```

To use it, add an extension method for cleaner registration:

```csharp
public static class RequestLoggingMiddlewareExtensions
{
    public static IApplicationBuilder UseRequestLogging(this IApplicationBuilder builder)
    {
        return builder.UseMiddleware<RequestLoggingMiddleware>();
    }
}
```

In `Program.cs`, add it to the pipeline:

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.UseRequestLogging(); // Add custom middleware

app.MapGet("/", () => "Hello, World!");

app.Run();
```

This middleware logs the path (e.g., "Incoming request: /") and continues the pipeline.

---

**Q. Design a simple Todo API with endpoints for getting all items, getting a single item by ID, adding a new item, and updating an existing one. Demonstrate how you would use attributes for routing ([HttpGet], [HttpPost], etc.) and show the service registration in Program.cs.**

**A.**  
For a simple Todo API, use a controller-based approach with MVC. Define a `TodoItem` model, an in-memory repository for simplicity, and a controller with routing attributes like `[HttpGet]`, `[HttpPost]`, etc.

### Model: TodoItem.cs
```csharp
public class TodoItem
{
    public int Id { get; set; }
    public string Title { get; set; } = string.Empty;
    public bool IsCompleted { get; set; }
}
```

### Repository: ITodoRepository.cs and InMemoryTodoRepository.cs
```csharp
public interface ITodoRepository
{
    List<TodoItem> GetAll();
    TodoItem? GetById(int id);
    void Add(TodoItem item);
    bool Update(int id, TodoItem updatedItem);
}

public class InMemoryTodoRepository : ITodoRepository
{
    private readonly List<TodoItem> _todos = new();
    private int _nextId = 1;

    public List<TodoItem> GetAll() => _todos;

    public TodoItem? GetById(int id) => _todos.FirstOrDefault(t => t.Id == id);

    public void Add(TodoItem item)
    {
        item.Id = _nextId++;
        _todos.Add(item);
    }

    public bool Update(int id, TodoItem updatedItem)
    {
        var existing = GetById(id);
        if (existing == null) return false;

        existing.Title = updatedItem.Title;
        existing.IsCompleted = updatedItem.IsCompleted;
        return true;
    }
}
```

### Controller: TodoController.cs
```csharp
using Microsoft.AspNetCore.Mvc;

[ApiController]
[Route("api/[controller]")]
public class TodoController : ControllerBase
{
    private readonly ITodoRepository _repository;

    public TodoController(ITodoRepository repository)
    {
        _repository = repository;
    }

    [HttpGet]
    public ActionResult<List<TodoItem>> GetAll()
    {
        return Ok(_repository.GetAll());
    }

    [HttpGet("{id}")]
    public ActionResult<TodoItem> GetById(int id)
    {
        var item = _repository.GetById(id);
        return item != null ? Ok(item) : NotFound();
    }

    [HttpPost]
    public ActionResult<TodoItem> Add([FromBody] TodoItem item)
    {
        if (item == null) return BadRequest();
        _repository.Add(item);
        return CreatedAtAction(nameof(GetById), new { id = item.Id }, item);
    }

    [HttpPut("{id}")]
    public ActionResult Update(int id, [FromBody] TodoItem updatedItem)
    {
        if (updatedItem == null) return BadRequest();
        return _repository.Update(id, updatedItem) ? NoContent() : NotFound();
    }
}
```

### Service Registration in Program.cs
Register the repository as a scoped service and add controllers:

```csharp
var builder = WebApplication.CreateBuilder(args);

// Register services
builder.Services.AddScoped<ITodoRepository, InMemoryTodoRepository>();
builder.Services.AddControllers(); // Adds MVC controllers

var app = builder.Build();

app.UseHttpsRedirection();
app.MapControllers(); // Maps attribute-routed controllers

app.Run();
```

This sets up endpoints like `GET /api/todo`, `GET /api/todo/{id}`, `POST /api/todo`, and `PUT /api/todo/{id}`. Data is stored in memory (not persisted).

---

**Q. Your API needs to return different data formats based on the Accept header (e.g., JSON or XML). How does ASP.NET Core handle this automatically? What is the term for this feature?**

**A.**  
ASP.NET Core handles different data formats based on the `Accept` header through **Output Formatters**. This feature is called **Content Negotiation**.

### How It Works Automatically
- **Content Negotiation**: The framework inspects the `Accept` header (e.g., `application/json` or `application/xml`) and selects the appropriate output formatter to serialize the response.
- **Default Behavior**: JSON is the default via `SystemTextJsonOutputFormatter`. For XML, add the `Microsoft.AspNetCore.Mvc.Xml.Serializers` package and configure it.
- **Configuration**: In `Program.cs`, add formatters via `AddControllers` options.

Example to enable both JSON and XML:
```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers(options =>
{
    options.RespectBrowserAcceptHeader = true; // Honor Accept header
    options.OutputFormatters.Add(new XmlSerializerOutputFormatter()); // Add XML support
});

var app = builder.Build();
app.MapControllers();
app.Run();
```

- If the client sends `Accept: application/json`, the response is JSON.
- If `Accept: application/xml`, it's XML (if configured).
- Fallback: Defaults to JSON if no match or unsupported format.

This promotes API flexibility for clients preferring different formats, adhering to REST principles.