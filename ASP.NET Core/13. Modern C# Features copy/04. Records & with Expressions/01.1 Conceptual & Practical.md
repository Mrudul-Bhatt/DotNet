## What is a record in C\#? How is it different from a class?

A **record** in C\# is a special kind of reference type (introduced in C\# 9.0) primarily designed for scenarios where you need to represent **data-centric models** that are focused on **immutability** and **value-based equality**. While they are reference types, they aim to provide "value-like semantics."

**Key Features of Records (by default or easily achievable):**

1.  **Immutability (Default):** Properties declared using the `init` keyword (init-only setters) can only be set during object initialization, making the object immutable after construction. This is a common pattern for data models.
2.  **Value-Based Equality:** Unlike classes (which by default use reference-based equality, meaning two class instances are equal only if they are the *exact same object in memory*), records automatically implement value-based equality. Two record instances are considered equal if all their public property values are equal.
3.  **Concise Syntax for Creation (Primary Constructor):** Records allow for a very concise syntax for defining properties directly in the constructor signature, automatically generating properties and a constructor.
4.  **Non-Destructive Mutation (`with` expression):** Records provide a built-in `with` expression that allows you to create a new instance of the record that is a shallow copy of an existing instance, with specified properties modified. This supports the immutability pattern.
5.  **Built-in `ToString()`:** Records automatically generate a `ToString()` method that prints the name of the record type and the names and values of its public properties, which is very helpful for debugging.
6.  **Deconstruction:** Records automatically generate a `Deconstruct` method, allowing you to easily deconstruct a record into its individual property values.

**How is it different from a class?**

While records are technically `class` types under the hood (they compile to classes), they differ significantly in their **default behaviors and intended use cases**:

| Feature               | `class`                                 | `record`                                  |
| :-------------------- | :-------------------------------------- | :---------------------------------------- |
| **Default Equality** | **Reference-based equality** (`==` checks if same object in memory) | **Value-based equality** (`==` checks if all public property values are equal) |
| **Mutability (Default)** | Mutable by default (`{ get; set; }`)    | **Immutable by default** (`{ get; init; }` with primary constructor or explicit init-only setters) |
| **`ToString()`** | Default `ToString()` (prints type name) | **Auto-generated `ToString()`** (prints type and property values) |
| **`with` expression** | Not available                           | **Available** (for non-destructive mutation) |
| **Deconstruction** | Not automatic (must implement `Deconstruct` manually) | **Automatic** (for properties defined in primary constructor) |
| **Inheritance** | Supports inheritance freely             | Supports inheritance, but with specific considerations for value equality |
| **Primary Use Case** | Objects with identity, behavior-centric | Data models, DTOs, immutable data, value-like types |

**Example:**

```csharp
// --- Class Example ---
public class PersonClass
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
}

// --- Record Example (concise primary constructor syntax) ---
public record PersonRecord(string FirstName, string LastName);

public class Program
{
    public static void Main(string[] args)
    {
        // --- Class Usage ---
        PersonClass class1 = new PersonClass { FirstName = "Alice", LastName = "Smith" };
        PersonClass class2 = new PersonClass { FirstName = "Alice", LastName = "Smith" };

        Console.WriteLine($"Class Equality (by reference): {class1 == class2}"); // Output: False
        Console.WriteLine($"Class ToString(): {class1}"); // Output: PersonClass

        // --- Record Usage ---
        PersonRecord record1 = new PersonRecord("Bob", "Johnson");
        PersonRecord record2 = new PersonRecord("Bob", "Johnson");

        Console.WriteLine($"Record Equality (by value): {record1 == record2}"); // Output: True
        Console.WriteLine($"Record ToString(): {record1}"); // Output: PersonRecord { FirstName = Bob, LastName = Johnson }

        // Record with expression
        PersonRecord record3 = record1 with { LastName = "Williams" };
        Console.WriteLine($"Record Original: {record1}"); // Output: PersonRecord { FirstName = Bob, LastName = Johnson }
        Console.WriteLine($"Record Copied with change: {record3}"); // Output: PersonRecord { FirstName = Bob, LastName = Williams }
    }
}
```

Records are ideal for scenarios like DTOs (Data Transfer Objects), immutable state, and any type where equality should be based on the data they contain rather than their memory address.

-----

## What does the `with` expression do in the context of records?

The **`with` expression** is a feature specifically designed for **records** (and structs with C\# 10) that enables **non-destructive mutation**. It allows you to create a **shallow copy** of an existing record instance, but with one or more specified properties modified, while leaving the original instance completely unchanged.

**How it works:**

The syntax is `originalRecord with { PropertyName = newValue, AnotherProperty = anotherValue }`.

1.  **Creates a New Instance:** The `with` expression *always* creates a brand new instance of the record type. It does not modify the original record.
2.  **Shallow Copy:** All properties of the original record are copied to the new instance. This is a *shallow* copy, meaning if a property is a reference type, only the reference is copied, not the object itself. If you change a mutable reference type property within the new record, the original record would still point to the same (now changed) object.
3.  **Property Overrides:** For any properties specified within the curly braces (`{ ... }`), their values are set to the new values provided in the `with` expression. These new values override the copied values from the original record.

**Example:**

```csharp
public record ProductRecord(int Id, string Name, decimal Price);

public class ProgramWith
{
    public static void Main(string[] args)
    {
        ProductRecord originalProduct = new ProductRecord(1, "Laptop", 1200.00M);
        Console.WriteLine($"Original: {originalProduct}");

        // Create a new record instance, changing only the Price
        ProductRecord updatedProduct = originalProduct with { Price = 1350.00M };
        Console.WriteLine($"Updated Price: {updatedProduct}");
        Console.WriteLine($"Original (unchanged): {originalProduct}"); // Original is still 1200.00M

        // Create another record instance, changing multiple properties
        ProductRecord renamedProduct = originalProduct with
        {
            Id = 2,
            Name = "Gaming Laptop"
        };
        Console.WriteLine($"Renamed: {renamedProduct}");

        // Shallow copy example with a mutable reference type (illustrative, often avoided in truly immutable records)
        public record Order(int Id, List<string> Items);

        Order originalOrder = new Order(101, new List<string> { "ItemA", "ItemB" });
        Order updatedOrder = originalOrder with { }; // Exact shallow copy, not changing anything
        Order newOrderWithNewItem = originalOrder with { Items = new List<string>(originalOrder.Items) { "ItemC" } }; // Create a new list for true immutability
                                                                                                                      // If we didn't use new List<string> then Items would be the same reference.

        originalOrder.Items.Add("ItemZ"); // This modifies the *list object*, not the record reference

        Console.WriteLine($"Original Order Items Count: {originalOrder.Items.Count}"); // Output: 3
        Console.WriteLine($"Updated Order Items Count (shallow copy reflects change): {updatedOrder.Items.Count}"); // Output: 3
        Console.WriteLine($"New Order With New Item (deep copy for list): {newOrderWithNewItem.Items.Count}"); // Output: 3
    }
}
```

The `with` expression is a cornerstone of immutability in records, allowing you to easily create new versions of data without altering existing ones, which is beneficial for thread safety, predictable state, and functional programming patterns.

-----

## Are records immutable by default? How can you make them mutable?

**Yes, records are designed to be immutable by default, especially when using the primary constructor syntax or `init` accessors.**

Let's break it down:

1.  **Immutability with Primary Constructor (Recommended):**
    When you define a record using the concise primary constructor syntax, all the properties declared in the constructor are automatically generated as **init-only properties**. This means they can only be assigned a value during object initialization (either in the constructor or using an object initializer `new MyRecord { Prop = value }`). Once the object is constructed, these properties cannot be changed.

    ```csharp
    public record Person(string FirstName, string LastName, int Age);

    // Usage:
    Person p1 = new Person("Alice", "Smith", 30);
    // p1.Age = 31; // Compile-time error: Init-only property cannot be assigned after initialization
    ```

2.  **Immutability with Explicit `init` Setters:**
    If you define properties explicitly within the record body, you can use the `init` accessor instead of `set` to enforce immutability.

    ```csharp
    public record Product
    {
        public int Id { get; init; }      // Init-only property
        public string Name { get; init; } // Init-only property
        public decimal Price { get; set; } // Mutable property (not init-only)
    }

    // Usage:
    Product prod1 = new Product { Id = 1, Name = "Book", Price = 25.00M };
    // prod1.Id = 2; // Compile-time error
    // prod1.Name = "Magazine"; // Compile-time error
    prod1.Price = 30.00M; // OK, because Price has a 'set' accessor
    ```

**How can you make them mutable?**

While records are *designed* for immutability, you **can intentionally make individual properties mutable** by defining them with a standard `set` accessor (or no `init` accessor if using the old full property syntax) instead of `init`.

**Example of a mutable record property:**

```csharp
public record Settings(string Theme, bool IsDarkMode) // Theme and IsDarkMode are init-only
{
    public int UserCount { get; set; } // This property is fully mutable (has a 'set' accessor)
}

// Usage:
Settings userSettings = new Settings("Dark", true) { UserCount = 10 };

// userSettings.Theme = "Light"; // Compile-time error (init-only)
userSettings.UserCount = 12; // OK, UserCount is mutable
```

**Important Consideration:**

While you *can* make properties mutable in a record, doing so goes against the primary design intent of records. If you find yourself consistently needing mutable properties and relying heavily on reference equality (as classes do), then a `class` might be a more appropriate choice for your data model. Records provide the benefits of value equality, `ToString()`, and `with` expressions primarily when their properties are immutable. Mixing mutable properties with the record semantics can sometimes lead to less clear code or unexpected behavior if not handled carefully.