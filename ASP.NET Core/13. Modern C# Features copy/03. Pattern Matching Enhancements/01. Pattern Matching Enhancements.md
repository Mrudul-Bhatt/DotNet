Today, July 17, 2025, let's explore the powerful evolution of pattern matching in C\# (from C\# 7.0 to 12.0). These enhancements provide a highly declarative and readable way to filter and transform data based on its shape, type, or value, significantly improving branching logic and type safety.

-----

### Pattern Matching Enhancements (C\# 7â€“12)

**Focus:** Declarative data filtering & transformation

Pattern matching in C\# allows you to test if an object has a certain "shape" (its type, its properties' values, its elements' values) and, if it does, extract values from it. This paradigm shifts from imperative `if`/`else if` chains and casts to more expressive and readable conditional logic.

#### 1\. `is` Type Patterns (C\# 7.0)

This was the initial step. It allows you to test if an object is of a certain type *and* simultaneously declare a new variable of that type for further use, all within a single `if` statement.

  * **Syntax:** `expression is Type variableName`
  * **Benefit:** Reduces boilerplate and avoids explicit casting.

**Code Example:**

```csharp
using System;

public class Shape { public string Color { get; set; } = "Unknown"; }
public class Circle : Shape { public double Radius { get; set; } }
public class Rectangle : Shape { public double Width { get; set; } public double Height { get; set; } }
public class Triangle : Shape { public double Base { get; set; } public double Height { get; set; } }

public static class IsTypePatternExample
{
    public static void Run()
    {
        Console.WriteLine("--- `is` Type Patterns (C# 7.0) ---");

        Shape shape1 = new Circle { Radius = 5, Color = "Red" };
        Shape shape2 = new Rectangle { Width = 10, Height = 5, Color = "Blue" };
        Shape shape3 = new Triangle { Base = 6, Height = 8, Color = "Green" };
        object obj = "Hello World";
        Shape nullShape = null!; // Simulate a null shape

        // Traditional approach vs. `is` type pattern
        Console.WriteLine("\n--- Processing Shape 1 ---");
        if (shape1 is Circle circle1) // Tests if shape1 is Circle, and if so, assigns it to circle1
        {
            Console.WriteLine($"It's a circle! Radius: {circle1.Radius}, Color: {circle1.Color}");
        }
        else if (shape1 is Rectangle rect1)
        {
            Console.WriteLine($"It's a rectangle! Width: {rect1.Width}, Height: {rect1.Height}");
        }
        else if (shape1 is Triangle tri1)
        {
            Console.WriteLine($"It's a triangle! Base: {tri1.Base}, Height: {tri1.Height}");
        }
        else
        {
            Console.WriteLine("Unknown shape.");
        }

        Console.WriteLine("\n--- Processing Shape 2 ---");
        if (shape2 is Rectangle rect2)
        {
            Console.WriteLine($"It's a rectangle! Area: {rect2.Width * rect2.Height}, Color: {rect2.Color}");
        }

        Console.WriteLine("\n--- Handling nulls with `is` type pattern ---");
        if (nullShape is Circle circleNull) // Evaluates to false if nullShape is null, no NRE
        {
            Console.WriteLine("This won't be hit.");
        }
        else
        {
            Console.WriteLine("nullShape is null or not a Circle.");
        }

        Console.WriteLine("\n--- `is` type pattern with non-related type ---");
        if (obj is string s)
        {
            Console.WriteLine($"Object is a string: {s.ToUpper()}");
        }
        else
        {
            Console.WriteLine("Object is not a string.");
        }

        Console.WriteLine("--- End `is` Type Patterns ---");
    }
}
```

#### 2\. `switch` Statement with Pattern Matching (C\# 7.0, 8.0, 9.0)

Building on `is` type patterns, `switch` statements gained the ability to match against types, properties, and more, making them powerful for handling multiple distinct cases.

  * **Type Patterns (C\# 7.0):** Cases can match types, just like `is` expressions.
  * **`when` Clause (C\# 7.0):** Adds additional conditions to a pattern.
  * **Property Patterns (C\# 8.0):** Allows matching against the values of an object's properties.
  * **Positional Patterns (C\# 8.0):** Deconstructs an object into its components (if a `Deconstruct` method exists).
  * **Relational Patterns (C\# 9.0):** Match numerical values using `<`, `<=`, `>`, `>=`.
  * **Logical Patterns (`and`, `or`, `not`) (C\# 9.0):** Combine multiple patterns.

**Code Example:**

```csharp
using System;
using System.Drawing; // For Color, often used in examples

public static class SwitchPatternMatchingExample
{
    public static void ProcessShape(Shape shape)
    {
        Console.WriteLine($"\n--- Processing Shape with Switch Patterns ({shape?.GetType().Name ?? "null"}) ---");

        switch (shape)
        {
            // Type pattern (C# 7.0)
            case Circle c:
                Console.WriteLine($"  Found a Circle with radius {c.Radius}");
                break;

            // Type pattern with 'when' clause (C# 7.0)
            case Rectangle r when r.Width == r.Height:
                Console.WriteLine($"  Found a Square (Rectangle with equal sides) of size {r.Width}");
                break;

            // Property pattern (C# 8.0)
            case Rectangle { Width: 10, Height: var h } rec: // Matches Rectangle with Width 10, extracts Height to 'h'
                Console.WriteLine($"  Found a specific 10-wide Rectangle. Height: {h}");
                break;

            // Property pattern with nested property pattern (C# 8.0)
            case Shape { Color: "Red" } redShape:
                Console.WriteLine($"  Found a Red shape of type {redShape.GetType().Name}");
                break;

            // Relational pattern (C# 9.0) - typically used with switch expressions
            // For switch statements, it applies to the target of the switch, not properties directly.
            // But can be used via 'when' clause:
            case Circle c when c.Radius > 10:
                Console.WriteLine($"  Found a LARGE Circle with radius {c.Radius}");
                break;

            // Logical patterns (C# 9.0)
            case Circle c and { Radius: < 5 }: // Matches a Circle AND its radius is less than 5
                Console.WriteLine($"  Found a small circle with radius {c.Radius}");
                break;
            case null: // Handles null input explicitly (C# 8.0)
                Console.WriteLine("  Input shape is null.");
                break;
            default: // Catches any other shape or non-shape object
                Console.WriteLine($"  Found an unknown shape or type: {shape?.GetType().Name}");
                break;
        }
    }

    public static void Run()
    {
        ProcessShape(new Circle { Radius = 5, Color = "Green" });
        ProcessShape(new Circle { Radius = 2, Color = "Blue" });
        ProcessShape(new Circle { Radius = 12, Color = "Yellow" });
        ProcessShape(new Rectangle { Width = 5, Height = 5, Color = "Purple" });
        ProcessShape(new Rectangle { Width = 10, Height = 7, Color = "Orange" });
        ProcessShape(new Triangle { Base = 3, Height = 4, Color = "Red" });
        ProcessShape(null);
        ProcessShape("Not a shape"); // Using object as switch target
    }
}
```

#### 3\. `switch` Expressions (C\# 8.0)

A more concise and functional alternative to the `switch` statement, designed to *produce a value* based on patterns. It's an expression, not a statement, meaning it can be used directly in assignments or as method arguments.

  * **Syntax:** `expression switch { pattern => result, ... }`
  * **Key Features:**
      * No `break` statements.
      * No fall-through.
      * Arrow `=>` separates pattern from result.
      * Comma `,` separates cases.
      * `_` for the default case (replaces `default:`).
      * Integrates all pattern types (type, property, relational, logical, tuple).

**Code Example:**

```csharp
using System;

public static class SwitchExpressionExample
{
    public static string GetShapeDescription(Shape? shape)
    {
        // Switch expression
        string description = shape switch
        {
            // Type pattern
            Circle c => $"Circle (R={c.Radius}, Color={c.Color})",

            // Property pattern with nested pattern
            Rectangle { Width: var w, Height: var h, Color: "Red" } => $"Red Rectangle ({w}x{h})",

            // Property pattern with relational and logical patterns
            Rectangle { Width: > 10 } r and { Height: > 10 } => $"Large Rectangle (>10x>10) ({r.Width}x{r.Height})",

            // Relational pattern (works well for numeric types too)
            // int score when score >= 90 => "Excellent",
            // int score when score >= 70 => "Good",

            // Positional pattern (requires a Deconstruct method on the type)
            // For Shape class to work with positional pattern:
            // public void Deconstruct(out string color) { color = Color; }
            // case Shape("Blue") => "Blue shape", // Example if Shape had Deconstruct

            // Tuple pattern (C# 8.0)
            (int x, int y) when x == y => $"Coordinates ({x},{y}) are equal.", // For a tuple input

            // Null pattern (C# 8.0)
            null => "No shape provided.",

            // Discard pattern (default case)
            _ => $"Generic shape ({shape.Color})" // Handles any other Shape or non-Shape object
        };
        return description;
    }

    // Example with tuple pattern
    public static string GetPointQuadrant(Point point) =>
        point switch
        {
            (> 0, > 0) => "First Quadrant",
            (< 0, > 0) => "Second Quadrant",
            (< 0, < 0) => "Third Quadrant",
            (> 0, < 0) => "Fourth Quadrant",
            (0, 0) => "Origin",
            (_, 0) => "On X-axis", // Covers (x,0) where x != 0
            (0, _) => "On Y-axis"  // Covers (0,y) where y != 0
        };

    public record Point(int X, int Y); // C# 9.0 record for brevity, provides Deconstruct implicitly

    public static void Run()
    {
        Console.WriteLine("--- `switch` Expressions (C# 8.0+) ---");

        Console.WriteLine(GetShapeDescription(new Circle { Radius = 7, Color = "Green" }));
        Console.WriteLine(GetShapeDescription(new Rectangle { Width = 15, Height = 12, Color = "Blue" }));
        Console.WriteLine(GetShapeDescription(new Rectangle { Width = 8, Height = 6, Color = "Red" }));
        Console.WriteLine(GetShapeDescription(null));
        Console.WriteLine(GetShapeDescription(new Triangle { Base = 3, Height = 4, Color = "Yellow" })); // Hits discard pattern

        Console.WriteLine($"\nPoint Quadrants:");
        Console.WriteLine($"Point (1,1): {GetPointQuadrant(new Point(1, 1))}");
        Console.WriteLine($"Point (-1,1): {GetPointQuadrant(new Point(-1, 1))}");
        Console.WriteLine($"Point (-1,-1): {GetPointQuadrant(new Point(-1, -1))}");
        Console.WriteLine($"Point (1,-1): {GetPointQuadrant(new Point(1, -1))}");
        Console.WriteLine($"Point (0,0): {GetPointQuadrant(new Point(0, 0))}");
        Console.WriteLine($"Point (5,0): {GetPointQuadrant(new Point(5, 0))}");
        Console.WriteLine($"Point (0, -5): {GetPointQuadrant(new Point(0, -5))}");

        Console.WriteLine("--- End `switch` Expressions ---");
    }
}
```

#### 4\. Extended Patterns (C\# 9.0+)

  * **Relational Patterns:** Already shown with `> 10`. Can be used directly in `is` expressions: `if (score is >= 90)`.
  * **Logical Patterns (`and`, `or`, `not`):** Allow combining patterns for complex conditions.
      * `if (obj is not null)` (replaces `if (obj != null)`)
      * `case int i and (> 0 and < 100)`
  * **Parenthesized Patterns:** For explicit grouping.
  * **Type Patterns with `not null`:** `case MyClass not null:` (explicitly matches non-null instances).

**Code Example:**

```csharp
using System;

public static class ExtendedPatternsExample
{
    public static string EvaluateScore(int score) => score switch
    {
        // Relational pattern
        >= 90 => "Excellent",
        >= 70 and < 90 => "Good", // Logical 'and'
        >= 50 and < 70 => "Average",
        < 50 => "Poor",
        _ => "Invalid Score"
    };

    public static void CheckObjectType(object? obj)
    {
        Console.WriteLine($"\n--- Checking Object Type for '{obj?.GetType().Name ?? "null"}' ---");

        // Logical 'not' pattern (C# 9.0)
        if (obj is not null) // Cleaner than obj != null
        {
            Console.WriteLine("  Object is not null.");
        }
        else
        {
            Console.WriteLine("  Object is null.");
        }

        // Logical 'or' pattern (C# 9.0)
        if (obj is int or string)
        {
            Console.WriteLine($"  Object is an int or a string.");
        }

        // Combining patterns for complex conditions
        if (obj is Rectangle { Width: var w, Height: var h } and { Color: "Blue" or "Green" })
        {
            Console.WriteLine($"  It's a blue or green rectangle: {w}x{h}");
        }
        else if (obj is Circle { Radius: > 10 } and not { Color: "Red" })
        {
            Console.WriteLine($"  It's a large circle not red: {(obj as Circle)?.Radius}");
        }
    }

    public static void Run()
    {
        Console.WriteLine("--- Extended Patterns (C# 9.0+) ---");

        Console.WriteLine($"Score 95: {EvaluateScore(95)}");
        Console.WriteLine($"Score 75: {EvaluateScore(75)}");
        Console.WriteLine($"Score 40: {EvaluateScore(40)}");

        CheckObjectType(null);
        CheckObjectType("Some text");
        CheckObjectType(123);
        CheckObjectType(new Rectangle { Width = 5, Height = 5, Color = "Blue" });
        CheckObjectType(new Circle { Radius = 15, Color = "Green" });
        CheckObjectType(new Circle { Radius = 8, Color = "Red" });

        Console.WriteLine("--- End Extended Patterns ---");
    }
}
```

#### 5\. List Patterns (C\# 11)

Allows matching against sequences of elements in arrays or lists.

  * **Syntax:** `[pattern1, pattern2, ..., patternN]`
  * **`..` (Range Pattern):** Matches zero or more elements.
  * **Discard `_` in List Patterns:** Matches a single element without capturing it.

**Code Example:**

```csharp
using System;
using System.Collections.Generic;

public static class ListPatternsExample
{
    public static string AnalyzeSequence(int[] numbers)
    {
        return numbers switch
        {
            [] => "Empty sequence", // Matches an empty array/list
            [1, 2, 3] => "Sequence 1, 2, 3", // Exact match
            [1, ..] => "Starts with 1", // Starts with 1, followed by any number of elements
            [.., 5] => "Ends with 5", // Ends with 5, preceded by any number of elements
            [_, _, 3] => "Third element is 3", // Matches any two elements then 3
            [1, _, ..] => "Starts with 1, second element is anything", // C# 11: Combines discard and range
            [var first, ..] => $"Starts with {first}", // Captures first element
            _ => "Other sequence"
        };
    }

    public static string AnalyzeStringList(List<string> words)
    {
        return words switch
        {
            ["apple", "banana"] => "Apple and Banana",
            ["orange", ..] => "Starts with orange",
            [_, "grape", ..] => "Has grape as second element",
            [.. , "kiwi", "mango"] => "Ends with kiwi and mango",
            _ => "Various words"
        };
    }

    public static void Run()
    {
        Console.WriteLine("--- List Patterns (C# 11) ---");

        Console.WriteLine($"[1, 2, 3]: {AnalyzeSequence(new[] { 1, 2, 3 })}");
        Console.WriteLine($"[1, 4, 5]: {AnalyzeSequence(new[] { 1, 4, 5 })}");
        Console.WriteLine($"[7, 8, 5]: {AnalyzeSequence(new[] { 7, 8, 5 })}");
        Console.WriteLine($"[4, 5, 3]: {AnalyzeSequence(new[] { 4, 5, 3 })}");
        Console.WriteLine($"[]: {AnalyzeSequence(new int[] { })}");
        Console.WriteLine($"[1]: {AnalyzeSequence(new[] { 1 })}"); // Starts with 1
        Console.WriteLine($"[1, 10]: {AnalyzeSequence(new[] { 1, 10 })}"); // Starts with 1, second element is anything
        Console.WriteLine($"[10, 20, 30]: {AnalyzeSequence(new[] { 10, 20, 30 })}"); // Other sequence

        Console.WriteLine("\n--- String List Patterns ---");
        Console.WriteLine($"[\"apple\", \"banana\"]: {AnalyzeStringList(new List<string> { "apple", "banana" })}");
        Console.WriteLine($"[\"orange\", \"peach\"]: {AnalyzeStringList(new List<string> { "orange", "peach" })}");
        Console.WriteLine($"[\"melon\", \"grape\", \"fig\"]: {AnalyzeStringList(new List<string> { "melon", "grape", "fig" })}");
        Console.WriteLine($"[\"lime\", \"kiwi\", \"mango\"]: {AnalyzeStringList(new List<string> { "lime", "kiwi", "mango" })}");

        Console.WriteLine("--- End List Patterns ---");
    }
}
```

#### 6\. Extended `nameof` in pattern matching (C\# 11)

Allows using `nameof` directly within a property pattern.

  * **Syntax:** `case { Property: nameof(SomeValue) }`

**Code Example:**

```csharp
using System;

public class UserStatus
{
    public string Status { get; set; } = string.Empty;

    public const string Active = "ACTIVE";
    public const string Inactive = "INACTIVE";
    public const string Pending = "PENDING";
}

public static class NameofPatternExample
{
    public static string GetUserStatusDescription(UserStatus status)
    {
        return status switch
        {
            // Using nameof in property pattern
            { Status: UserStatus.Active } => "User is currently active.",
            { Status: UserStatus.Inactive } => "User account is disabled.",
            { Status: UserStatus.Pending } => "User requires activation.",
            _ => "Unknown user status."
        };
    }

    public static void Run()
    {
        Console.WriteLine("--- Extended `nameof` in Pattern Matching (C# 11) ---");

        UserStatus activeUser = new UserStatus { Status = UserStatus.Active };
        UserStatus inactiveUser = new UserStatus { Status = UserStatus.Inactive };
        UserStatus pendingUser = new UserStatus { Status = UserStatus.Pending };
        UserStatus suspendedUser = new UserStatus { Status = "SUSPENDED" };

        Console.WriteLine($"Active User: {GetUserStatusDescription(activeUser)}");
        Console.WriteLine($"Inactive User: {GetUserStatusDescription(inactiveUser)}");
        Console.WriteLine($"Pending User: {GetUserStatusDescription(pendingUser)}");
        Console.WriteLine($"Suspended User: {GetUserStatusDescription(suspendedUser)}");

        Console.WriteLine("--- End Extended `nameof` ---");
    }
}
```

#### 7\. Readonly Structs in Pattern Matching (C\# 12)

C\# 12 allows `readonly struct` to be used in positional patterns.

**Code Example:**

```csharp
using System;

public readonly struct Point3D(int x, int y, int z) // Primary constructor for readonly struct (C# 12)
{
    public int X { get; } = x;
    public int Y { get; } = y;
    public int Z { get; } = z;

    // A Deconstruct method is implicitly generated for records and for primary constructors on structs.
    // For older structs, you'd explicitly write:
    // public void Deconstruct(out int x, out int y, out int z) { x = X; y = Y; z = Z; }
}

public static class ReadonlyStructPatternExample
{
    public static string DescribePoint3D(Point3D point)
    {
        return point switch
        {
            (0, 0, 0) => "Origin", // Positional pattern for readonly struct
            (_, 0, 0) => "On X-axis",
            (0, _, 0) => "On Y-axis",
            (0, 0, _) => "On Z-axis",
            (var x, var y, var z) when x > 0 && y > 0 && z > 0 => "First Octant",
            _ => $"General point ({point.X},{point.Y},{point.Z})"
        };
    }

    public static void Run()
    {
        Console.WriteLine("--- Readonly Structs in Pattern Matching (C# 12) ---");

        Console.WriteLine($"Point (0,0,0): {DescribePoint3D(new Point3D(0, 0, 0))}");
        Console.WriteLine($"Point (5,0,0): {DescribePoint3D(new Point3D(5, 0, 0))}");
        Console.WriteLine($"Point (0,10,0): {DescribePoint3D(new Point3D(0, 10, 0))}");
        Console.WriteLine($"Point (0,0,-3): {DescribePoint3D(new Point3D(0, 0, -3))}");
        Console.WriteLine($"Point (1,2,3): {DescribePoint3D(new Point3D(1, 2, 3))}");
        Console.WriteLine($"Point (-1,-2,-3): {DescribePoint3D(new Point3D(-1, -2, -3))}");

        Console.WriteLine("--- End Readonly Structs ---");
    }
}
```

### Interview Focus: Readable Branching Logic, Type-Safe Filters

Pattern matching is a core modern C\# feature, and interviewers expect you to be familiar with its benefits and usage.

1.  **Readable Branching Logic:**

      * **Question:** "How would you handle complex conditional logic that depends on the type and state of an object in a clean way?"
      * **Answer:** Pattern matching, especially `switch` expressions. Instead of nested `if-else if` blocks with explicit `is` checks and casts, pattern matching allows you to express conditions declaratively (`case MyType { Property: value }`). This makes the code much easier to read and understand at a glance. It's often compared to functional programming's ability to express transformations based on data shape.

2.  **Type-Safe Filters:**

      * **Question:** "How do pattern matching features improve type safety compared to older C\# approaches?"
      * **Answer:**
          * **Eliminates Explicit Casts:** `if (obj is MyType myObj)` avoids the need for `MyType myObj = (MyType)obj;` which could throw an `InvalidCastException`. The pattern ensures the cast is safe.
          * **Compile-time Checks:** The compiler performs extensive analysis. If you try to match a pattern that's impossible or introduce type errors, the compiler will catch it.
          * **Exhaustiveness Checks (for `switch` expressions with sealed types):** While not fully exhaustive for all types, for sealed hierarchies or enums, the compiler can warn if you don't cover all possible cases, preventing unhandled states at runtime.
          * **Null Handling:** Patterns like `case null:` explicitly handle `null` values, preventing `NullReferenceException`s that might occur with implicit assumptions. The `is not null` pattern is also very useful here.

3.  **Conciseness and Expressiveness:**

      * **Question:** "Compare `if (obj is Type variable)` with `if (obj is Type) { Type variable = (Type)obj; }`."
      * **Answer:** The `is` type pattern is much more concise, performing the type check and variable assignment in one go. It's also safer because the cast only happens if the type matches.

4.  **When to Use `switch` Statement vs. `switch` Expression:**

      * **Question:** "When would you use a `switch` statement vs. a `switch` expression?"
      * **Answer:**
          * **`switch` Statement:** When the primary goal is to perform *different actions* (side effects) based on conditions, and you don't necessarily need to produce a value.
          * **`switch` Expression:** When the primary goal is to *produce a value* (like calculating a description, a price, or a new object) based on conditions. It's an expression, so it can be used directly in assignments, `return` statements, etc., leading to more functional-style code.

5.  **Newer Patterns (Relational, Logical, List):**

      * **Question:** "Describe a scenario where relational or logical patterns would be particularly useful."
      * **Answer:**
          * **Relational:** Processing scores/grades (`score is >= 90`), age groups (`age is < 18`), or price tiers.
          * **Logical:** Combining multiple conditions for a single case, like `case int i and (> 0 and < 100)` for a positive integer within a specific range, or `if (obj is not null and not int)` to exclude nulls and integers.
          * **List Patterns:** Parsing command-line arguments, analyzing sequence data (e.g., specific header bytes in a file, specific order of events), or validating array shapes.

By demonstrating a strong understanding of these pattern matching features, you show proficiency in writing modern, readable, and robust C\# code.